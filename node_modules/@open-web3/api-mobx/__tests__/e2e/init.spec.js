"use strict";

var _mobx = require("mobx");

var _api = require("@polkadot/api");

var _rpcProvider = require("@polkadot/rpc-provider");

var _ = require("../..");

describe('api-mobx', () => {
  jest.setTimeout(30000);
  let api;
  let storage;
  beforeAll(async () => {
    const ws = new _rpcProvider.WsProvider('wss://kusama-rpc.polkadot.io/');
    api = await _api.ApiPromise.create({
      provider: ws
    });
    storage = (0, _.createStorage)(api, ws);
  });
  it('block hash works', done => {
    (0, _mobx.autorun)(() => {
      const hash = storage.block.hash;
      hash && console.dir(hash);

      if (hash) {
        done();
      }
    });
  });
  it('starts with null', done => {
    let tick = 0;
    (0, _mobx.autorun)(() => {
      const parentHash = storage.system.parentHash;

      if (tick === 0) {
        expect(parentHash).toBeNull();
      } else {
        expect(parentHash).toBeTruthy();
        done();
      }

      tick++;
    });
  });
  it('account works', done => {
    (0, _mobx.autorun)(() => {
      const alice = api.createType('AccountId', 'CtwdfrhECFs3FpvCGoiE4hwRC4UsSiM8WL899HjRdQbfYZY');
      const account = storage.system.account(alice);
      account && console.dir(account.toHuman());

      if (account) {
        done();
      }
    });
  });
  it('StorageMap entries works', done => {
    (0, _mobx.autorun)(() => {
      const validators = storage.staking.validators.entries();
      console.log(validators.keys());
      console.dir([...validators.values()].map(value => value.toHuman()));

      if (validators.size > 0) {
        done();
      }
    });
  });
  it('StorageMap with key works', done => {
    (0, _mobx.autorun)(() => {
      const validator = storage.staking.validators('HYxzaXwkydDNAy3R8UnCvfprNm74TwwSELpyXSRoqmy9AQY');
      validator && console.log(validator.toHuman());

      if (validator) {
        done();
      }
    });
  });
  it('StorageDoubleMap allEntries works', done => {
    (0, _mobx.autorun)(() => {
      let result = storage.staking.erasValidatorPrefs.allEntries();
      const keys = Array.from(result.keys());
      const values = Array.from(result.values());

      if (keys.length > 0) {
        console.log(keys[0]);

        for (const rawValue of values[0]) {
          for (const [key, value] of rawValue.entries()) {
            console.log(key, value.toString());
            done();
            return;
          }
        }
      }
    });
  }, 60000);
  it('StorageDoubleMap with key1 works', done => {
    (0, _mobx.autorun)(() => {
      let result = storage.staking.erasValidatorPrefs.entries(2421);

      if (result) {
        const keys = Array.from(result.keys());
        const values = Array.from(result.entries());
        const [key, value] = values[0];
        console.log(key, value.toString());

        if (keys.length > 0) {
          console.log(keys[0]);
          done();
        }
      }
    });
  });
  it('StorageDoubleMap with key1 & key2 works', done => {
    (0, _mobx.autorun)(() => {
      let result = storage.staking.erasValidatorPrefs(0, 'CtwdfrhECFs3FpvCGoiE4hwRC4UsSiM8WL899HjRdQbfYZY');
      result && console.log(result.toJSON());

      if (result) {
        done();
      }
    });
  });
});