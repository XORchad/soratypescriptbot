import { CodecString, FPNumber, NumberLike } from '@sora-substrate/math';
import type { CreateResult } from '@polkadot/ui-keyring/types';
import type { KeyringPair, KeyringPair$Json, KeyringPair$Meta } from '@polkadot/keyring/types';
import type { Signer } from '@polkadot/types/types';
import { BaseApi, OnChainIdentity } from './BaseApi';
import { BridgeProxyModule } from './bridgeProxy';
import { SwapModule } from './swap';
import { RewardsModule } from './rewards';
import { PoolXykModule } from './poolXyk';
import { ReferralSystemModule } from './referralSystem';
import { AssetsModule } from './assets';
import { OrderBookModule } from './orderBook';
import { MstTransfersModule } from './mstTransfers';
import { SystemModule } from './system';
import { StakingModule } from './staking';
import { DemeterFarmingModule } from './demeterFarming';
import { DexModule } from './dex';
import { CeresLiquidityLockerModule } from './ceresLiquidityLocker';
import type { Storage } from './storage';
import type { AccountAsset, Asset } from './assets/types';
/**
 * Contains all necessary data and functions for the wallet & polkaswap client
 */
export declare class Api<T = void> extends BaseApi<T> {
    private readonly type;
    readonly defaultSlippageTolerancePercent = 0.5;
    readonly seedLength = 12;
    readonly bridgeProxy: BridgeProxyModule<T>;
    readonly swap: SwapModule<T>;
    readonly rewards: RewardsModule<T>;
    readonly poolXyk: PoolXykModule<T>;
    readonly referralSystem: ReferralSystemModule<T>;
    readonly assets: AssetsModule<T>;
    readonly orderBook: OrderBookModule<T>;
    /** This module is used for internal needs */
    readonly mstTransfers: MstTransfersModule<T>;
    readonly system: SystemModule<T>;
    readonly staking: StakingModule<T>;
    readonly demeterFarming: DemeterFarmingModule<T>;
    readonly dex: DexModule<T>;
    readonly ceresLiquidityLocker: CeresLiquidityLockerModule<T>;
    initAccountStorage(): void;
    /**
     * Remove all history
     * @param assetAddress If it's empty then all history will be removed, else - only history of the specific asset
     */
    clearHistory(assetAddress?: string): void;
    /**
     * Set storage if it should be used as data storage
     * @param storage
     */
    setStorage(storage: Storage): void;
    /**
     * Set signer if the pair is locked (For polkadot js extension usage)
     * @param signer
     */
    setSigner(signer: Signer): void;
    /**
     * Set account data
     * @param account
     */
    setAccount(account: CreateResult): void;
    initKeyring(silent?: boolean): Promise<void>;
    restoreActiveAccount(): Promise<void>;
    /**
     * The first method you should run. Includes initialization process
     * @param withKeyringLoading `true` by default
     */
    initialize(withKeyringLoading?: boolean): Promise<void>;
    /**
     * Before use the seed for wallet connection you may want to check its correctness
     * @param suri Seed which is set by the user
     */
    checkSeed(suri: string): {
        address: string;
        suri: string;
    };
    /**
     * Get on-chain account's identity
     * @param address account address
     */
    getAccountOnChainIdentity(address: string): Promise<OnChainIdentity | null>;
    private updateAccountData;
    /**
     * Login to account
     * @param address account address
     * @param name account name
     * @param source wallet identity
     * @param isExternal is account from extension or not
     */
    loginAccount(address: string, name?: string, source?: string, isExternal?: boolean): Promise<void>;
    /**
     * Import account using credentials
     * @param suri Seed of the account
     * @param name Name of the account
     * @param password Password which will be set for the account
     */
    addAccount(suri: string, name: string, password: string): CreateResult;
    /**
     * Create account pair from json
     * @param json account json
     * @param meta account meta
     */
    createAccountPairFromJson(json: KeyringPair$Json, meta?: KeyringPair$Meta): KeyringPair;
    /**
     * Create an account pair
     * It could be added to account list using addAccountPair method
     * @param suri Seed of the account
     * @param name Name of the account
     */
    createAccountPair(suri: string, name?: string): KeyringPair;
    /**
     * Get already imported account pair by address
     * @param address account address
     */
    getAccountPair(address: string): KeyringPair;
    /**
     * Import account using account pair
     * @param pair account pair to add
     * @param password account password
     */
    addAccountPair(pair: KeyringPair, password: string): void;
    /**
     * Import account & login
     * @param suri Seed of the account
     * @param name Name of the account
     * @param password Password which will be set for the account
     */
    importAccount(suri: string, name: string, password: string): void;
    /**
     * Get all imported accounts.
     * It returns list of imported accounts
     * added via api.importAccount()
     */
    getAccounts(): import("@polkadot/ui-keyring/types").KeyringAddress[];
    /**
     * Change the account password.
     * It generates an error if `oldPassword` is invalid
     * @param oldPassword
     * @param newPassword
     */
    changeAccountPassword(oldPassword: string, newPassword: string): void;
    /**
     * Change the account name
     * TODO: check it, polkadot-js extension doesn't change account name
     * @param address account address
     * @param name New name
     */
    changeAccountName(address: string, name: string): void;
    /**
     * Restore from JSON object.
     * Adds it to keyring storage
     * It generates an error if JSON or/and password are not valid
     * @param json
     * @param password
     */
    restoreAccountFromJson(json: KeyringPair$Json, password: string): {
        address: string;
        name: string;
    };
    /**
     * Export a JSON with the account data
     * @param password
     * @param encrypted If `true` then it will be decrypted. `false` by default
     */
    exportAccount(pair: KeyringPair, password: string, encrypted?: boolean): string;
    /**
     * Create seed phrase. It returns `{ address, seed }` object.
     */
    createSeed(): {
        address: string;
        seed: string;
    };
    /**
     * Transfer amount from account
     * @param asset Asset object
     * @param toAddress Account address
     * @param amount Amount value
     */
    transfer(asset: Asset | AccountAsset, toAddress: string, amount: NumberLike): Promise<T>;
    /**
     * Forget account from keyring
     * @param address account address to forget
     */
    forgetAccount(address?: string): void;
    /**
     * Remove all wallet data
     */
    logout(): void;
    hasEnoughXor(asset: AccountAsset, amount: string | number, fee: FPNumber | CodecString): boolean;
    private divideAssetsInternal;
    /**
     * Divide the first asset by the second
     * @param firstAsset
     * @param secondAsset
     * @param firstAmount
     * @param secondAmount
     * @param reversed If `true`: the second by the first (`false` by default)
     * @returns Formatted string
     */
    divideAssets(firstAsset: Asset | AccountAsset, secondAsset: Asset | AccountAsset, firstAmount: NumberLike, secondAmount: NumberLike, reversed?: boolean): string;
    /**
     * Divide the first asset by the second
     * @param firstAssetAddress
     * @param secondAssetAddress
     * @param firstAmount
     * @param secondAmount
     * @param reversed If `true`: the second by the first (`false` by default)
     * @returns Promise with formatted string
     */
    divideAssetsByAssetIds(firstAssetAddress: string, secondAssetAddress: string, firstAmount: NumberLike, secondAmount: NumberLike, reversed?: boolean): Promise<string>;
}
/** Api object */
export declare const api: Api<void>;
