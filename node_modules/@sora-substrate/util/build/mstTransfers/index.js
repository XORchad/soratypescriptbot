"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MstTransfersModule = void 0;
var _util = require("@polkadot/util");
var _math = require("@sora-substrate/math");
var _logger = require("../logger");
var _BaseApi = require("../BaseApi");
/**
 * This module is used for internal needs
 */
class MstTransfersModule {
  constructor(root) {
    this.root = root;
  }

  /**
   * Returns batch tx
   * @param data List with data for Transfer All Tx
   */
  prepareCall(data) {
    (0, _util.assert)(data.length, _logger.Messages.noTransferData);
    const txs = data.map(item => {
      return this.root.api.tx.assets.transfer(item.assetAddress, item.toAddress, new _math.FPNumber(item.amount).toCodecString());
    });
    return this.root.api.tx.utility.batchAll(txs);
  }

  /**
   * Returns the final extrinsic for Trnaser All MST transaction
   * @param call `api.prepareTransferAllAsMstCall` result
   * @param threshold Minimum number of signers
   * @param coSigners List of co-signers
   */
  prepareExtrinsic(call, threshold, coSigners) {
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    const MAX_WEIGHT = 640000000;
    // TODO: [MST] check MAX_WEIGHT arg
    return this.root.api.tx.multisig.approveAsMulti(threshold, coSigners, null, call.method.hash, `${MAX_WEIGHT}`);
  }

  /**
   * Get network fee for Transfer All MST Tx
   * @param extrinsic `api.prepareTransferAllAsMstExtrinsic` result
   */
  async getNetworkFee(tx) {
    return await this.root.getTransactionFee(tx);
  }

  /**
   * Transfer all data from array as MST
   * @param extrinsic `api.prepareTransferAllAsMstExtrinsic` result
   */
  submit(extrinsic) {
    return this.root.submitExtrinsic(extrinsic, this.root.account.pair, {
      type: _BaseApi.Operation.TransferAll
    });
  }

  /**
   * Get the last (frist from array of multisigns) pending TX from MST
   * @param mstAccount MST account
   */
  async getLastPendingTx(mstAccount) {
    try {
      const pendingData = await this.root.api.query.multisig.multisigs.entries(mstAccount);
      return pendingData.map(_ref => {
        let [item, _] = _ref;
        return item.args[1].toString();
      })[0];
    } catch {
      return null;
    }
  }
}
exports.MstTransfersModule = MstTransfersModule;