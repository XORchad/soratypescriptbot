"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AssetsModule = void 0;
exports.excludePoolXYKAssets = excludePoolXYKAssets;
exports.formatBalance = formatBalance;
exports.getAssetBalance = getAssetBalance;
exports.getAssets = getAssets;
exports.getBalance = getBalance;
exports.getLegalAssets = getLegalAssets;
exports.isBlacklistedAssetAddress = isBlacklistedAssetAddress;
exports.isNativeAsset = isNativeAsset;
var _util = require("@polkadot/util");
var _rxjs = require("rxjs");
var _math = require("@sora-substrate/math");
var _consts = require("./consts");
var _consts2 = require("../poolXyk/consts");
var _logger = require("../logger");
var _BaseApi = require("../BaseApi");
/**
 * **For the external collaboration**
 *
 * Useful method for balance formatting
 *
 * @param data Account Data for ORML tokens or for PalletBalances
 * @param assetDecimals Asset decimals, 18 is used by default
 * @param bondedData Required only for XOR tokens in SORA network
 */
function formatBalance(data, assetDecimals, bondedData) {
  const free = new _math.FPNumber(data.free || 0, assetDecimals);
  const reserved = new _math.FPNumber(data.reserved || 0, assetDecimals);
  // [Substrate 4: PalletBalancesAccountData]
  const miscFrozen = new _math.FPNumber(data.miscFrozen || 0, assetDecimals);
  // [Substrate 4: PalletBalancesAccountData]
  const feeFrozen = new _math.FPNumber(data.feeFrozen || 0, assetDecimals);
  const frozenDeprecated = _math.FPNumber.max(miscFrozen, feeFrozen);
  // [Substrate 5: PalletBalancesAccountData] & OrmlTokensAccountData
  const frozenCurrent = new _math.FPNumber(data.frozen || 0, assetDecimals);
  const frozen = _math.FPNumber.max(frozenCurrent, frozenDeprecated);
  // [SORA] bondedData can be NaN, it can be checked by isEmpty===true
  const bonded = new _math.FPNumber(!bondedData || bondedData.isEmpty ? 0 : bondedData, assetDecimals);
  // [SORA]
  const locked = reserved.add(frozen).add(bonded);
  return {
    free: free.toCodecString(),
    reserved: reserved.toCodecString(),
    frozen: frozen.toCodecString(),
    bonded: bonded.toCodecString(),
    locked: locked.toCodecString(),
    total: free.add(locked).toCodecString(),
    transferable: free.sub(frozen).toCodecString()
  };
}
async function getAssetInfo(api, address) {
  const [symbol, name, decimals, _, content, description] = (await api.query.assets.assetInfos({
    code: address
  })).toHuman();
  return {
    address,
    symbol,
    name,
    decimals: +decimals,
    content,
    description
  };
}

/**
 * **For the external collaboration**
 *
 * Returns Asset Balance.
 *
 * If Asset ID == XOR, referrals.referrerBalances will be included as bonded
 *
 * @param api Polkadot based API object
 * @param accountAddress Account ID
 * @param assetAddress Asset ID
 * @param assetDecimals Asset decimals, 18 is used by default
 */
async function getAssetBalance(api, accountAddress, assetAddress) {
  let assetDecimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 18;
  if (assetAddress === _consts.XOR.address) {
    const [accountInfo, bondedBalance] = await Promise.all([api.query.system.account(accountAddress), api.query.referrals.referrerBalances(accountAddress)]);
    return formatBalance(accountInfo.data, assetDecimals, bondedBalance);
  }
  const accountData = await api.query.tokens.accounts(accountAddress, assetAddress);
  return formatBalance(accountData, assetDecimals);
}
function isRegisteredAsset(asset, whitelist) {
  if (!asset.address) {
    return false;
  }
  return !!whitelist[asset.address];
}

/**
 * Used *ONLY* for faucet
 */
function getBalance(api, accountAddress, assetAddress) {
  return api.rpc.assets.usableBalance(accountAddress, assetAddress);
}
function isNativeAsset(asset) {
  if (!asset.address) {
    return false;
  }
  return !!_consts.NativeAssets.get(asset.address);
}
function excludePoolXYKAssets(assets) {
  return assets.filter(asset => asset.symbol !== _consts2.PoolTokens.XYKPOOL);
}
function isBlacklistedAssetAddress(address, blacklist) {
  return blacklist.includes(address);
}
function getLegalAssets(allAssets, blacklist) {
  if (!blacklist.length) return allAssets;
  return allAssets.filter(_ref => {
    let {
      address
    } = _ref;
    return !isBlacklistedAssetAddress(address, blacklist);
  });
}
async function getAssets(api, whitelist, blacklist) {
  const allAssets = (await api.query.assets.assetInfos.entries()).map(_ref2 => {
    let [key, codec] = _ref2;
    const address = key.args[0].code.toString();
    const [symbol, name, decimals, _, content, description] = codec.toHuman();
    return {
      address,
      symbol,
      name,
      decimals: +decimals,
      content,
      description
    };
  });
  const assets = blacklist !== null && blacklist !== void 0 && blacklist.length ? getLegalAssets(allAssets, blacklist) : allAssets;
  return !whitelist ? assets : assets.sort((a, b) => {
    const isNativeA = isNativeAsset(a);
    const isNativeB = isNativeAsset(b);
    const isRegisteredA = isRegisteredAsset(a, whitelist);
    const isRegisteredB = isRegisteredAsset(b, whitelist);
    if (isNativeA && !isNativeB || isRegisteredA && !isRegisteredB) {
      return -1;
    }
    if (!isNativeA && isNativeB || !isRegisteredA && isRegisteredB) {
      return 1;
    }
    if (a.symbol < b.symbol) {
      return -1;
    }
    if (a.symbol > b.symbol) {
      return 1;
    }
    return 0;
  });
}
class AssetsModule {
  constructor(root) {
    this.root = root;
    this.accountDefaultAssetsAddresses = _consts.NativeAssets.map(asset => asset.address);
    this._accountAssetsAddresses = [];
    this.balanceSubscriptions = new Map();
    this.balanceSubject = new _rxjs.Subject();
    this.balanceUpdated = this.balanceSubject.asObservable();
    this.accountAssets = [];
  }

  /**
   * Get whitelist assets object
   * @param whitelist Whitelist array
   */
  getWhitelist(whitelist) {
    return whitelist.reduce((acc, asset) => {
      const {
        address,
        name,
        symbol,
        decimals,
        icon
      } = asset;
      acc[address] = {
        name,
        symbol,
        decimals,
        icon
      };
      return acc;
    }, {});
  }

  /**
   * Check is whitelisted asset or not
   * @param asset Asset object
   * @param whitelist Whitelist assets object
   */
  isWhitelist(asset, whitelist) {
    return isRegisteredAsset(asset, whitelist);
  }

  /**
   * Get whitelist object by symbol as keys
   * @param whitelist Whitelist array
   */
  getWhitelistIdsBySymbol(whitelist) {
    return whitelist.reduce((acc, asset) => {
      const {
        address,
        symbol
      } = asset;
      acc[symbol.toUpperCase()] = address;
      return acc;
    }, {});
  }

  /**
   * Check is blacklisted asset or not
   * @param asset Asset object
   * @param whitelistIdsBySymbol whitelist object by symbol as keys
   */
  isBlacklist(asset, whitelistIdsBySymbol) {
    const {
      address,
      symbol
    } = asset;
    if (!address || !symbol) {
      return false;
    }
    const foundAddress = whitelistIdsBySymbol[symbol];
    if (!foundAddress) {
      return false;
    }
    return foundAddress !== address;
  }

  /**
   * Checks if asset is NFT or not.
   *
   * **Asset is NFT if it has content and description fields**
   * @param asset
   */
  isNft(asset) {
    return !!(asset.content && asset.description);
  }

  /**
   * Checks if NFT asset is blacklisted or not.
   * @param asset Asset object
   * @param blacklist Blacklist assets object
   */
  isNftBlacklisted(asset, blacklist) {
    if (!asset.address) {
      return false;
    }
    return blacklist.includes(asset.address);
  }

  // Default assets addresses of account - list of NativeAssets addresses

  // # Account assets methods

  subscribeToAssetBalance(asset) {
    const subscription = this.getAssetBalanceObservable(asset).subscribe(accountBalance => {
      asset.balance = accountBalance;
      this.balanceSubject.next();
    });
    this.balanceSubscriptions.set(asset.address, subscription);
  }
  unsubscribeFromAssetBalance(address) {
    var _this$balanceSubscrip;
    (_this$balanceSubscrip = this.balanceSubscriptions.get(address)) === null || _this$balanceSubscrip === void 0 ? void 0 : _this$balanceSubscrip.unsubscribe();
    this.balanceSubscriptions.delete(address);
  }
  async addToAccountAssetsList(address) {
    if (this.getAsset(address)) return;
    // Get asset data and balance info
    const asset = await this.getAccountAsset(address);
    // During async execution of the method above, asset may have already been added
    // Check again, that asset is not in account assets list
    if (!this.getAsset(address)) {
      this.accountAssets.push(asset);
      this.subscribeToAssetBalance(asset);
    }
  }
  removeFromAccountAssets(address) {
    this.accountAssets = this.accountAssets.filter(item => item.address !== address);
  }
  removeFromAccountAssetsList(address) {
    this.unsubscribeFromAssetBalance(address);
    this.removeFromAccountAssets(address);
    this.balanceSubject.next();
  }

  /**
   * Add account asset to the end of list & create balance subscription
   * @param address asset address
   */
  async addAccountAsset(address) {
    this.addToAccountAssetsAddressesList(address);
    await this.addToAccountAssetsList(address);
  }

  /**
   * Remove account asset & it's balance subscription
   * @param address asset address
   */
  removeAccountAsset(address) {
    this.removeFromAccountAssetsAddressesList(address);
    this.removeFromAccountAssetsList(address);
  }

  /**
   * Clear account assets & their balance subscriptions
   */
  clearAccountAssets() {
    for (const address of this.balanceSubscriptions.keys()) {
      this.unsubscribeFromAssetBalance(address);
    }
    this.accountAssets = [];
  }

  /**
   * Find account asset in account assets list
   * @param address asset address
   */
  getAsset(address) {
    var _this$accountAssets$f;
    return (_this$accountAssets$f = this.accountAssets.find(asset => asset.address === address)) !== null && _this$accountAssets$f !== void 0 ? _this$accountAssets$f : null;
  }
  getAssetBalanceObservable(asset) {
    const accountAddress = this.root.account.pair.address;
    const assetAddress = asset.address;
    if (assetAddress === _consts.XOR.address) {
      const accountInfo = this.root.apiRx.query.system.account(accountAddress);
      const bondedBalance = this.root.apiRx.query.referrals.referrerBalances(accountAddress);
      return (0, _rxjs.combineLatest)([accountInfo, bondedBalance]).pipe((0, _rxjs.map)(result => formatBalance(result[0].data, asset.decimals, result[1])));
    }
    return this.root.apiRx.query.tokens.accounts(accountAddress, assetAddress).pipe((0, _rxjs.map)(accountData => formatBalance(accountData, asset.decimals)));
  }

  /**
   * Get total XOR balance including staking
   * and liquidity poolings
   *
   */
  getTotalXorBalanceObservable() {
    return (0, _rxjs.combineLatest)([this.getAssetBalanceObservable(_consts.XOR), this.root.demeterFarming.getAccountPoolsObservable()]).pipe((0, _rxjs.map)(_ref3 => {
      let [xorAssetBalance, demeterFarmingPools] = _ref3;
      // wallet xor balance (including frozen & bonded)
      const xorBalanceTotal = _math.FPNumber.fromCodecValue(xorAssetBalance.total);

      // staked xor in demeter farming platform
      const xorStaked = demeterFarmingPools.filter(pool => pool.isFarm === false && pool.poolAsset === _consts.XOR.address).map(pool => pool.pooledTokens);
      const xorStakedTotal = xorStaked.reduce((prev, curr) => prev.add(curr), _math.FPNumber.ZERO);

      // pooled xor
      const xorPooled = this.root.poolXyk.accountLiquidity.filter(pool => pool.firstAddress === _consts.XOR.address || pool.secondAddress === _consts.XOR.address).map(pool => pool.firstAddress === _consts.XOR.address ? pool.firstBalance : pool.secondBalance).map(pooledXor => _math.FPNumber.fromCodecValue(pooledXor));
      const xorPooledTotal = xorPooled.reduce((prev, curr) => prev.add(curr), _math.FPNumber.ZERO);
      return xorBalanceTotal.add(xorStakedTotal).add(xorPooledTotal);
    }));
  }

  /**
   * Sync account assets with account assets address list
   * During update process, assets should be removed according to 'excludedAddresses'
   * and exists in accounts assets list according to 'currentAddresses'
   */
  async updateAccountAssets() {
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    if (!this.accountAssetsAddresses.length) {
      const defaultList = this.accountDefaultAssetsAddresses;
      const accountList = await this.getAccountTokensAddressesList();
      this.accountAssetsAddresses = [...new Set([...defaultList, ...accountList])];
    }
    const currentAddresses = this.accountAssetsAddresses;
    const excludedAddresses = this.accountAssets.reduce((result, _ref4) => {
      let {
        address
      } = _ref4;
      return currentAddresses.includes(address) ? result : [...result, address];
    }, []);
    for (const assetAddress of excludedAddresses) {
      this.removeFromAccountAssetsList(assetAddress);
    }
    if (!currentAddresses.length) return;
    const addToAccountAssetsListPromises = currentAddresses.map(assetId => this.addToAccountAssetsList(assetId));
    await Promise.allSettled(addToAccountAssetsListPromises);
    // sort assets by currentAddresses list
    this.accountAssets.sort((a, b) => {
      return currentAddresses.indexOf(a.address) - currentAddresses.indexOf(b.address);
    });
  }

  /**
   * Get asset information
   * @param address asset address
   */
  async getAssetInfo(address) {
    const knownAsset = _consts.KnownAssets.get(address);
    if (knownAsset) {
      return knownAsset;
    }
    const existingAsset = this.getAsset(address) || this.root.poolXyk.accountLiquidity.find(asset => asset.address === address);
    if (existingAsset) {
      return {
        address: existingAsset.address,
        decimals: existingAsset.decimals,
        symbol: existingAsset.symbol,
        name: existingAsset.name,
        content: existingAsset.content,
        // will be undefined,
        description: existingAsset.description // if there are no such props
      };
    }

    return await getAssetInfo(this.root.api, address);
  }

  /**
   * Get account asset information.
   * You can just check balance of any asset
   * @param address asset address
   */
  async getAccountAsset(address) {
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    const {
      decimals,
      symbol,
      name,
      content,
      description
    } = await this.getAssetInfo(address);
    const asset = {
      address,
      decimals,
      symbol,
      name,
      content,
      description
    };
    const result = await getAssetBalance(this.root.api, this.root.account.pair.address, address, decimals);
    asset.balance = result;
    return asset;
  }

  /**
   * Get account ORML tokens list with any non zero balance
   */
  async getAccountTokensAddressesList() {
    const data = await this.root.api.query.tokens.accounts.entries(this.root.account.pair.address);
    const list = [];
    for (const [key, {
      free,
      reserved,
      frozen
    }] of data) {
      const assetId = key.args[1].code.toString();
      const hasAssetAnyBalance = [free, reserved, frozen].some(value => !new _math.FPNumber(value).isZero());
      if (hasAssetAnyBalance) {
        list.push(assetId);
      }
    }
    return list;
  }

  // # Account assets addresses

  get accountAssetsAddresses() {
    if (this.root.accountStorage) {
      const addresses = this.root.accountStorage.get('assetsAddresses');
      this._accountAssetsAddresses = addresses ? JSON.parse(addresses) : [];
    }
    return this._accountAssetsAddresses;
  }
  set accountAssetsAddresses(assetsAddresses) {
    var _this$root$accountSto;
    (_this$root$accountSto = this.root.accountStorage) === null || _this$root$accountSto === void 0 ? void 0 : _this$root$accountSto.set('assetsAddresses', JSON.stringify(assetsAddresses));
    this._accountAssetsAddresses = [...assetsAddresses];
  }
  addToAccountAssetsAddressesList(assetAddress) {
    if (this.accountAssetsAddresses.includes(assetAddress)) return;
    // add address to the end of list
    this.accountAssetsAddresses = [...this.accountAssetsAddresses, assetAddress];
  }
  removeFromAccountAssetsAddressesList(address) {
    this.accountAssetsAddresses = this.accountAssetsAddresses.filter(item => item !== address);
  }

  /**
   * Get all tokens list registered in the blockchain network
   * @param withPoolTokens `false` by default
   * @param whitelist set of whitelist tokens
   * @param blacklist set of blacklist tokens
   */
  async getAssets() {
    let withPoolTokens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    let whitelist = arguments.length > 1 ? arguments[1] : undefined;
    let blacklist = arguments.length > 2 ? arguments[2] : undefined;
    const assets = await getAssets(this.root.api, whitelist, blacklist);
    return withPoolTokens ? assets : excludePoolXYKAssets(assets);
  }

  /**
   * Get all tokens addresses list registered in the blockchain network
   * @param blacklist set of blacklist tokens
   */
  async getAssetsIds(blacklist) {
    const ids = (await this.root.api.rpc.assets.listAssetIds()).map(codec => codec.toString());
    const filtered = blacklist !== null && blacklist !== void 0 && blacklist.length ? ids.filter(id => !isBlacklistedAssetAddress(id, blacklist)) : ids;
    return filtered;
  }
  calcRegisterAssetParams(symbol, name, totalSupply, extensibleSupply, nonDivisible) {
    let nft = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
      content: null,
      description: null
    };
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    const supply = new _math.FPNumber(totalSupply, nonDivisible ? 0 : _math.FPNumber.DEFAULT_PRECISION);
    return {
      args: [symbol, name, supply.toCodecString(), extensibleSupply, nonDivisible, nft.content, nft.description]
    };
  }

  /**
   * Register asset
   * @param symbol string with asset symbol
   * @param name string with asset name
   * @param totalSupply total token supply
   * @param extensibleSupply `true` means that token can be mintable any time by the owner of that token. `false` by default
   * @param nonDivisible `false` by default
   * @param nft Nft params object which contains content & description
   */
  register(symbol, name, totalSupply) {
    let extensibleSupply = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    let nonDivisible = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    let nft = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
      content: null,
      description: null
    };
    const params = this.calcRegisterAssetParams(symbol, name, totalSupply, extensibleSupply, nonDivisible, nft);
    return this.root.submitExtrinsic(this.root.api.tx.assets.register(...params.args), this.root.account.pair, {
      symbol,
      type: _BaseApi.Operation.RegisterAsset
    });
  }
}
exports.AssetsModule = AssetsModule;