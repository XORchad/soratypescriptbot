import { FPNumber, NumberLike } from '@sora-substrate/math';
import type { BalanceInfo } from '@sora-substrate/types';
import type { ApiPromise } from '@polkadot/api';
import type { Observable } from '@polkadot/types/types';
import type { OrmlTokensAccountData, PalletBalancesAccountData } from '@polkadot/types/lookup';
import type { Option, u128 } from '@polkadot/types-codec';
import type { AccountAsset, AccountBalance, Asset, Blacklist, Whitelist, WhitelistArrayItem, WhitelistIdsBySymbol } from './types';
import type { Api } from '../api';
/**
 * **For the external collaboration**
 *
 * Useful method for balance formatting
 *
 * @param data Account Data for ORML tokens or for PalletBalances
 * @param assetDecimals Asset decimals, 18 is used by default
 * @param bondedData Required only for XOR tokens in SORA network
 */
export declare function formatBalance(data: PalletBalancesAccountData | OrmlTokensAccountData, assetDecimals?: number, bondedData?: Option<u128>): AccountBalance;
/**
 * **For the external collaboration**
 *
 * Returns Asset Balance.
 *
 * If Asset ID == XOR, referrals.referrerBalances will be included as bonded
 *
 * @param api Polkadot based API object
 * @param accountAddress Account ID
 * @param assetAddress Asset ID
 * @param assetDecimals Asset decimals, 18 is used by default
 */
export declare function getAssetBalance(api: ApiPromise, accountAddress: string, assetAddress: string, assetDecimals?: number): Promise<AccountBalance>;
/**
 * Used *ONLY* for faucet
 */
export declare function getBalance(api: ApiPromise, accountAddress: string, assetAddress: string): Promise<Option<BalanceInfo>>;
export declare function isNativeAsset(asset: any): boolean;
export declare function excludePoolXYKAssets(assets: Asset[]): Asset[];
export declare function isBlacklistedAssetAddress(address: string, blacklist: Blacklist): boolean;
export declare function getLegalAssets(allAssets: Array<Asset>, blacklist: Blacklist): Array<Asset>;
export declare function getAssets(api: ApiPromise, whitelist?: Whitelist, blacklist?: Blacklist): Promise<Array<Asset>>;
export declare class AssetsModule<T> {
    private readonly root;
    constructor(root: Api<T>);
    /**
     * Get whitelist assets object
     * @param whitelist Whitelist array
     */
    getWhitelist(whitelist: Array<WhitelistArrayItem>): Whitelist;
    /**
     * Check is whitelisted asset or not
     * @param asset Asset object
     * @param whitelist Whitelist assets object
     */
    isWhitelist(asset: Partial<Asset>, whitelist: Whitelist): boolean;
    /**
     * Get whitelist object by symbol as keys
     * @param whitelist Whitelist array
     */
    getWhitelistIdsBySymbol(whitelist: Array<WhitelistArrayItem>): WhitelistIdsBySymbol;
    /**
     * Check is blacklisted asset or not
     * @param asset Asset object
     * @param whitelistIdsBySymbol whitelist object by symbol as keys
     */
    isBlacklist(asset: Partial<Asset>, whitelistIdsBySymbol: WhitelistIdsBySymbol): boolean;
    /**
     * Checks if asset is NFT or not.
     *
     * **Asset is NFT if it has content and description fields**
     * @param asset
     */
    isNft(asset: Asset | AccountAsset): boolean;
    /**
     * Checks if NFT asset is blacklisted or not.
     * @param asset Asset object
     * @param blacklist Blacklist assets object
     */
    isNftBlacklisted(asset: Partial<Asset>, blacklist: Blacklist): boolean;
    accountDefaultAssetsAddresses: Array<string>;
    private _accountAssetsAddresses;
    private balanceSubscriptions;
    private balanceSubject;
    balanceUpdated: Observable<void>;
    accountAssets: Array<AccountAsset>;
    private subscribeToAssetBalance;
    private unsubscribeFromAssetBalance;
    private addToAccountAssetsList;
    private removeFromAccountAssets;
    private removeFromAccountAssetsList;
    /**
     * Add account asset to the end of list & create balance subscription
     * @param address asset address
     */
    addAccountAsset(address: string): Promise<void>;
    /**
     * Remove account asset & it's balance subscription
     * @param address asset address
     */
    removeAccountAsset(address: string): void;
    /**
     * Clear account assets & their balance subscriptions
     */
    clearAccountAssets(): void;
    /**
     * Find account asset in account assets list
     * @param address asset address
     */
    getAsset(address: string): AccountAsset | null;
    getAssetBalanceObservable(asset: AccountAsset | Asset): Observable<AccountBalance>;
    /**
     * Get total XOR balance including staking
     * and liquidity poolings
     *
     */
    getTotalXorBalanceObservable(): Observable<FPNumber>;
    /**
     * Sync account assets with account assets address list
     * During update process, assets should be removed according to 'excludedAddresses'
     * and exists in accounts assets list according to 'currentAddresses'
     */
    updateAccountAssets(): Promise<void>;
    /**
     * Get asset information
     * @param address asset address
     */
    getAssetInfo(address: string): Promise<Asset>;
    /**
     * Get account asset information.
     * You can just check balance of any asset
     * @param address asset address
     */
    getAccountAsset(address: string): Promise<AccountAsset>;
    /**
     * Get account ORML tokens list with any non zero balance
     */
    getAccountTokensAddressesList(): Promise<string[]>;
    get accountAssetsAddresses(): Array<string>;
    set accountAssetsAddresses(assetsAddresses: Array<string>);
    private addToAccountAssetsAddressesList;
    private removeFromAccountAssetsAddressesList;
    /**
     * Get all tokens list registered in the blockchain network
     * @param withPoolTokens `false` by default
     * @param whitelist set of whitelist tokens
     * @param blacklist set of blacklist tokens
     */
    getAssets(withPoolTokens?: boolean, whitelist?: Whitelist, blacklist?: Blacklist): Promise<Array<Asset>>;
    /**
     * Get all tokens addresses list registered in the blockchain network
     * @param blacklist set of blacklist tokens
     */
    getAssetsIds(blacklist?: Blacklist): Promise<string[]>;
    private calcRegisterAssetParams;
    /**
     * Register asset
     * @param symbol string with asset symbol
     * @param name string with asset name
     * @param totalSupply total token supply
     * @param extensibleSupply `true` means that token can be mintable any time by the owner of that token. `false` by default
     * @param nonDivisible `false` by default
     * @param nft Nft params object which contains content & description
     */
    register(symbol: string, name: string, totalSupply: NumberLike, extensibleSupply?: boolean, nonDivisible?: boolean, nft?: {
        content: any;
        description: any;
    }): Promise<T>;
}
