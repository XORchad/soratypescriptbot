"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSubstrateOperation = exports.isEvmOperation = exports.isEthOperation = exports.TransactionStatus = exports.Operation = exports.KeyringType = exports.BaseApi = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _last2 = _interopRequireDefault(require("lodash/fp/last"));
var _first = _interopRequireDefault(require("lodash/fp/first"));
var _omit = _interopRequireDefault(require("lodash/fp/omit"));
var _rxjs = require("rxjs");
var _utilCrypto = require("@polkadot/util-crypto");
var _math = require("@sora-substrate/math");
var _connection = require("@sora-substrate/connection");
var _storage = require("./storage");
var _consts = require("./dex/consts");
var _consts2 = require("./assets/consts");
var _crypto = require("./crypto");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const isEthOperation = operation => [Operation.EthBridgeIncoming, Operation.EthBridgeOutgoing].includes(operation);
exports.isEthOperation = isEthOperation;
const isEvmOperation = operation => [Operation.EvmIncoming, Operation.EvmOutgoing].includes(operation);
exports.isEvmOperation = isEvmOperation;
const isSubstrateOperation = operation => [Operation.SubstrateIncoming, Operation.SubstrateOutgoing].includes(operation);
exports.isSubstrateOperation = isSubstrateOperation;
const isLiquidityPoolOperation = operation => [Operation.AddLiquidity, Operation.RemoveLiquidity].includes(operation);
const KeyringType = 'sr25519';

// We don't need to know real account address for checking network fees
exports.KeyringType = KeyringType;
const mockAccountAddress = 'cnRuw2R6EVgQW3e4h8XeiFym2iU17fNsms15zRGcg9YEJndAs';
class BaseApi {
  /**
   * Network fee values which can be used right after `calcStaticNetworkFees` method.
   *
   * Each value is represented as `CodecString`
   */

  // common data storage
  // account data storage

  /** If `true` you might subscribe on extrinsic statuses (`false` by default) */

  /** If `true` it'll be locked during extrinsics submit (`false` by default) */

  constructor() {
    let historyNamespace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'history';
    this.historyNamespace = historyNamespace;
    this.NetworkFee = {
      [Operation.AddLiquidity]: '0',
      [Operation.CreatePair]: '0',
      [Operation.EthBridgeIncoming]: '0',
      [Operation.EthBridgeOutgoing]: '0',
      [Operation.EvmIncoming]: '0',
      [Operation.EvmOutgoing]: '0',
      [Operation.SubstrateIncoming]: '0',
      [Operation.SubstrateOutgoing]: '0',
      [Operation.RegisterAsset]: '0',
      [Operation.RemoveLiquidity]: '0',
      [Operation.Swap]: '0',
      [Operation.SwapAndSend]: '0',
      [Operation.SwapTransferBatch]: '0',
      [Operation.Transfer]: '0',
      [Operation.ClaimVestedRewards]: '0',
      [Operation.ClaimCrowdloanRewards]: '0',
      [Operation.ClaimLiquidityProvisionRewards]: '0',
      [Operation.ClaimExternalRewards]: '0',
      [Operation.ReferralReserveXor]: '0',
      [Operation.ReferralUnreserveXor]: '0',
      [Operation.ReferralSetInvitedUser]: '0',
      [Operation.DemeterFarmingDepositLiquidity]: '0',
      [Operation.DemeterFarmingWithdrawLiquidity]: '0',
      [Operation.DemeterFarmingStakeToken]: '0',
      [Operation.DemeterFarmingUnstakeToken]: '0',
      [Operation.DemeterFarmingGetRewards]: '0',
      [Operation.CeresLiquidityLockerLockLiquidity]: '0',
      [Operation.StakingBond]: '0',
      [Operation.StakingBondExtra]: '0',
      [Operation.StakingRebond]: '0',
      [Operation.StakingUnbond]: '0',
      [Operation.StakingWithdrawUnbonded]: '0',
      [Operation.StakingNominate]: '0',
      [Operation.StakingChill]: '0',
      [Operation.StakingSetPayee]: '0',
      [Operation.StakingSetController]: '0',
      [Operation.StakingPayout]: '0'
    };
    this.prefix = 69;
    this._history = {};
    this.signer = void 0;
    this.storage = void 0;
    this.accountStorage = void 0;
    this.account = void 0;
    this.shouldObservableBeUsed = false;
    this.shouldPairBeLocked = false;
  }
  get api() {
    return _connection.connection.api;
  }
  get apiRx() {
    return _connection.connection.api.rx;
  }
  get accountPair() {
    if (!this.account) {
      return null;
    }
    return this.account.pair;
  }
  get address() {
    if (!this.account) {
      return '';
    }
    return this.formatAddress(this.account.pair.address);
  }
  get accountJson() {
    if (!this.account) {
      return null;
    }
    return this.account.json;
  }
  logout() {
    this.account = undefined;
    this.accountStorage = undefined;
    this.signer = undefined;
    this.history = {};
    if (this.storage) {
      this.storage.clear();
    }
  }
  initAccountStorage() {
    var _this$account, _this$account$pair;
    if (!((_this$account = this.account) !== null && _this$account !== void 0 && (_this$account$pair = _this$account.pair) !== null && _this$account$pair !== void 0 && _this$account$pair.address)) return;
    // TODO: dependency injection ?
    if (this.storage) {
      this.accountStorage = new _storage.AccountStorage((0, _crypto.toHmacSHA256)(this.account.pair.address));
    }
  }

  // methods for working with history
  get history() {
    if (this.accountStorage) {
      const history = this.accountStorage.get(this.historyNamespace);
      this._history = history ? JSON.parse(history) : {};
    }
    return this._history;
  }
  set history(value) {
    var _this$accountStorage;
    (_this$accountStorage = this.accountStorage) === null || _this$accountStorage === void 0 ? void 0 : _this$accountStorage.set(this.historyNamespace, JSON.stringify(value));
    this._history = _objectSpread({}, value);
  }
  get historyList() {
    return Object.values(this.history);
  }
  getHistory(id) {
    var _this$history$id;
    return (_this$history$id = this.history[id]) !== null && _this$history$id !== void 0 ? _this$history$id : null;
  }
  getFilteredHistory(filterFn) {
    const currentHistory = this.history;
    const filtered = {};
    for (const id in currentHistory) {
      const item = currentHistory[id];
      if (filterFn(item)) {
        filtered[id] = item;
      }
    }
    return filtered;
  }
  saveHistory(historyItem, options) {
    if (!(historyItem !== null && historyItem !== void 0 && historyItem.id)) return;
    let historyCopy;
    let addressStorage;
    const hasAccessToStorage = !!this.storage;
    const historyItemHasSigner = !!historyItem.from;
    const historyItemFromAddress = historyItemHasSigner ? this.formatAddress(historyItem.from, false) : '';
    const needToUpdateAddressStorage = !(options !== null && options !== void 0 && options.toCurrentAccount) && historyItemFromAddress && historyItemFromAddress !== this.address && hasAccessToStorage;
    if (needToUpdateAddressStorage) {
      addressStorage = new _storage.AccountStorage((0, _crypto.toHmacSHA256)(historyItemFromAddress));
      const history = addressStorage.get(this.historyNamespace);
      historyCopy = history ? JSON.parse(history) : {};
    } else {
      historyCopy = _objectSpread({}, this.history);
    }
    const item = _objectSpread(_objectSpread({}, historyCopy[historyItem.id] || {}), historyItem);
    if (options !== null && options !== void 0 && options.wasNotGenerated) {
      // Tx was failed on the static validation and wasn't generated in the network
      delete item.txId;
    }
    historyCopy[historyItem.id] = item;
    if (needToUpdateAddressStorage && addressStorage) {
      addressStorage.set(this.historyNamespace, JSON.stringify(historyCopy));
    } else {
      this.history = historyCopy;
    }
  }
  removeHistory() {
    for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key < _len; _key++) {
      ids[_key] = arguments[_key];
    }
    if (!ids.length) return;
    this.history = (0, _omit.default)(ids, this.history);
  }
  clearHistory() {
    this.history = {};
  }

  /**
   * Set account data
   * @param account
   */
  setAccount(account) {
    this.account = account;
  }

  /**
   * Unlock pair to sign tx
   * @param password
   */
  unlockPair(password) {
    this.account.pair.unlock(password);
  }

  /**
   * Lock pair
   */
  lockPair() {
    var _this$account$pair2;
    if (!((_this$account$pair2 = this.account.pair) !== null && _this$account$pair2 !== void 0 && _this$account$pair2.isLocked)) {
      this.account.pair.lock();
    }
  }

  /**
   * Set signer if the pair is locked (For polkadot js extension usage)
   * @param signer
   */
  setSigner(signer) {
    this.api.setSigner(signer);
    this.signer = signer;
  }

  /**
   * Set storage if it should be used as data storage
   * @param storage
   */
  setStorage(storage) {
    this.storage = storage;
  }
  getAccountWithOptions() {
    return {
      account: this.accountPair.isLocked ? this.accountPair.address : this.accountPair,
      options: {
        signer: this.signer
      }
    };
  }
  async submitApiExtrinsic(api, extrinsic, signer, historyData) {
    var _historyData$id, _historyData$startTim;
    let unsigned = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    const nonce = await api.rpc.system.accountNextIndex(signer.address);
    const {
      account,
      options
    } = this.getAccountWithOptions();
    // Signing the transaction
    const signedTx = unsigned ? extrinsic : await extrinsic.signAsync(account, _objectSpread(_objectSpread({}, options), {}, {
      nonce
    }));

    // we should lock pair, if it's not locked
    this.shouldPairBeLocked && this.lockPair();
    const isNotFaucetOperation = !historyData || historyData.type !== Operation.Faucet;

    // history initial params
    const from = isNotFaucetOperation && signer ? this.address : undefined;
    const txId = signedTx.hash.toString();
    const id = (_historyData$id = historyData.id) !== null && _historyData$id !== void 0 ? _historyData$id : txId;
    const type = historyData.type;
    const startTime = (_historyData$startTim = historyData.startTime) !== null && _historyData$startTim !== void 0 ? _historyData$startTim : Date.now();
    // history required params for each update
    const requiredParams = {
      id,
      from,
      type
    };
    this.saveHistory(_objectSpread(_objectSpread(_objectSpread({}, historyData), requiredParams), {}, {
      txId,
      startTime
    }));
    const extrinsicFn = async subscriber => {
      const unsub = await extrinsic.send(result => {
        const status = (0, _first.default)(Object.keys(result.status.toJSON())).toLowerCase();
        const updated = {};
        updated.status = status;
        if (result.status.isInBlock) {
          updated.blockId = result.status.asInBlock.toString();
        } else if (result.status.isFinalized) {
          updated.endTime = Date.now();
          const txIndex = result.txIndex;
          for (const {
            phase,
            event: {
              data,
              method,
              section
            }
          } of result.events) {
            if (!(phase.isApplyExtrinsic && phase.asApplyExtrinsic.toNumber() === txIndex)) continue;
            if (method === 'FeeWithdrawn' && section === 'xorFee') {
              const [_, soraNetworkFee] = data;
              updated.soraNetworkFee = soraNetworkFee.toString();
            } else if (method === 'AssetRegistered' && section === 'assets') {
              var _code;
              const [assetId, _] = data;
              updated.assetAddress = ((_code = assetId.code) !== null && _code !== void 0 ? _code : assetId).toString();
            } else if (method === 'Transfer' && ['balances', 'tokens'].includes(section) && isLiquidityPoolOperation(type)) {
              // balances.Transfer hasn't assetId field
              const [amount, to, from, assetId] = data.slice().reverse();
              const amountFormatted = new _math.FPNumber(amount).toString();
              const history = this.getHistory(id);
              // events for 1st token and 2nd token are ordered in extrinsic
              const amountKey = !history.amount ? 'amount' : 'amount2';
              updated[amountKey] = amountFormatted;
            } else if (method === 'RequestRegistered' && isEthOperation(type) || method === 'RequestStatusUpdate' && (isEvmOperation(type) || isSubstrateOperation(type))) {
              updated.hash = (0, _first.default)(data.toJSON());
            } else if (section === 'system' && method === 'ExtrinsicFailed') {
              updated.status = TransactionStatus.Error;
              updated.endTime = Date.now();
              const error = data[0];
              if (error.isModule) {
                const decoded = this.api.registry.findMetaError(error.asModule);
                const {
                  docs,
                  section,
                  name
                } = decoded;
                updated.errorMessage = section && name ? {
                  name,
                  section
                } : docs.join(' ').trim();
              } else {
                // Other, CannotLookup, BadOrigin, no extra info
                updated.errorMessage = error.toString();
              }
            }
          }
        }
        this.saveHistory(_objectSpread(_objectSpread({}, requiredParams), updated)); // Save history during each status update

        subscriber === null || subscriber === void 0 ? void 0 : subscriber.next([status, this.getHistory(id)]);
        if (result.status.isFinalized) {
          subscriber === null || subscriber === void 0 ? void 0 : subscriber.complete();
          unsub();
        }
      }).catch(e => {
        var _e$message, _last;
        const errorParts = e === null || e === void 0 ? void 0 : (_e$message = e.message) === null || _e$message === void 0 ? void 0 : _e$message.split(':');
        const errorInfo = (_last = (0, _last2.default)(errorParts)) === null || _last === void 0 ? void 0 : _last.trim();
        const status = TransactionStatus.Error;
        const updated = {};
        updated.status = status;
        updated.endTime = Date.now();
        updated.errorMessage = errorInfo;

        // save history and then delete 'txId'
        this.saveHistory(_objectSpread(_objectSpread({}, requiredParams), updated), {
          wasNotGenerated: true
        });
        subscriber === null || subscriber === void 0 ? void 0 : subscriber.next([status, this.getHistory(id)]);
        subscriber === null || subscriber === void 0 ? void 0 : subscriber.complete();
        throw new Error(errorInfo);
      });
    };
    if (this.shouldObservableBeUsed) {
      return new _rxjs.Observable(subscriber => {
        extrinsicFn(subscriber);
      }); // T is `Observable<ExtrinsicEvent>` here
    }

    return extrinsicFn(); // T is `void` here
  }

  async submitExtrinsic(extrinsic, signer, historyData) {
    let unsigned = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    return await this.submitApiExtrinsic(this.api, extrinsic, signer, historyData, unsigned);
  }

  /**
   * Returns an extrinsic with the default or empty params.
   *
   * Actually, network fee value doesn't depend on extrinsic params, so, we can use empty/default values
   * @param operation
   */
  getEmptyExtrinsic(operation) {
    try {
      switch (operation) {
        case Operation.AddLiquidity:
          return this.api.tx.poolXYK.depositLiquidity(_consts.DexId.XOR, '', '', 0, 0, 0, 0);
        case Operation.CreatePair:
          return this.api.tx.utility.batchAll([this.api.tx.tradingPair.register(_consts.DexId.XOR, '', ''), this.api.tx.poolXYK.initializePool(_consts.DexId.XOR, '', ''), this.api.tx.poolXYK.depositLiquidity(_consts.DexId.XOR, '', '', 0, 0, 0, 0)]);
        case Operation.EthBridgeIncoming:
        case Operation.EvmIncoming:
        case Operation.SubstrateIncoming:
        case Operation.EvmOutgoing:
        case Operation.SubstrateOutgoing:
          return null;
        case Operation.EthBridgeOutgoing:
          return this.api.tx.ethBridge.transferToSidechain('', '', 0, 0);
        case Operation.RegisterAsset:
          return this.api.tx.assets.register('', '', 0, false, false, null, null);
        case Operation.RemoveLiquidity:
          return this.api.tx.poolXYK.withdrawLiquidity(_consts.DexId.XOR, '', '', 0, 0, 0);
        case Operation.Swap:
          return this.api.tx.liquidityProxy.swap(_consts.DexId.XOR, '', '', {
            WithDesiredInput: {
              desiredAmountIn: '0',
              minAmountOut: '0'
            }
          }, [], 'Disabled');
        case Operation.SwapAndSend:
          return this.api.tx.liquidityProxy.swapTransfer('', _consts.DexId.XOR, '', '', {
            WithDesiredInput: {
              desiredAmountIn: '0',
              minAmountOut: '0'
            }
          }, [], 'Disabled');
        case Operation.SwapTransferBatch:
          return this.api.tx.liquidityProxy.swapTransferBatch([], '', '', [], 'Disabled');
        case Operation.Transfer:
          return this.api.tx.assets.transfer('', '', 0);
        case Operation.ClaimVestedRewards:
          return this.api.tx.vestedRewards.claimRewards();
        case Operation.ClaimCrowdloanRewards:
          return this.api.tx.vestedRewards.claimCrowdloanRewards(_consts2.XOR.address);
        case Operation.ClaimLiquidityProvisionRewards:
          return this.api.tx.pswapDistribution.claimIncentive();
        case Operation.ClaimExternalRewards:
          return this.api.tx.rewards.claim('0xa8811ca9a2f65a4e21bd82a1e121f2a7f0f94006d0d4bcacf50016aef0b67765692bb7a06367365f13a521ec129c260451a682e658048729ff514e77e4cdffab1b');
        // signature mock
        case Operation.ReferralReserveXor:
          return this.api.tx.referrals.reserve(0);
        case Operation.ReferralUnreserveXor:
          return this.api.tx.referrals.unreserve(0);
        case Operation.ReferralSetInvitedUser:
          return this.api.tx.referrals.setReferrer('');
        case Operation.DemeterFarmingDepositLiquidity:
          return this.api.tx.demeterFarmingPlatform.deposit(_consts2.XOR.address, _consts2.XOR.address, _consts2.XOR.address, true, 0);
        case Operation.DemeterFarmingWithdrawLiquidity:
          return this.api.tx.demeterFarmingPlatform.withdraw(_consts2.XOR.address, _consts2.XOR.address, _consts2.XOR.address, 0, true);
        case Operation.DemeterFarmingStakeToken:
          return this.api.tx.demeterFarmingPlatform.deposit(_consts2.XOR.address, _consts2.XOR.address, _consts2.XOR.address, false, 0);
        case Operation.DemeterFarmingUnstakeToken:
          return this.api.tx.demeterFarmingPlatform.withdraw(_consts2.XOR.address, _consts2.XOR.address, _consts2.XOR.address, 0, false);
        case Operation.DemeterFarmingGetRewards:
          return this.api.tx.demeterFarmingPlatform.getRewards(_consts2.XOR.address, _consts2.XOR.address, _consts2.XOR.address, true);
        case Operation.CeresLiquidityLockerLockLiquidity:
          return this.api.tx.ceresLiquidityLocker.lockLiquidity(_consts2.XOR.address, _consts2.XOR.address, 0, 100, false);
        case Operation.StakingBond:
          return this.api.tx.staking.bond(mockAccountAddress, 0, {
            Account: mockAccountAddress
          });
        case Operation.StakingBondExtra:
          return this.api.tx.staking.bondExtra(0);
        case Operation.StakingRebond:
          return this.api.tx.staking.rebond(0);
        case Operation.StakingUnbond:
          return this.api.tx.staking.unbond(0);
        case Operation.StakingWithdrawUnbonded:
          return this.api.tx.staking.withdrawUnbonded(0);
        case Operation.StakingNominate:
          return this.api.tx.staking.nominate([mockAccountAddress]);
        case Operation.StakingChill:
          return this.api.tx.staking.chill();
        case Operation.StakingSetPayee:
          return this.api.tx.staking.setPayee({
            Account: mockAccountAddress
          });
        case Operation.StakingSetController:
          return this.api.tx.staking.setController(mockAccountAddress);
        case Operation.StakingPayout:
          return this.api.tx.staking.payoutStakers(mockAccountAddress, 3449);
        default:
          return null;
      }
    } catch {
      return null;
    }
  }

  /**
   * Calc all required network fees. The result will be written to `NetworkFee` object.
   *
   * For example, `api.NetworkFee[Operation.AddLiquidity]`
   */
  async calcStaticNetworkFees() {
    const operations = [Operation.AddLiquidity, Operation.CreatePair, Operation.EthBridgeIncoming, Operation.EthBridgeOutgoing, Operation.EvmIncoming, Operation.EvmOutgoing, Operation.SubstrateIncoming, Operation.SubstrateOutgoing, Operation.RegisterAsset, Operation.RemoveLiquidity, Operation.Swap, Operation.SwapAndSend, Operation.SwapTransferBatch, Operation.Transfer, Operation.ClaimVestedRewards, Operation.ClaimCrowdloanRewards, Operation.ClaimLiquidityProvisionRewards, Operation.ClaimExternalRewards, Operation.ReferralReserveXor, Operation.ReferralUnreserveXor, Operation.ReferralSetInvitedUser, Operation.DemeterFarmingDepositLiquidity, Operation.DemeterFarmingWithdrawLiquidity, Operation.DemeterFarmingStakeToken, Operation.DemeterFarmingUnstakeToken, Operation.DemeterFarmingGetRewards, Operation.CeresLiquidityLockerLockLiquidity, Operation.StakingBond, Operation.StakingBondExtra, Operation.StakingRebond, Operation.StakingUnbond, Operation.StakingWithdrawUnbonded, Operation.StakingNominate, Operation.StakingChill, Operation.StakingSetPayee, Operation.StakingSetController, Operation.StakingPayout];
    const operationsPromises = operations.map(async operation => {
      const extrinsic = this.getEmptyExtrinsic(operation);
      if (extrinsic) {
        this.NetworkFee[operation] = await this.getTransactionFee(extrinsic);
      }
    });
    await Promise.allSettled(operationsPromises);
  }
  async getTransactionFee(extrinsic) {
    try {
      const res = await extrinsic.paymentInfo(mockAccountAddress);
      return new _math.FPNumber(res.partialFee, _consts2.XOR.decimals).toCodecString();
    } catch {
      // extrinsic is not supported in chain
      return '0';
    }
  }

  /**
   * Format address
   * @param withSoraPrefix `true` by default
   */
  formatAddress(address) {
    let withSoraPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const publicKey = (0, _utilCrypto.decodeAddress)(address, false);
    if (withSoraPrefix) {
      return (0, _utilCrypto.encodeAddress)(publicKey, this.prefix);
    }
    return (0, _utilCrypto.encodeAddress)(publicKey);
  }

  /**
   * Validate address
   * @param address
   */
  validateAddress(address) {
    try {
      (0, _utilCrypto.decodeAddress)(address, false);
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Get public key as hex string by account address
   * @param address
   * @returns
   */
  getPublicKeyByAddress(address) {
    const publicKey = (0, _utilCrypto.decodeAddress)(address, false);
    return Buffer.from(publicKey).toString('hex');
  }

  /**
   * Generate unique string from value
   * @param value
   * @returns
   */
  encrypt(value) {
    return (0, _crypto.encrypt)(value);
  }
}
exports.BaseApi = BaseApi;
let TransactionStatus; // When something happened before sending to network
exports.TransactionStatus = TransactionStatus;
(function (TransactionStatus) {
  TransactionStatus["Ready"] = "ready";
  TransactionStatus["Broadcast"] = "broadcast";
  TransactionStatus["InBlock"] = "inblock";
  TransactionStatus["Finalized"] = "finalized";
  TransactionStatus["Error"] = "error";
  TransactionStatus["Usurped"] = "usurped";
  TransactionStatus["Invalid"] = "invalid";
})(TransactionStatus || (exports.TransactionStatus = TransactionStatus = {}));
let Operation;
exports.Operation = Operation;
(function (Operation) {
  Operation["Swap"] = "Swap";
  Operation["Transfer"] = "Transfer";
  Operation["AddLiquidity"] = "AddLiquidity";
  Operation["RemoveLiquidity"] = "RemoveLiquidity";
  Operation["CreatePair"] = "CreatePair";
  Operation["Faucet"] = "Faucet";
  Operation["RegisterAsset"] = "RegisterAsset";
  Operation["EthBridgeOutgoing"] = "EthBridgeOutgoing";
  Operation["EthBridgeIncoming"] = "EthBridgeIncoming";
  Operation["EvmOutgoing"] = "EvmOutgoing";
  Operation["EvmIncoming"] = "EvmIncoming";
  Operation["SubstrateOutgoing"] = "SubstrateOutgoing";
  Operation["SubstrateIncoming"] = "SubstrateIncoming";
  Operation["ClaimRewards"] = "ClaimRewards";
  Operation["ClaimVestedRewards"] = "ClaimVestedRewards";
  Operation["ClaimCrowdloanRewards"] = "ClaimCrowdloanRewards";
  Operation["ClaimLiquidityProvisionRewards"] = "LiquidityProvisionRewards";
  Operation["ClaimExternalRewards"] = "ClaimExternalRewards";
  Operation["TransferAll"] = "TransferAll";
  Operation["SwapAndSend"] = "SwapAndSend";
  Operation["SwapTransferBatch"] = "SwapTransferBatch";
  Operation["ReferralReserveXor"] = "ReferralReserveXor";
  Operation["ReferralUnreserveXor"] = "ReferralUnreserveXor";
  Operation["ReferralSetInvitedUser"] = "ReferralSetInvitedUser";
  Operation["StakingBond"] = "StakingBond";
  Operation["StakingBondExtra"] = "StakingBondExtra";
  Operation["StakingRebond"] = "StakingRebond";
  Operation["StakingUnbond"] = "StakingUnbond";
  Operation["StakingWithdrawUnbonded"] = "StakingWithdrawUnbonded";
  Operation["StakingNominate"] = "StakingNominate";
  Operation["StakingChill"] = "StakingChill";
  Operation["StakingSetPayee"] = "StakingSetPayee";
  Operation["StakingSetController"] = "StakingSetController";
  Operation["StakingPayout"] = "StakingPayout";
  Operation["DemeterFarmingDepositLiquidity"] = "DemeterFarmingDepositLiquidity";
  Operation["DemeterFarmingWithdrawLiquidity"] = "DemeterFarmingWithdrawLiquidity";
  Operation["DemeterFarmingStakeToken"] = "DemeterFarmingStakeToken";
  Operation["DemeterFarmingUnstakeToken"] = "DemeterFarmingUnstakeToken";
  Operation["DemeterFarmingGetRewards"] = "DemeterFarmingGetRewards";
  Operation["CeresLiquidityLockerLockLiquidity"] = "CeresLiquidityLockerLockLiquidity";
  Operation["PlaceLimitOrder"] = "PlaceLimitOrder";
  Operation["CancelLimitOrder"] = "CancelLimitOrder";
  Operation["CancelLimitOrders"] = "CancelLimitOrders";
})(Operation || (exports.Operation = Operation = {}));