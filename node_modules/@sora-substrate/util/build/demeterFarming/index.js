"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DemeterFarmingModule = void 0;
var _rxjs = require("rxjs");
var _util = require("@polkadot/util");
var _math = require("@sora-substrate/math");
var _logger = require("../logger");
var _BaseApi = require("../BaseApi");
var _consts = require("../assets/consts");
class DemeterFarmingModule {
  constructor(root) {
    this.root = root;
  }

  /**
   * Get a list of pools for farming & staking, by provided pool & reward asset adresses
   * @param poolAsset address of pool asset (paired with XOR)
   * @param rewardAsset address of reward asset
   * @returns Observable list of pools
   */
  getPoolsByAssetsObservable(poolAsset, rewardAsset) {
    return this.root.apiRx.query.demeterFarmingPlatform.pools(poolAsset, rewardAsset).pipe((0, _rxjs.map)(poolDataVec => {
      return poolDataVec.map(poolData => ({
        baseAsset: poolData.baseAsset.code.toString(),
        poolAsset,
        rewardAsset,
        multiplier: poolData.multiplier.toNumber(),
        isCore: poolData.isCore.isTrue,
        isFarm: poolData.isFarm.isTrue,
        isRemoved: poolData.isRemoved.isTrue,
        depositFee: new _math.FPNumber(poolData.depositFee).toNumber(),
        totalTokensInPool: new _math.FPNumber(poolData.totalTokensInPool),
        rewards: new _math.FPNumber(poolData.rewards),
        rewardsToBeDistributed: new _math.FPNumber(poolData.rewardsToBeDistributed)
      }));
    }));
  }

  /**
   * Get a list of all pools for farming and staking
   * @returns Observable list of pools
   */
  async getPoolsObservable() {
    // TODO: resolve double map keys type issue
    // @ts-ignore
    const storageKeys = await this.root.api.query.demeterFarmingPlatform.pools.keys();
    if (!storageKeys.length) return null;
    const keys = storageKeys.map(item => {
      const [poolAssetId, rewardAssetId] = item.args;
      return {
        poolAsset: poolAssetId.code.toString(),
        rewardAsset: rewardAssetId.code.toString()
      };
    });
    const observables = keys.map(_ref => {
      let {
        poolAsset,
        rewardAsset
      } = _ref;
      return this.getPoolsByAssetsObservable(poolAsset, rewardAsset);
    });
    return (0, _rxjs.combineLatest)(observables).pipe((0, _rxjs.map)(data => data.flat()));
  }

  /**
   * Get an info about reward token
   * @param assetId asset address
   * @returns Observable token info
   */
  getTokenInfoObservable(assetId) {
    return this.root.apiRx.query.demeterFarmingPlatform.tokenInfos(assetId).pipe((0, _rxjs.map)(tokenInfo => {
      const data = tokenInfo.unwrap();
      return {
        assetId,
        tokenPerBlock: new _math.FPNumber(data.tokenPerBlock),
        farmsTotalMultiplier: Number(data.farmsTotalMultiplier),
        stakingTotalMultiplier: Number(data.stakingTotalMultiplier),
        farmsAllocation: new _math.FPNumber(data.farmsAllocation),
        stakingAllocation: new _math.FPNumber(data.stakingAllocation),
        teamAllocation: new _math.FPNumber(data.teamAllocation)
      };
    }));
  }

  /**
   * Get a list of all reward tokens
   * @returns Observable list of token infos
   */
  async getTokenInfosObservable() {
    const storageKeys = await this.root.api.query.demeterFarmingPlatform.tokenInfos.keys();
    if (!storageKeys.length) return null;
    const keys = storageKeys.map(item => item.args[0].code.toString());
    const observables = keys.map(assetId => this.getTokenInfoObservable(assetId));
    return (0, _rxjs.combineLatest)(observables);
  }

  /**
   * Get a list of active account pools for farming & staking
   * @returns Observable list of account pools (farming & staking)
   */
  getAccountPoolsObservable() {
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    return this.root.apiRx.query.demeterFarmingPlatform.userInfos(this.root.account.pair.address).pipe((0, _rxjs.map)(userInfoVec => {
      return userInfoVec.map(data => ({
        isFarm: data.isFarm.isTrue,
        baseAsset: data.baseAsset.code.toString(),
        poolAsset: data.poolAsset.code.toString(),
        pooledTokens: new _math.FPNumber(data.pooledTokens),
        rewardAsset: data.rewardAsset.code.toString(),
        rewards: new _math.FPNumber(data.rewards)
      }));
    }));
  }

  /**
   * Deposit LP tokens for farming pool
   * @param amount amount of LP tokens to be provided for farming
   * @param poolAsset address of pool asset (paired with XOR)
   * @param rewardAsset address of reward asset
   * @param baseAsset address of base asset (XOR, XSTUSD)
   */
  depositLiquidity(amount, poolAsset, rewardAsset) {
    let baseAsset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _consts.XOR;
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    const isFarm = true;
    const value = new _math.FPNumber(amount).toCodecString();
    return this.root.submitExtrinsic(this.root.api.tx.demeterFarmingPlatform.deposit(baseAsset.address, poolAsset.address, rewardAsset.address, isFarm, value), this.root.account.pair, {
      type: _BaseApi.Operation.DemeterFarmingDepositLiquidity,
      symbol: baseAsset.symbol,
      assetAddress: baseAsset.address,
      symbol2: poolAsset.symbol,
      asset2Address: poolAsset.address,
      amount: `${amount}`
    });
  }

  /**
   * Withdraw LP tokens from farming pool
   * @param amount amount of LP tokens to be withdrawed from farming
   * @param poolAsset address of pool asset (paired with XOR)
   * @param rewardAsset address of reward asset
   * @param baseAsset address of base asset (XOR, XSTUSD)
   */
  withdrawLiquidity(amount, poolAsset, rewardAsset) {
    let baseAsset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _consts.XOR;
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    const isFarm = true;
    const value = new _math.FPNumber(amount).toCodecString();
    return this.root.submitExtrinsic(this.root.api.tx.demeterFarmingPlatform.withdraw(baseAsset.address, poolAsset.address, rewardAsset.address, value, isFarm), this.root.account.pair, {
      type: _BaseApi.Operation.DemeterFarmingWithdrawLiquidity,
      symbol: baseAsset.symbol,
      assetAddress: baseAsset.address,
      symbol2: poolAsset.symbol,
      asset2Address: poolAsset.address,
      amount: `${amount}`
    });
  }

  /**
   * Stake token
   * @param asset address of asset to be staked
   * @param rewardAsset address of reward asset
   * @param amount amount of tokens to be staked
   */
  stake(asset, rewardAsset, amount) {
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    const isFarm = false;
    const value = new _math.FPNumber(amount, asset.decimals).toCodecString();
    return this.root.submitExtrinsic(this.root.api.tx.demeterFarmingPlatform.deposit(asset.address, asset.address, rewardAsset.address, isFarm, value), this.root.account.pair, {
      type: _BaseApi.Operation.DemeterFarmingStakeToken,
      symbol: asset.symbol,
      assetAddress: asset.address,
      amount: `${amount}`
    });
  }

  /**
   * Unstake token
   * @param asset address of asset to be unstaked
   * @param rewardAsset address of reward asset
   * @param amount amount of tokens to be unstaked
   */
  unstake(asset, rewardAsset, amount) {
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    const isFarm = false;
    const value = new _math.FPNumber(amount, asset.decimals).toCodecString();
    return this.root.submitExtrinsic(this.root.api.tx.demeterFarmingPlatform.withdraw(asset.address, asset.address, rewardAsset.address, value, isFarm), this.root.account.pair, {
      type: _BaseApi.Operation.DemeterFarmingUnstakeToken,
      symbol: asset.symbol,
      assetAddress: asset.address,
      amount: `${amount}`
    });
  }

  /**
   * Get rewards from farming or staking pool
   * @param isFarm flag indicated is getting rewards from farming or staking pool
   * @param asset asset (staking) or pool asset (farming) address
   * @param rewardAsset reward asset address
   * @param baseAsset address of base asset (XOR, XSTUSD) for farming pool or staking token
   * @param amount amount (for history only)
   */
  getRewards(isFarm, asset, rewardAsset) {
    let baseAsset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _consts.XOR;
    let amount = arguments.length > 4 ? arguments[4] : undefined;
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    // for staking base asset should be equal to staking asset
    const baseAssetAddress = isFarm ? baseAsset.address : asset.address;
    return this.root.submitExtrinsic(this.root.api.tx.demeterFarmingPlatform.getRewards(baseAssetAddress, asset.address, rewardAsset.address, isFarm), this.root.account.pair, {
      type: _BaseApi.Operation.DemeterFarmingGetRewards,
      symbol: rewardAsset.symbol,
      assetAddress: rewardAsset.address,
      amount: amount ? `${amount}` : undefined
    });
  }
}
exports.DemeterFarmingModule = DemeterFarmingModule;