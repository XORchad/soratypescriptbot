"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StakingModule = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _util = require("@polkadot/util");
var _math = require("@sora-substrate/math");
var _rxjs = require("rxjs");
var _logger = require("../logger");
var _BaseApi = require("../BaseApi");
var _consts = require("../assets/consts");
var _helpers = require("./helpers");
var _types = require("./types");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * A value to convert the validator commission into a fractional number
 */
const COMMISSION_DECIMALS = 9;

/**
 * Check on other networks
 */
const COUNT_ERAS_IN_DAILY = 4;

/**
 * Check on other networks
 */
const COUNT_HOURS_IN_ERA = 6;
const COUNT_DAYS_IN_YEAR = 365;
class StakingModule {
  constructor(root) {
    this.root = root;
  }
  getSignerPair(signerPair) {
    const pair = signerPair || this.root.account.pair;
    (0, _util.assert)(pair, _logger.Messages.provideAccountPair);
    return pair;
  }

  /**
   * Number of eras that staked funds must remain bonded for.
   * @returns bonding duration
   */
  getBondingDuration() {
    return this.root.api.consts.staking.bondingDuration.toNumber();
  }

  /**
   * The maximum number of nominators rewarded for each validator.
   * @returns max nominators
   */
  getMaxNominatorRewardedPerValidator() {
    return this.root.api.consts.staking.maxNominatorRewardedPerValidator.toNumber();
  }

  /**
   * Number of days that staked funds must remain bonded for.
   * @returns unbond period
   */
  getUnbondPeriod() {
    const bondingDuration = this.getBondingDuration();
    return bondingDuration / COUNT_ERAS_IN_DAILY;
  }

  /**
   * Maximum number of nominations per nominator.
   * @returns max nominations
   */
  getMaxNominations() {
    return this.root.api.consts.staking.maxNominations.toNumber();
  }

  /**
   * The minimum active bond to become and maintain the role of a nominator.
   * @returns min bond
   */
  async getMinNominatorBond() {
    return (await this.root.api.query.staking.minNominatorBond()).toNumber();
  }

  /**
   * Get observable session index
   *
   * Each era is divided into sessions.
   * Session defines an interval during which validators must submit heartbeat if they donâ€™t produce blocks.
   * Another usage of sessions is that reward points are calculated per session.
   * Reward points are used to calculate reward for validators at the end of each era.
   * @returns session index
   */
  getCurrentSessionObservable() {
    return this.root.apiRx.query.session.currentIndex().pipe((0, _rxjs.map)(data => data.toNumber()));
  }

  /**
   * Get observable preferred validator count
   * Staking module provides a variable that describes the preferred number of validators needs to be elected per era
   * @returns validator count (69)
   */
  getPreferredValidatorCountObservable() {
    return this.root.apiRx.query.staking.validatorCount().pipe((0, _rxjs.map)(data => data.toNumber()));
  }

  /**
   * Get observable active era
   * @returns era index & era start timestamp
   */
  getActiveEraObservable() {
    return this.root.apiRx.query.staking.activeEra().pipe((0, _rxjs.map)(data => {
      if (data.isEmpty) return null;
      const era = data.unwrap();
      const index = era.index.toNumber();
      const start = era.start.unwrapOrDefault().toNumber();
      return {
        index,
        start
      };
    }));
  }

  /**
   * Get history depth.
   * History depth - number of eras to keep in history.
   * @returns history depth
   */
  getHistoryDepth() {
    const historyDepth = this.root.api.consts.staking.historyDepth;
    return historyDepth.toNumber();
  }

  /**
   * Get the current era index.
   * This is the latest planned era, depending on how the Session pallet queues the validator
   * set, it might be active or not.
   * @returns current era index
   */
  async getCurrentEra() {
    const data = await this.root.api.query.staking.currentEra();
    return (0, _helpers.formatEra)(data);
  }

  /**
   * Get observable current era
   * @returns current era index
   */
  getCurrentEraObservable() {
    return this.root.apiRx.query.staking.currentEra().pipe((0, _rxjs.map)(_helpers.formatEra));
  }

  /**
   * Election status determines whether validator election is completed.
   * This value is very important from the point of view that many calls to the Staking module are only allowed when election is completed.
   * @returns election status of current era
   */
  // public getEraElectionStatusObservable(): Observable<EraElectionStatus> {
  //   return this.root.apiRx.query.staking.eraElectionStatus().pipe(
  //     map((electionStatus) => {
  //       return electionStatus.toJSON() as EraElectionStatus;
  //     })
  //   );
  // }

  /**
   * Get observable eras total stake
   * @param eraIndex index of era
   * @returns total stake balance in XOR (codec string)
   */
  async getEraTotalStake(eraIndex) {
    const erasTotalStake = await this.root.api.query.staking.erasTotalStake(eraIndex);
    return erasTotalStake.toString();
  }

  /**
   * Get observable eras total stake
   * @param eraIndex index of era
   * @returns total stake balance in XOR (codec string)
   */
  getEraTotalStakeObservable(eraIndex) {
    return this.root.apiRx.query.staking.erasTotalStake(eraIndex).pipe((0, _rxjs.map)(data => data.toString()));
  }

  /**
   * Get reward points of validators for era
   * @param eraIndex index of era
   * @returns validator points
   */
  async getEraRewardPoints(eraIndex) {
    const data = await this.root.api.query.staking.erasRewardPoints(eraIndex);
    return (0, _helpers.formatIndividualRewardPoints)(data);
  }

  /**
   * Get observable reward points of validators for era
   * @param eraIndex index of era
   * @returns total points and validator points
   */
  getEraRewardPointsObservable(eraIndex) {
    return this.root.apiRx.query.staking.erasRewardPoints(eraIndex).pipe((0, _rxjs.map)(data => {
      const total = data.total.toNumber();
      const individual = (0, _helpers.formatIndividualRewardPoints)(data);
      return {
        individual,
        total
      };
    }));
  }

  /**
   * **CONTROLLER**
   * CONTROLLER - STASH relation
   * Get observable information about stash address, locked funds and claimed rewards
   * @param controllerAddress address of controller account
   */
  getAccountLedgerObservable(controllerAddress) {
    return this.root.apiRx.query.staking.ledger(controllerAddress).pipe((0, _rxjs.map)(codec => {
      if (codec.isEmpty) return null;
      const data = codec.unwrap();
      return {
        stash: data.stash.toString(),
        total: data.total.toString(),
        active: data.active.toString(),
        unlocking: data.unlocking.map(item => ({
          value: item.value.toString(),
          era: item.era.toNumber()
        }))
      };
    }));
  }

  /**
   * **STASH**
   * STASH - CONTROLLER relation
   * Get observable controller account address for stash account
   * @param stashAddress address of stash account
   */
  getControllerObservable(stashAddress) {
    return this.root.apiRx.query.staking.bonded(stashAddress).pipe((0, _rxjs.map)(data => {
      if (data.isEmpty) return null;
      return data.unwrap().toString();
    }));
  }

  /**
   * **STASH**
   * Get observable rewards destination of stash account
   * @param stashAddress address of stash account
   * @returns rewards destination
   */
  getPayeeObservable(stashAddress) {
    return this.root.apiRx.query.staking.payee(stashAddress).pipe((0, _rxjs.map)(data => {
      if (data.isStaked) return _types.StakingRewardsDestination.Staked;
      if (data.isController) return _types.StakingRewardsDestination.Controller;
      if (data.isStash) return _types.StakingRewardsDestination.Stash;
      if (data.isAccount) return data.value.toString();
      return _types.StakingRewardsDestination.None;
    }));
  }

  /**
   * **STASH**
   * Get rewards destination of stash account
   * @param stashAddress address of stash account
   * @returns rewards destination
   */
  async getPayee(stashAddress) {
    const payee = await this.root.api.query.staking.payee(stashAddress);
    const payeeHuman = payee.toHuman();
    return typeof payeeHuman === 'string' ? payeeHuman : payeeHuman.Account;
  }

  /**
   * Get all accounts which want to be a validator
   * @returns list of validators infos (address, commission, blocked)
   */
  async getWannabeValidators() {
    const validators = (await this.root.api.query.staking.validators.entries()).map(_ref => {
      let [key, codec] = _ref;
      const address = key.args[0].toString();
      const {
        commission,
        blocked
      } = codec;
      return {
        address,
        blocked: blocked.isTrue,
        commission: commission.unwrap().toString()
      };
    });
    return validators;
  }

  /**
   * Calculating average validator reward
   * @returns average validator reward
   */
  async getAverageRewards(eraIndex) {
    const erasValidatorRewardPallet = this.root.api.query.staking.erasValidatorReward;
    if (Number.isInteger(eraIndex)) {
      const erasValidatorReward = await erasValidatorRewardPallet(eraIndex);
      return new _math.FPNumber(erasValidatorReward.value);
    }
    const erasValidatorReward = await erasValidatorRewardPallet.entries();
    const summaryRewards = erasValidatorReward.reduce((sum, _ref2) => {
      let [, eraReward] = _ref2;
      const eraRewardValue = eraReward.value.toString();
      return sum.add(_math.FPNumber.fromCodecValue(eraRewardValue));
    }, _math.FPNumber.ZERO);
    const averageRewards = summaryRewards.div(new _math.FPNumber(erasValidatorReward.length));
    return averageRewards;
  }

  /**
   * Calculating validator apy
   * @returns apy
   */
  async calculatingStakeReturn(totalStakeValidator, rewardToStakeRatio, eraTotalStake, eraAverageRewards, commission) {
    const validatorTotalStake = _math.FPNumber.fromCodecValue(totalStakeValidator);
    if (validatorTotalStake.isZero()) return {
      stakeReturn: '0',
      apy: '0'
    };
    const validatorShareStake = validatorTotalStake.div(_math.FPNumber.fromCodecValue(eraTotalStake));
    const stakeReturnReward = eraAverageRewards.mul(validatorShareStake);
    const stakeReturn = stakeReturnReward.mul(_math.FPNumber.fromCodecValue(rewardToStakeRatio));
    const ratioReturnStakeToTotalStake = stakeReturn.div(validatorTotalStake).mul(new _math.FPNumber(COUNT_ERAS_IN_DAILY)).mul(new _math.FPNumber(COUNT_DAYS_IN_YEAR));
    const nominatorShare = _math.FPNumber.ONE.sub(_math.FPNumber.fromCodecValue(commission, COMMISSION_DECIMALS));
    const apy = ratioReturnStakeToTotalStake.sub(_math.FPNumber.ONE).mul(_math.FPNumber.HUNDRED).mul(nominatorShare);
    return {
      stakeReturn: stakeReturn.toCodecString(),
      apy: apy.toFixed(2)
    };
  }

  /**
   * Get information about validators
   * @returns list of validators infos sorted by recommended
   */
  async getValidatorsInfo() {
    const [wannabeValidators, currentEra, eraAverageRewards] = await Promise.all([this.getWannabeValidators(), this.getCurrentEra(), this.getAverageRewards()]);
    const [eraRewardPoints, electedValidators, eraTotalStake] = await Promise.all([this.getEraRewardPoints(currentEra), this.getElectedValidators(currentEra), this.getEraTotalStake(currentEra)]);

    // TODO: use liquidity proxy quote; XOR based quote is used just for now
    const {
      amount: rewardToStakeRatio
    } = await this.root.swap.getResultFromDexRpc(_consts.VAL.address, _consts.XOR.address, 1);
    const validatorsPromises = wannabeValidators.map(async _ref3 => {
      var _electedValidator$tot, _await$this$root$getA, _electedValidator$oth, _identity$judgements, _electedValidator$oth2, _electedValidator$own, _identity$info;
      let {
        address,
        commission
      } = _ref3;
      const electedValidator = electedValidators.find(_ref4 => {
        let {
          address: _address
        } = _ref4;
        return _address === address;
      });
      const total = (_electedValidator$tot = electedValidator === null || electedValidator === void 0 ? void 0 : electedValidator.total) !== null && _electedValidator$tot !== void 0 ? _electedValidator$tot : '0';
      const rewardPoints = eraRewardPoints[address];
      const identity = (_await$this$root$getA = await this.root.getAccountOnChainIdentity(address)) === null || _await$this$root$getA === void 0 ? void 0 : _await$this$root$getA.identity;
      const {
        apy,
        stakeReturn
      } = await this.calculatingStakeReturn(total, rewardToStakeRatio, eraTotalStake, eraAverageRewards, commission);
      const nominators = (_electedValidator$oth = electedValidator === null || electedValidator === void 0 ? void 0 : electedValidator.others) !== null && _electedValidator$oth !== void 0 ? _electedValidator$oth : [];
      const maxNominatorRewardedPerValidator = this.getMaxNominatorRewardedPerValidator();
      const isOversubscribed = nominators.length > maxNominatorRewardedPerValidator;
      const knownGoodIndex = identity === null || identity === void 0 ? void 0 : (_identity$judgements = identity.judgements) === null || _identity$judgements === void 0 ? void 0 : _identity$judgements.findIndex(_ref5 => {
        let [, type] = _ref5;
        return type === 'KnownGood';
      });
      const isKnownGood = knownGoodIndex && knownGoodIndex !== -1;
      return {
        address,
        apy,
        rewardPoints,
        commission: commission !== null && commission !== void 0 ? commission : '',
        nominators: (_electedValidator$oth2 = electedValidator === null || electedValidator === void 0 ? void 0 : electedValidator.others) !== null && _electedValidator$oth2 !== void 0 ? _electedValidator$oth2 : [],
        isOversubscribed,
        isKnownGood,
        stake: {
          stakeReturn,
          total,
          own: (_electedValidator$own = electedValidator === null || electedValidator === void 0 ? void 0 : electedValidator.own) !== null && _electedValidator$own !== void 0 ? _electedValidator$own : '0'
        },
        identity: identity !== null ? _objectSpread(_objectSpread({}, identity), {}, {
          info: Object.fromEntries(Object.entries((_identity$info = identity === null || identity === void 0 ? void 0 : identity.info) !== null && _identity$info !== void 0 ? _identity$info : {}).map(_ref6 => {
            let [key, value] = _ref6;
            if (value === 'None') return [key, ''];
            if (!Array.isArray(value) && (value === null || value === void 0 ? void 0 : value.Raw) !== undefined) return [key, value === null || value === void 0 ? void 0 : value.Raw];
            return [key, value];
          }))
        }) : null
      };
    });
    const validators = await Promise.all(validatorsPromises);

    // step 1 - apy DESC
    // step 2 - commission ASC
    // step 3 - identity, array of judgements have KnownGood element
    return validators.sort((validator1, validator2) => {
      const {
        apy: apy1,
        commission: commission1,
        isKnownGood: isKnownGood1
      } = validator1;
      const {
        apy: apy2,
        commission: commission2,
        isKnownGood: isKnownGood2
      } = validator2;
      const subtractionApy = new _math.FPNumber(apy2).sub(new _math.FPNumber(apy1));
      if (!subtractionApy.isZero()) return subtractionApy.toNumber();
      const subtractionCommission = new _math.FPNumber(commission1).sub(new _math.FPNumber(commission2));
      if (!subtractionCommission.isZero()) return subtractionCommission.toNumber();
      if (isKnownGood1 && !isKnownGood2) return -1;
      if (!isKnownGood1 && isKnownGood2) return 1;
      return 0;
    });
  }

  /**
   * Get my staking info
   * @returns staking info
   */
  async getMyStakingInfo(address) {
    var _this$root$api, _stakingDerive$unlock, _stakingDerive$unlock2, _stakingDerive$redeem, _stakingDerive$contro, _stakingDerive$contro2, _ref9, _stakingDerive$reward;
    const stakingDerive = await ((_this$root$api = this.root.api) === null || _this$root$api === void 0 ? void 0 : _this$root$api.derive.staking.account(address));
    const unlocking = (_stakingDerive$unlock = (_stakingDerive$unlock2 = stakingDerive.unlocking) === null || _stakingDerive$unlock2 === void 0 ? void 0 : _stakingDerive$unlock2.map(_ref7 => {
      let {
        value,
        remainingEras: _remainingEras
      } = _ref7;
      const remainingEras = new _math.FPNumber(_remainingEras.toString());
      const remainingHours = remainingEras.mul(new _math.FPNumber(COUNT_HOURS_IN_ERA)).toString();
      const remainingDays = remainingEras.div(new _math.FPNumber(COUNT_ERAS_IN_DAILY)).toString();
      return {
        value: _math.FPNumber.fromCodecValue(value.toString(), _consts.XOR.decimals).toString(),
        remainingEras: remainingEras.toString(),
        remainingHours,
        remainingDays
      };
    })) !== null && _stakingDerive$unlock !== void 0 ? _stakingDerive$unlock : [];
    const sum = unlocking.reduce((sum, _ref8) => {
      let {
        value
      } = _ref8;
      return sum.add(new _math.FPNumber(value));
    }, _math.FPNumber.ZERO).toString();
    const stakingLedger = stakingDerive.stakingLedger;
    const activeStake = _math.FPNumber.fromCodecValue(stakingLedger.active.toString(), _consts.XOR.decimals).toString();
    const totalStake = _math.FPNumber.fromCodecValue(stakingLedger.total.toString(), _consts.XOR.decimals).toString();
    const myValidators = stakingDerive.nominators.map(item => item.toHuman());
    const redeemAmount = _math.FPNumber.fromCodecValue((_stakingDerive$redeem = stakingDerive.redeemable) === null || _stakingDerive$redeem === void 0 ? void 0 : _stakingDerive$redeem.toString(), _consts.XOR.decimals).toString();
    const controller = (_stakingDerive$contro = (_stakingDerive$contro2 = stakingDerive.controllerId) === null || _stakingDerive$contro2 === void 0 ? void 0 : _stakingDerive$contro2.toString()) !== null && _stakingDerive$contro !== void 0 ? _stakingDerive$contro : '';
    const rewardDestination = (_ref9 = (_stakingDerive$reward = stakingDerive.rewardDestination) === null || _stakingDerive$reward === void 0 ? void 0 : _stakingDerive$reward.toHuman()) !== null && _ref9 !== void 0 ? _ref9 : '';
    const payee = typeof rewardDestination === 'string' ? rewardDestination : rewardDestination.Account;
    return {
      payee,
      controller,
      myValidators,
      redeemAmount,
      activeStake,
      totalStake,
      unbond: {
        unlocking,
        sum
      }
    };
  }

  /**
   * Get nominators reward
   * @returns nominators reward
   */
  async getNominatorsReward(address) {
    const stakerRewards = await this.root.api.derive.staking.stakerRewards(address);
    return stakerRewards.map(_ref10 => {
      let {
        era,
        validators: _validators
      } = _ref10;
      const validators = Object.entries(_validators).map(_ref11 => {
        let [address, {
          value
        }] = _ref11;
        return {
          address,
          value: _math.FPNumber.fromCodecValue(value.toString(), _consts.VAL.decimals).toString()
        };
      });
      return {
        era: era.toString(),
        sumRewards: validators.reduce((sum, _ref12) => {
          let {
            value
          } = _ref12;
          return sum.add(new _math.FPNumber(value));
        }, _math.FPNumber.ZERO).toString(),
        validators
      };
    });
  }

  /**
   * Get a set of validators elected for a given era
   * @param eraIndex index of era
   * @param clipped flag to reduce 'others' list to biggest stakers
   * @returns a list of elected validators
   */
  async getElectedValidators(eraIndex) {
    let clipped = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const storage = clipped ? this.root.api.query.staking.erasStakersClipped : this.root.api.query.staking.erasStakers;
    const validators = (await storage.entries(eraIndex)).map(_ref13 => {
      let [key, codec] = _ref13;
      const address = key.args[1].toString();
      const data = (0, _helpers.formatValidatorExposure)(codec);
      return _objectSpread({
        address
      }, data);
    });
    return validators;
  }

  /**
   * Get validator exposure observable
   * @param eraIndex index of era
   * @param validatorAddress address of validator
   * @param clipped flag to reduce 'others' list to biggest stakers
   * @returns validator exposure
   */
  getElectedValidatorObservable(eraIndex, validatorAddress) {
    let clipped = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    const observable = clipped ? this.root.apiRx.query.staking.erasStakersClipped : this.root.apiRx.query.staking.erasStakers;
    return observable(eraIndex, validatorAddress).pipe((0, _rxjs.map)(_helpers.formatValidatorExposure));
  }

  /**
   * New set of validators for the current era starts working from the second session of the era and until the first session of the next era.
   * This request is used to fetch validators when EraStakers returns no validators during transition to the new era.
   * @returns list of validator addresses
   */
  async getSessionValidators() {
    const data = await this.root.api.query.session.validators();
    return data.map(id => id.toString());
  }

  /**
   * **STASH**
   * Get validators nominated by stash
   * @param stashAddress address of stash account
   * @returns The structure with the list of validators, eraIndex
   */
  async getNominations(stashAddress) {
    const codec = await this.root.api.query.staking.nominators(stashAddress);
    return (0, _helpers.formatNominations)(codec);
  }

  /**
   * **STASH**
   * Get observable validators nominated by stash
   * @param stashAddress address of stash account
   * @returns The structure with the list of validators, eraIndex
   */
  getNominationsObservable(stashAddress) {
    return this.root.apiRx.query.staking.nominators(stashAddress).pipe((0, _rxjs.map)(_helpers.formatNominations));
  }

  /**
   * Calc bond tx params
   * @param value amount to bond (XOR)
   * @param controller address of controller account
   * @param payee destination of rewards (one of payee or specific account address for payments)
   * @returns
   */
  calcBondParams(value, controller, payee) {
    const amount = new _math.FPNumber(value, _consts.XOR.decimals).toCodecString();
    const destination = (0, _helpers.formatPayee)(payee);
    return [controller, amount, destination];
  }

  /**
   * **STASH**
   * Lock the stake
   * @param args.value amount to bond (XOR)
   * @param args.controller address of controller account
   * @param args.payee destination of rewards (one of payee or account address for payments)
   * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
   */
  async bond(args, signerPair) {
    const pair = this.getSignerPair(signerPair);
    const params = this.calcBondParams(args.value, args.controller, args.payee);
    return this.root.submitExtrinsic(this.root.api.tx.staking.bond(...params), pair, {
      type: _BaseApi.Operation.StakingBond,
      symbol: _consts.XOR.symbol,
      assetAddress: _consts.XOR.address,
      amount: `${args.value}`
    });
  }

  /**
   * **STASH**
   * Add more funds to an existing stake
   * @param args.value amount add to stake
   * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
   */
  async bondExtra(args, signerPair) {
    const pair = this.getSignerPair(signerPair);
    return this.root.submitExtrinsic(this.root.api.tx.staking.bondExtra(new _math.FPNumber(args.value, _consts.XOR.decimals).toCodecString()), pair, {
      type: _BaseApi.Operation.StakingBondExtra,
      symbol: _consts.XOR.symbol,
      assetAddress: _consts.XOR.address,
      amount: `${args.value}`
    });
  }

  /**
   * **CONTROLLER**
   * Lock again part of currently unlocking value
   * @param args.value amount to lock in stake
   * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
   */
  async rebond(args, signerPair) {
    const pair = this.getSignerPair(signerPair);
    return this.root.submitExtrinsic(this.root.api.tx.staking.rebond(new _math.FPNumber(args.value, _consts.XOR.decimals).toCodecString()), pair, {
      type: _BaseApi.Operation.StakingRebond,
      symbol: _consts.XOR.symbol,
      assetAddress: _consts.XOR.address,
      amount: `${args.value}`
    });
  }

  /**
   * **CONTROLLER**
   * To withdraw part of the staked amount a user must perform unbounding firstly
   * @param args.value amount to unbond from stake
   * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
   */
  async unbond(args, signerPair) {
    const pair = this.getSignerPair(signerPair);
    return this.root.submitExtrinsic(this.root.api.tx.staking.unbond(new _math.FPNumber(args.value, _consts.XOR.decimals).toCodecString()), pair, {
      type: _BaseApi.Operation.StakingUnbond,
      symbol: _consts.XOR.symbol,
      assetAddress: _consts.XOR.address,
      amount: `${args.value}`
    });
  }

  /**
   * Get slashing spans
   * slashingSpans parameter is needed to ensure
   * that the user agrees that staking information will be removed when there is no unlocking items pending
   * and active value goes below minimum_balance due to slashing.
   * @param stashAddress address of stash account
   * @returns slashing spans
   */
  async getSlashingSpans(stashAddress) {
    const {
      value
    } = await this.root.api.query.staking.slashingSpans(stashAddress);
    return value.spanIndex;
  }

  /**
   * **CONTROLLER**
   * Moves unlocked value to the free balance of the stash account
   * @param args.value amount to withdraw - not used in extrinsic call, but can be passed to save this value in history
   * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
   */
  async withdrawUnbonded(args, signerPair) {
    const pair = this.getSignerPair(signerPair);
    const slashingSpans = await this.getSlashingSpans(pair.address);
    return this.root.submitExtrinsic(this.root.api.tx.staking.withdrawUnbonded(slashingSpans), pair, {
      type: _BaseApi.Operation.StakingWithdrawUnbonded,
      symbol: _consts.XOR.symbol,
      assetAddress: _consts.XOR.address,
      amount: args.value ? `${args.value}` : undefined
    });
  }

  /**
   * **CONTROLLER**
   * Start nominating a list of validators from the next era
   * @param args.validators list of validators addresses to nominate
   * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
   */
  async nominate(args, signerPair) {
    const pair = this.getSignerPair(signerPair);
    return this.root.submitExtrinsic(this.root.api.tx.staking.nominate(args.validators), pair, {
      type: _BaseApi.Operation.StakingNominate,
      validators: args.validators
    });
  }

  /**
   * **CONTROLLER**
   * Stop nominating or validating from the next era.
   * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
   */
  async chill(signerPair) {
    const pair = this.getSignerPair(signerPair);
    return this.root.submitExtrinsic(this.root.api.tx.staking.chill(), pair, {
      type: _BaseApi.Operation.StakingChill
    });
  }

  /**
   * **CONTROLLER**
   * Changes new account to which staking reward is sent starting from the next era
   * @param args.payee rewards destination
   * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
   */
  async setPayee(args, signerPair) {
    const pair = this.getSignerPair(signerPair);
    const destination = (0, _helpers.formatPayee)(args.payee);
    return this.root.submitExtrinsic(this.root.api.tx.staking.setPayee(destination), pair, {
      type: _BaseApi.Operation.StakingSetPayee,
      payee: args.payee
    });
  }

  /**
   * **STASH**
   * Set new controller for the current stash starting from the next era
   * @param args.address address of controller account
   * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
   */
  async setController(args, signerPair) {
    const pair = this.getSignerPair(signerPair);
    return this.root.submitExtrinsic(this.root.api.tx.staking.setController(args.address), pair, {
      type: _BaseApi.Operation.StakingSetController,
      controller: args.address
    });
  }

  /**
   * Distribute payout for staking in a given era for given validators
   * @param args.payouts
   * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
   */
  async payout(args, signerPair) {
    const pair = this.getSignerPair(signerPair);
    const transactions = args.payouts.map(_ref14 => {
      let {
        era,
        validators
      } = _ref14;
      return validators.map(address => this.root.api.tx.staking.payoutStakers(address, era));
    }).flat();
    const call = transactions.length > 1 ? this.root.api.tx.utility.batchAll(transactions) : transactions[0];
    return this.root.submitExtrinsic(call, pair, {
      type: _BaseApi.Operation.StakingPayout,
      payouts: args.payouts
    });
  }
}
exports.StakingModule = StakingModule;