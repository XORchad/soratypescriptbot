import { FPNumber } from '@sora-substrate/math';
import { StakingRewardsDestination } from './types';
import type { Observable } from '@polkadot/types/types';
import type { KeyringPair } from '@polkadot/keyring/types';
import type { CodecString, NumberLike } from '@sora-substrate/math';
import type { Api } from '../api';
import type { ValidatorInfo, StashNominatorsInfo, ActiveEra, EraRewardPoints, ValidatorExposure, ElectedValidator, AccountStakingLedger, RewardPointsIndividual, ValidatorInfoFull, MyStakingInfo, StakeReturn, NominatorReward, Payouts } from './types';
export declare class StakingModule<T> {
    private readonly root;
    constructor(root: Api<T>);
    getSignerPair(signerPair?: KeyringPair): KeyringPair;
    /**
     * Number of eras that staked funds must remain bonded for.
     * @returns bonding duration
     */
    getBondingDuration(): number;
    /**
     * The maximum number of nominators rewarded for each validator.
     * @returns max nominators
     */
    getMaxNominatorRewardedPerValidator(): number;
    /**
     * Number of days that staked funds must remain bonded for.
     * @returns unbond period
     */
    getUnbondPeriod(): number;
    /**
     * Maximum number of nominations per nominator.
     * @returns max nominations
     */
    getMaxNominations(): number;
    /**
     * The minimum active bond to become and maintain the role of a nominator.
     * @returns min bond
     */
    getMinNominatorBond(): Promise<number>;
    /**
     * Get observable session index
     *
     * Each era is divided into sessions.
     * Session defines an interval during which validators must submit heartbeat if they donâ€™t produce blocks.
     * Another usage of sessions is that reward points are calculated per session.
     * Reward points are used to calculate reward for validators at the end of each era.
     * @returns session index
     */
    getCurrentSessionObservable(): Observable<number>;
    /**
     * Get observable preferred validator count
     * Staking module provides a variable that describes the preferred number of validators needs to be elected per era
     * @returns validator count (69)
     */
    getPreferredValidatorCountObservable(): Observable<number>;
    /**
     * Get observable active era
     * @returns era index & era start timestamp
     */
    getActiveEraObservable(): Observable<ActiveEra | null>;
    /**
     * Get history depth.
     * History depth - number of eras to keep in history.
     * @returns history depth
     */
    getHistoryDepth(): number;
    /**
     * Get the current era index.
     * This is the latest planned era, depending on how the Session pallet queues the validator
     * set, it might be active or not.
     * @returns current era index
     */
    getCurrentEra(): Promise<number>;
    /**
     * Get observable current era
     * @returns current era index
     */
    getCurrentEraObservable(): Observable<number>;
    /**
     * Election status determines whether validator election is completed.
     * This value is very important from the point of view that many calls to the Staking module are only allowed when election is completed.
     * @returns election status of current era
     */
    /**
     * Get observable eras total stake
     * @param eraIndex index of era
     * @returns total stake balance in XOR (codec string)
     */
    getEraTotalStake(eraIndex: number): Promise<CodecString>;
    /**
     * Get observable eras total stake
     * @param eraIndex index of era
     * @returns total stake balance in XOR (codec string)
     */
    getEraTotalStakeObservable(eraIndex: number): Observable<CodecString>;
    /**
     * Get reward points of validators for era
     * @param eraIndex index of era
     * @returns validator points
     */
    getEraRewardPoints(eraIndex: number): Promise<RewardPointsIndividual>;
    /**
     * Get observable reward points of validators for era
     * @param eraIndex index of era
     * @returns total points and validator points
     */
    getEraRewardPointsObservable(eraIndex: number): Observable<EraRewardPoints>;
    /**
     * **CONTROLLER**
     * CONTROLLER - STASH relation
     * Get observable information about stash address, locked funds and claimed rewards
     * @param controllerAddress address of controller account
     */
    getAccountLedgerObservable(controllerAddress: string): Observable<AccountStakingLedger | null>;
    /**
     * **STASH**
     * STASH - CONTROLLER relation
     * Get observable controller account address for stash account
     * @param stashAddress address of stash account
     */
    getControllerObservable(stashAddress: string): Observable<string | null>;
    /**
     * **STASH**
     * Get observable rewards destination of stash account
     * @param stashAddress address of stash account
     * @returns rewards destination
     */
    getPayeeObservable(stashAddress: string): Observable<StakingRewardsDestination | string>;
    /**
     * **STASH**
     * Get rewards destination of stash account
     * @param stashAddress address of stash account
     * @returns rewards destination
     */
    getPayee(stashAddress: string): Promise<StakingRewardsDestination | string>;
    /**
     * Get all accounts which want to be a validator
     * @returns list of validators infos (address, commission, blocked)
     */
    getWannabeValidators(): Promise<ValidatorInfo[]>;
    /**
     * Calculating average validator reward
     * @returns average validator reward
     */
    getAverageRewards(eraIndex?: number): Promise<FPNumber>;
    /**
     * Calculating validator apy
     * @returns apy
     */
    calculatingStakeReturn(totalStakeValidator: string, rewardToStakeRatio: string, eraTotalStake: string, eraAverageRewards: FPNumber, commission: string): Promise<StakeReturn>;
    /**
     * Get information about validators
     * @returns list of validators infos sorted by recommended
     */
    getValidatorsInfo(): Promise<ValidatorInfoFull[]>;
    /**
     * Get my staking info
     * @returns staking info
     */
    getMyStakingInfo(address: string): Promise<MyStakingInfo>;
    /**
     * Get nominators reward
     * @returns nominators reward
     */
    getNominatorsReward(address: string): Promise<NominatorReward>;
    /**
     * Get a set of validators elected for a given era
     * @param eraIndex index of era
     * @param clipped flag to reduce 'others' list to biggest stakers
     * @returns a list of elected validators
     */
    getElectedValidators(eraIndex: number, clipped?: boolean): Promise<ElectedValidator[]>;
    /**
     * Get validator exposure observable
     * @param eraIndex index of era
     * @param validatorAddress address of validator
     * @param clipped flag to reduce 'others' list to biggest stakers
     * @returns validator exposure
     */
    getElectedValidatorObservable(eraIndex: number, validatorAddress: string, clipped?: boolean): Observable<ValidatorExposure>;
    /**
     * New set of validators for the current era starts working from the second session of the era and until the first session of the next era.
     * This request is used to fetch validators when EraStakers returns no validators during transition to the new era.
     * @returns list of validator addresses
     */
    getSessionValidators(): Promise<string[]>;
    /**
     * **STASH**
     * Get validators nominated by stash
     * @param stashAddress address of stash account
     * @returns The structure with the list of validators, eraIndex
     */
    getNominations(stashAddress: string): Promise<StashNominatorsInfo | null>;
    /**
     * **STASH**
     * Get observable validators nominated by stash
     * @param stashAddress address of stash account
     * @returns The structure with the list of validators, eraIndex
     */
    getNominationsObservable(stashAddress: string): Observable<StashNominatorsInfo | null>;
    /**
     * Calc bond tx params
     * @param value amount to bond (XOR)
     * @param controller address of controller account
     * @param payee destination of rewards (one of payee or specific account address for payments)
     * @returns
     */
    private calcBondParams;
    /**
     * **STASH**
     * Lock the stake
     * @param args.value amount to bond (XOR)
     * @param args.controller address of controller account
     * @param args.payee destination of rewards (one of payee or account address for payments)
     * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
     */
    bond(args: {
        value: NumberLike;
        controller: string;
        payee: StakingRewardsDestination | string;
    }, signerPair?: KeyringPair): Promise<T>;
    /**
     * **STASH**
     * Add more funds to an existing stake
     * @param args.value amount add to stake
     * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
     */
    bondExtra(args: {
        value: NumberLike;
    }, signerPair?: KeyringPair): Promise<T>;
    /**
     * **CONTROLLER**
     * Lock again part of currently unlocking value
     * @param args.value amount to lock in stake
     * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
     */
    rebond(args: {
        value: NumberLike;
    }, signerPair?: KeyringPair): Promise<T>;
    /**
     * **CONTROLLER**
     * To withdraw part of the staked amount a user must perform unbounding firstly
     * @param args.value amount to unbond from stake
     * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
     */
    unbond(args: {
        value: NumberLike;
    }, signerPair?: KeyringPair): Promise<T>;
    /**
     * Get slashing spans
     * slashingSpans parameter is needed to ensure
     * that the user agrees that staking information will be removed when there is no unlocking items pending
     * and active value goes below minimum_balance due to slashing.
     * @param stashAddress address of stash account
     * @returns slashing spans
     */
    private getSlashingSpans;
    /**
     * **CONTROLLER**
     * Moves unlocked value to the free balance of the stash account
     * @param args.value amount to withdraw - not used in extrinsic call, but can be passed to save this value in history
     * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
     */
    withdrawUnbonded(args: {
        value?: NumberLike;
    }, signerPair?: KeyringPair): Promise<T>;
    /**
     * **CONTROLLER**
     * Start nominating a list of validators from the next era
     * @param args.validators list of validators addresses to nominate
     * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
     */
    nominate(args: {
        validators: string[];
    }, signerPair?: KeyringPair): Promise<T>;
    /**
     * **CONTROLLER**
     * Stop nominating or validating from the next era.
     * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
     */
    chill(signerPair?: KeyringPair): Promise<T>;
    /**
     * **CONTROLLER**
     * Changes new account to which staking reward is sent starting from the next era
     * @param args.payee rewards destination
     * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
     */
    setPayee(args: {
        payee: StakingRewardsDestination | string;
    }, signerPair?: KeyringPair): Promise<T>;
    /**
     * **STASH**
     * Set new controller for the current stash starting from the next era
     * @param args.address address of controller account
     * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
     */
    setController(args: {
        address: string;
    }, signerPair?: KeyringPair): Promise<T>;
    /**
     * Distribute payout for staking in a given era for given validators
     * @param args.payouts
     * @param signerPair account pair for transaction sign (otherwise the connected account will be used)
     */
    payout(args: {
        payouts: Payouts;
    }, signerPair?: KeyringPair): Promise<T>;
}
