"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EvmBridgeApi = void 0;
var _math = require("@sora-substrate/math");
var _util = require("@polkadot/util");
var _BaseApi = require("../../BaseApi");
var _logger = require("../../logger");
var _consts = require("../consts");
var _methods = require("../methods");
class EvmBridgeApi extends _BaseApi.BaseApi {
  constructor() {
    super('evmHistory');
  }
  generateHistoryItem(params) {
    if (!params.type) {
      return null;
    }
    const historyItem = params || {};
    historyItem.startTime = historyItem.startTime || Date.now();
    historyItem.id = this.encrypt(`${historyItem.startTime}`);
    historyItem.transactionState = historyItem.transactionState || _consts.BridgeTxStatus.Pending;
    this.saveHistory(historyItem);
    return historyItem;
  }
  saveHistory(history) {
    if (!(0, _BaseApi.isEvmOperation)(history.type)) return;
    super.saveHistory(history);
  }
  async getRegisteredAssets(evmNetwork) {
    const assets = {};
    try {
      const data = await this.api.rpc.bridgeProxy.listAssets({
        [_consts.BridgeNetworkType.Evm]: evmNetwork
      });
      data.forEach(assetData => {
        const assetInfo = assetData.asEvm;
        const soraAddress = assetInfo.assetId.toString();
        const evmAddress = assetInfo.evmAddress.toString();
        const appKind = assetInfo.appKind.toString();
        const decimals = assetInfo.precision.toNumber();
        assets[soraAddress] = {
          address: evmAddress,
          appKind,
          decimals
        };
      });
      return assets;
    } catch {
      return assets;
    }
  }
  async getUserTransactions(accountAddress, evmNetwork) {
    return await (0, _methods.getUserTransactions)(this.api, accountAddress, {
      [_consts.BridgeNetworkType.Evm]: evmNetwork
    }, evmNetwork, _consts.BridgeNetworkType.Evm);
  }
  async getTransactionDetails(accountAddress, evmNetwork, hash) {
    return await (0, _methods.getTransactionDetails)(this.api, accountAddress, hash, {
      [_consts.BridgeNetworkType.Evm]: evmNetwork
    }, evmNetwork, _consts.BridgeNetworkType.Evm);
  }
  subscribeOnTransactionDetails(accountAddress, evmNetwork, hash) {
    return (0, _methods.subscribeOnTransactionDetails)(this.apiRx, accountAddress, hash, {
      [_consts.BridgeNetworkType.Evm]: evmNetwork
    }, evmNetwork, _consts.BridgeNetworkType.Evm);
  }
  async getLockedAssets(evmNetwork, assetAddress) {
    return await (0, _methods.getLockedAssets)(this.api, {
      [_consts.BridgeNetworkType.Evm]: evmNetwork
    }, assetAddress);
  }

  /** UNCHECKED */
  getTransferExtrinsic(asset, recipient, amount, evmNetwork) {
    const value = new _math.FPNumber(amount, asset.decimals).toCodecString();
    return this.api.tx.bridgeProxy.burn({
      [_consts.BridgeNetworkType.Evm]: evmNetwork
    }, asset.address, {
      [_consts.BridgeAccountType.Evm]: recipient
    }, value);
  }
  async transfer(asset, recipient, amount, evmNetwork, historyId) {
    (0, _util.assert)(this.account, _logger.Messages.connectWallet);
    const extrinsic = this.getTransferExtrinsic(asset, recipient, amount, evmNetwork);
    const historyItem = this.getHistory(historyId) || {
      type: _BaseApi.Operation.EvmOutgoing,
      symbol: asset.symbol,
      assetAddress: asset.address,
      amount: `${amount}`
    };
    await this.submitExtrinsic(extrinsic, this.account.pair, historyItem);
  }
  async getNetworkFee(asset, evmNetwork) {
    const tx = this.getTransferExtrinsic(asset, '', '0', evmNetwork);
    return await this.getTransactionFee(tx);
  }
}
exports.EvmBridgeApi = EvmBridgeApi;