"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLockedAssets = getLockedAssets;
exports.getTransactionDetails = getTransactionDetails;
exports.getUserTransactions = getUserTransactions;
exports.subscribeOnTransactionDetails = subscribeOnTransactionDetails;
var _rxjs = require("rxjs");
var _consts = require("./consts");
var _consts2 = require("./sub/consts");
function accountFromJunction(junction) {
  if (junction.isAccountId32) {
    return junction.asAccountId32.id.toString();
  } else {
    return '';
  }
}
function getAccount(data) {
  if (data.isUnknown) {
    return '';
  }
  if (data.isEvm) {
    return data.asEvm.toString();
  }
  if (data.isSora) {
    return data.asSora.toString();
  }
  const {
    interior
  } = data.asParachain.isV3 ? data.asParachain.asV3 : data.asParachain.asV2;
  if (interior.isX1) {
    return accountFromJunction(interior.asX1);
  } else if (interior.isX2) {
    return accountFromJunction(interior.asX2[1]);
  } else {
    return '';
  }
}
function getSubNetworkId(data, parachainIds, usedNetwork) {
  // we don't know from where are this tx. For now this will be a used network
  if (data.isUnknown) return usedNetwork;
  const {
    interior
  } = data.asParachain.isV3 ? data.asParachain.asV3 : data.asParachain.asV2;
  if (interior.isX2) {
    const networkParam = interior.asX2[0];
    if (networkParam.isParachain) {
      const paraId = networkParam.asParachain.toNumber();
      for (const parachainKey in parachainIds) {
        if (parachainIds[parachainKey] === paraId) {
          return _consts2.SubNetwork[parachainKey];
        }
      }
    }
  }
  return usedNetwork;
}
function getBlock(data) {
  if (data.isEvm) {
    return data.asEvm.toNumber();
  }
  if (data.isSora) {
    return data.asSora.toNumber();
  }
  if (data.isParachain) {
    return data.asParachain.toNumber();
  }
  return 0;
}
function formatBridgeTx(hash, data, networkId, networkType, parachainIds) {
  if (!data.isSome) {
    return null;
  }
  const unwrapped = data.unwrap();
  const formatted = {};
  const isSub = networkType === _consts.BridgeNetworkType.Sub;
  const externalNetworkSrc = unwrapped.direction.isInbound ? unwrapped.source : unwrapped.dest;
  const externalNetwork = isSub ? getSubNetworkId(externalNetworkSrc, parachainIds, networkId) : networkId;
  if (externalNetwork !== networkId) return null;
  formatted.externalNetwork = externalNetwork;
  formatted.externalNetworkType = networkType;
  formatted.soraHash = hash;
  formatted.amount = unwrapped.amount.toString();
  formatted.soraAssetAddress = unwrapped.assetId.code.toString();
  formatted.status = unwrapped.status.isFailed ? _consts.BridgeTxStatus.Failed : unwrapped.status.isDone || unwrapped.status.isCommitted ? _consts.BridgeTxStatus.Done : _consts.BridgeTxStatus.Pending;
  formatted.startBlock = getBlock(unwrapped.startTimepoint);
  formatted.endBlock = getBlock(unwrapped.endTimepoint);
  if (unwrapped.direction.isInbound) {
    // incoming: network -> SORA
    formatted.externalAccount = getAccount(unwrapped.source);
    formatted.soraAccount = getAccount(unwrapped.dest);
    formatted.direction = _consts.BridgeTxDirection.Incoming;
  } else {
    // outgoing: SORA -> network
    formatted.soraAccount = getAccount(unwrapped.source);
    formatted.externalAccount = getAccount(unwrapped.dest);
    formatted.direction = _consts.BridgeTxDirection.Outgoing;
  }
  return formatted;
}

/**
 * Get all user transactions from external network
 */
async function getUserTransactions(api, accountAddress, networkParam, networkId, networkType, parachainIds) {
  try {
    const buffer = [];
    const data = await api.query.bridgeProxy.transactions.entries([networkParam, accountAddress]);
    for (const [key, value] of data) {
      const hash = key.args[1];
      const tx = formatBridgeTx(hash.toString(), value, networkId, networkType, parachainIds);
      if (tx) {
        buffer.push(tx);
      }
    }
    return buffer;
  } catch {
    return [];
  }
}

/** Get transaction details */
async function getTransactionDetails(api, accountAddress, hash, networkParam, networkId, networkType, parachainIds) {
  try {
    const data = await api.query.bridgeProxy.transactions([networkParam, accountAddress], hash);
    return formatBridgeTx(hash, data, networkId, networkType, parachainIds);
  } catch {
    return null;
  }
}

/** Subscribe on transaction details */
function subscribeOnTransactionDetails(apiRx, accountAddress, hash, networkParam, networkId, networkType, parachainIds) {
  try {
    return apiRx.query.bridgeProxy.transactions([networkParam, accountAddress], hash).pipe((0, _rxjs.map)(value => formatBridgeTx(hash, value, networkId, networkType, parachainIds)));
  } catch {
    return null;
  }
}

/** Get the amount of the asset locked on the bridge on the SORA side */
async function getLockedAssets(api, networkParam, assetAddress) {
  try {
    const data = await api.query.bridgeProxy.lockedAssets(networkParam, assetAddress);
    return data.toString();
  } catch {
    return null;
  }
}