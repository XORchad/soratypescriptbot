"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BridgeProxyModule = void 0;
var _rxjs = require("rxjs");
var _math = require("@sora-substrate/math");
var _eth = require("./eth");
var _evm = require("./evm");
var _sub = require("./sub");
var _consts = require("./consts");
class BridgeProxyModule {
  constructor(root) {
    this.root = root;
    this.eth = new _eth.EthBridgeApi();
    this.evm = new _evm.EvmBridgeApi();
    this.sub = new _sub.SubBridgeApi();
  }
  initAccountStorage() {
    this.eth.initAccountStorage();
    this.evm.initAccountStorage();
    this.sub.initAccountStorage();
  }
  setStorage(storage) {
    this.eth.setStorage(storage);
    this.evm.setStorage(storage);
    this.sub.setStorage(storage);
  }
  setSigner(signer) {
    this.eth.setSigner(signer);
    this.evm.setSigner(signer);
    this.sub.setSigner(signer);
  }
  setAccount(account) {
    this.eth.setAccount(account);
    this.evm.setAccount(account);
    this.sub.setAccount(account);
  }
  logout() {
    this.eth.logout();
    this.evm.logout();
    this.sub.logout();
  }
  async getListApps() {
    const apps = {
      [_consts.BridgeNetworkType.Eth]: {},
      [_consts.BridgeNetworkType.Evm]: {},
      [_consts.BridgeNetworkType.Sub]: []
    };
    try {
      const data = await this.root.api.rpc.bridgeProxy.listApps();
      data.forEach(appInfo => {
        if (appInfo.isEvm) {
          const [genericNetworkId, evmAppInfo] = appInfo.asEvm;
          const id = genericNetworkId.isEvm ? genericNetworkId.asEvm.toNumber() : genericNetworkId.asEvmLegacy.toNumber();
          const type = genericNetworkId.isEvm ? _consts.BridgeNetworkType.Evm : _consts.BridgeNetworkType.Eth;
          const kind = evmAppInfo.appKind.toString();
          const address = evmAppInfo.evmAddress.toString();
          if (!apps[type][id]) apps[type][id] = {};
          apps[type][id][kind] = address;
        } else {
          const genericNetworkId = appInfo.asSub;
          const type = _consts.BridgeNetworkType.Sub;
          const subNetwork = genericNetworkId.asSub;
          const name = subNetwork.toString();
          if (subNetwork.isRococo) {
            // adding parachains we work through relaychain
          }
          apps[type].push(name);
        }
      });
      return apps;
    } catch {
      return apps;
    }
  }
  async isAssetTransferLimited(assetAddress) {
    const result = await this.root.api.query.bridgeProxy.limitedAssets(assetAddress);
    return result.isTrue;
  }
  getTransferLimitObservable() {
    return this.root.apiRx.query.bridgeProxy.transferLimit().pipe((0, _rxjs.map)(limitSettings => limitSettings.maxAmount.toString()));
  }
  getConsumedTransferLimitObservable() {
    return this.root.apiRx.query.bridgeProxy.consumedTransferLimit().pipe((0, _rxjs.map)(limit => limit.toString()));
  }
  getCurrentTransferLimitObservable() {
    return (0, _rxjs.combineLatest)([this.getTransferLimitObservable(), this.getConsumedTransferLimitObservable()]).pipe((0, _rxjs.map)(_ref => {
      let [maxLimit, consumedLimit] = _ref;
      const max = _math.FPNumber.fromCodecValue(maxLimit);
      const consumed = _math.FPNumber.fromCodecValue(consumedLimit);
      const current = max.sub(consumed);
      const checked = _math.FPNumber.isGreaterThan(current, _math.FPNumber.ZERO) ? current : _math.FPNumber.ZERO;
      return checked.toCodecString();
    }));
  }
  async getTransferLimitUnlockSchedule() {
    const data = await this.root.api.query.bridgeProxy.transferLimitUnlockSchedule.entries();
    const unlocks = data.map(_ref2 => {
      let [key, value] = _ref2;
      const blockNumber = key.args[0].toNumber();
      const amount = value.toString();
      return {
        blockNumber,
        amount
      };
    }).sort((a, b) => a.blockNumber - b.blockNumber);
    return unlocks;
  }
}
exports.BridgeProxyModule = BridgeProxyModule;