"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubBridgeApi = void 0;
var _math = require("@sora-substrate/math");
var _util = require("@polkadot/util");
var _BaseApi = require("../../BaseApi");
var _logger = require("../../logger");
var _consts = require("../consts");
var _methods = require("../methods");
var _consts2 = require("./consts");
var _parachain = require("./parachain");
class SubBridgeApi extends _BaseApi.BaseApi {
  constructor() {
    super('subHistory');
    this.soraParachainApi = new _parachain.SoraParachainApi();
    this.parachainIds = {
      // Sora
      [_consts2.SubNetwork.RococoSora]: 2011,
      [_consts2.SubNetwork.KusamaSora]: 2011,
      // Karura
      [_consts2.SubNetwork.KusamaKarura]: 2000
    };
  }

  // override it from frontend config if needed

  getRelayChain(subNetwork) {
    if (this.isRelayChain(subNetwork)) return subNetwork;
    switch (subNetwork) {
      case _consts2.SubNetwork.RococoSora:
        return _consts2.SubNetwork.Rococo;
      case _consts2.SubNetwork.KusamaKarura:
      case _consts2.SubNetwork.KusamaSora:
        return _consts2.SubNetwork.Kusama;
      default:
        throw new Error(`"${subNetwork}" has not relaychain`);
    }
  }
  getSoraParachain(subNetwork) {
    if (this.isSoraParachain(subNetwork)) return subNetwork;
    switch (subNetwork) {
      case _consts2.SubNetwork.Kusama:
      case _consts2.SubNetwork.KusamaKarura:
        return _consts2.SubNetwork.KusamaSora;
      case _consts2.SubNetwork.Rococo:
        return _consts2.SubNetwork.RococoSora;
      default:
        throw new Error(`"${subNetwork}" has not SORA parachain`);
    }
  }
  getParachainId(subNetwork) {
    const parachainId = this.parachainIds[subNetwork];
    if (!parachainId) throw new Error(`Parachain id is not defined for "${subNetwork}" parachain`);
    return parachainId;
  }
  isRelayChain(subNetwork) {
    return [_consts2.SubNetwork.Kusama, _consts2.SubNetwork.Polkadot, _consts2.SubNetwork.Rococo].includes(subNetwork);
  }
  isSoraParachain(subNetwork) {
    return [_consts2.SubNetwork.RococoSora, _consts2.SubNetwork.KusamaSora].includes(subNetwork);
  }
  getRecipientArg(subNetwork, recipient) {
    const recipientPublicKey = this.api.createType('AccountId32', recipient).toHex();
    const accountXcmJunction = {
      [_consts2.XcmJunction.AccountId32]: {
        id: recipientPublicKey
      }
    };
    if (this.isRelayChain(subNetwork)) {
      return {
        [_consts.BridgeAccountType.Parachain]: {
          [_consts2.XcmVersionedMultiLocation.V3]: {
            parents: 1,
            interior: {
              [_consts2.XcmMultilocationJunction.X1]: accountXcmJunction
            }
          }
        }
      };
    }
    return {
      [_consts.BridgeAccountType.Parachain]: {
        [_consts2.XcmVersionedMultiLocation.V3]: {
          parents: 1,
          interior: {
            [_consts2.XcmMultilocationJunction.X2]: [
            // parachain id in relaychain
            {
              [_consts2.XcmJunction.Parachain]: this.getParachainId(subNetwork)
            },
            // recipient account
            accountXcmJunction]
          }
        }
      }
    };
  }
  generateHistoryItem(params) {
    if (!params.type) {
      return null;
    }
    const historyItem = params || {};
    historyItem.startTime = historyItem.startTime || Date.now();
    historyItem.id = this.encrypt(`${historyItem.startTime}`);
    historyItem.transactionState = historyItem.transactionState || _consts.BridgeTxStatus.Pending;
    this.saveHistory(historyItem);
    return historyItem;
  }
  saveHistory(history) {
    if (!(0, _BaseApi.isSubstrateOperation)(history.type)) return;
    super.saveHistory(history);
  }
  async getSubAssetDecimals(subNetwork, soraAssetId) {
    const precision = await this.api.query.parachainBridgeApp.sidechainPrecision(subNetwork, soraAssetId);
    return precision.unwrap().toNumber();
  }
  async getSubAssetKind(subNetwork, soraAssetId) {
    const kind = await this.api.query.parachainBridgeApp.assetKinds(subNetwork, soraAssetId);
    return kind.unwrap().isSidechain ? _consts2.SubAssetKind.Sidechain : _consts2.SubAssetKind.Thischain;
  }
  async getSubAssetData(relaychain, soraAssetId) {
    const [decimals, assetKind] = await Promise.all([this.getSubAssetDecimals(relaychain, soraAssetId), this.getSubAssetKind(relaychain, soraAssetId)]);
    return {
      decimals,
      assetKind
    };
  }
  async getRelayChainAssets(relaychain) {
    const assets = {};
    try {
      const assetCodec = await this.api.query.parachainBridgeApp.relaychainAsset(relaychain);
      const soraAssetId = assetCodec.unwrap().code.toString();
      const data = await this.getSubAssetData(relaychain, soraAssetId);
      assets[soraAssetId] = data;
      return assets;
    } catch {
      return assets;
    }
  }
  async getParaChainAssets(parachain) {
    const assets = {};
    const relaychain = this.getRelayChain(parachain);
    const parachainId = this.getParachainId(parachain);
    try {
      const assetsCodecs = await this.api.query.parachainBridgeApp.allowedParachainAssets(relaychain, parachainId);
      const soraAssetIds = assetsCodecs.map(item => item.code.toString());
      await Promise.all(soraAssetIds.map(async soraAssetId => {
        const data = await this.getSubAssetData(relaychain, soraAssetId);
        assets[soraAssetId] = data;
      }));
      return assets;
    } catch {
      return assets;
    }
  }
  async getRegisteredAssets(subNetwork) {
    return this.isRelayChain(subNetwork) ? await this.getRelayChainAssets(subNetwork) : await this.getParaChainAssets(subNetwork);
  }
  async getUserTransactions(accountAddress, subNetwork) {
    return await (0, _methods.getUserTransactions)(this.api, accountAddress, {
      [_consts.BridgeNetworkType.Sub]: this.getRelayChain(subNetwork)
    }, subNetwork, _consts.BridgeNetworkType.Sub, this.parachainIds);
  }
  async getTransactionDetails(accountAddress, subNetwork, hash) {
    return await (0, _methods.getTransactionDetails)(this.api, accountAddress, hash, {
      [_consts.BridgeNetworkType.Sub]: this.getRelayChain(subNetwork)
    }, subNetwork, _consts.BridgeNetworkType.Sub, this.parachainIds);
  }
  subscribeOnTransactionDetails(accountAddress, subNetwork, hash) {
    return (0, _methods.subscribeOnTransactionDetails)(this.apiRx, accountAddress, hash, {
      [_consts.BridgeNetworkType.Sub]: this.getRelayChain(subNetwork)
    }, subNetwork, _consts.BridgeNetworkType.Sub, this.parachainIds);
  }
  async getLockedAssets(subNetwork, assetAddress) {
    return await (0, _methods.getLockedAssets)(this.api, {
      [_consts.BridgeNetworkType.Sub]: subNetwork
    }, assetAddress);
  }
  getTransferExtrinsic(asset, recipient, amount, subNetwork) {
    const network = this.getRelayChain(subNetwork);
    const recipientData = this.getRecipientArg(subNetwork, recipient);
    const value = new _math.FPNumber(amount, asset.decimals).toCodecString();
    return this.api.tx.bridgeProxy.burn({
      [_consts.BridgeNetworkType.Sub]: network
    }, asset.address, recipientData, value);
  }
  async transfer(asset, recipient, amount, subNetwork, historyId) {
    (0, _util.assert)(this.account, _logger.Messages.connectWallet);
    const extrinsic = this.getTransferExtrinsic(asset, recipient, amount, subNetwork);
    const historyItem = this.getHistory(historyId) || {
      type: _BaseApi.Operation.SubstrateOutgoing,
      symbol: asset.symbol,
      assetAddress: asset.address,
      amount: `${amount}`
    };
    await this.submitExtrinsic(extrinsic, this.account.pair, historyItem);
  }
  async getNetworkFee(asset, subNetwork) {
    const tx = this.getTransferExtrinsic(asset, '', '0', subNetwork);
    return await this.getTransactionFee(tx);
  }
}
exports.SubBridgeApi = SubBridgeApi;