"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EthBridgeApi = void 0;
var _first = _interopRequireDefault(require("lodash/fp/first"));
var _util = require("@polkadot/util");
var _rxjs = require("rxjs");
var _math = require("@sora-substrate/math");
var _BaseApi = require("../../BaseApi");
var _logger = require("../../logger");
var _methods = require("../methods");
var _consts = require("../consts");
var _consts2 = require("./consts");
var _methods2 = require("./methods");
class EthBridgeApi extends _BaseApi.BaseApi {
  constructor() {
    super('ethBridgeHistory');
    this.externalNetwork = _consts2.EthNetwork.Ethereum;
  }
  initAccountStorage() {
    var _this$accountStorage, _this$accountStorage2;
    super.initAccountStorage();
    // 1.18 migration
    // "bridgeHistory" -> "ethBridgeHistory"
    // "bridgeHistorySyncTimestamp" -> "ethBridgeHistorySyncTimestamp"
    (_this$accountStorage = this.accountStorage) === null || _this$accountStorage === void 0 ? void 0 : _this$accountStorage.remove('bridgeHistory');
    (_this$accountStorage2 = this.accountStorage) === null || _this$accountStorage2 === void 0 ? void 0 : _this$accountStorage2.remove('bridgeHistorySyncTimestamp');
  }
  generateHistoryItem(params) {
    if (!params.type) {
      return null;
    }
    const historyItem = params || {};
    historyItem.startTime = historyItem.startTime || Date.now();
    historyItem.id = this.encrypt(`${historyItem.startTime}`);
    historyItem.transactionState = historyItem.transactionState || 'INITIAL';
    this.saveHistory(historyItem);
    return historyItem;
  }
  saveHistory(history) {
    if (!(history && history.id && (0, _BaseApi.isEthOperation)(history.type))) {
      return;
    }
    super.saveHistory(history);
  }
  getTransferExtrinsic(asset, recipient, amount) {
    const value = new _math.FPNumber(amount, asset.decimals).toCodecString();
    return this.api.tx.ethBridge.transferToSidechain(asset.address, recipient, value, this.externalNetwork);
  }

  /**
   * Transfer through the bridge operation
   * @param asset Asset
   * @param recipient Ethereum account address
   * @param amount
   * @param historyId not required
   */
  transfer(asset, recipient, amount, historyId) {
    (0, _util.assert)(this.account, _logger.Messages.connectWallet);
    const extrinsic = this.getTransferExtrinsic(asset, recipient, amount);
    const historyItem = this.getHistory(historyId) || {
      symbol: asset.symbol,
      assetAddress: asset.address,
      amount: `${amount}`,
      type: _BaseApi.Operation.EthBridgeOutgoing
    };
    return this.submitExtrinsic(extrinsic, this.account.pair, historyItem);
  }

  /**
   * Get registered assets for bridge
   * @returns Array with all registered assets
   */
  async getRegisteredAssets() {
    const data = await this.api.rpc.ethBridge.getRegisteredAssets(this.externalNetwork);
    if (!data.isOk) {
      // Returns an empty list and logs issue
      console.warn('[api.bridge.getRegisteredAssets]:', data.asErr.toString());
      return {};
    }
    return data.asOk.reduce((buffer, _ref) => {
      let [kind, soraAsset, externalAsset] = _ref;
      const assetKind = kind.toString();
      const soraAssetId = soraAsset[0].toString();
      let externalAddress = '';
      let externalDecimals = undefined;
      if (externalAsset.isSome) {
        const [externalAssetId, externalAssetDecimals] = externalAsset.unwrap();
        externalAddress = externalAssetId.toString();
        externalDecimals = externalAssetDecimals.toNumber();
      }
      buffer[soraAssetId] = {
        address: externalAddress,
        decimals: externalDecimals,
        assetKind
      };
      return buffer;
    }, {});
  }

  /**
   * Get approved request
   * @param hash Bridge hash
   * @returns Approved request with proofs
   */
  async getApprovedRequest(hash) {
    const data = await this.api.rpc.ethBridge.getApprovedRequests([hash], this.externalNetwork);
    (0, _methods2.assertRequest)(data, 'api.bridge.getApprovedRequest');
    return (0, _first.default)(data.asOk.map(_ref2 => {
      let [request, proofs] = _ref2;
      return (0, _methods2.formatApprovedRequest)(request, proofs);
    }));
  }

  /**
   * Returns bridge request status
   * @param hash sora or evm transaction hash
   * @returns BridgeRequest status
   */
  async getRequestStatus(hash) {
    return (await this.api.query.ethBridge.requestStatuses(this.externalNetwork, hash)).toHuman() || null;
  }

  /**
   * Creates a subscription to bridge request status
   * @param hash sora or evm transaction hash
   * @returns BridgeRequest status
   */
  subscribeOnRequestStatus(hash) {
    return this.apiRx.query.ethBridge.requestStatuses(this.externalNetwork, hash).pipe((0, _rxjs.map)(data => data.toHuman() || null));
  }

  /**
   * Creates a subscription to bridge request data
   * @param hash sora or evm transaction hash
   * @returns BridgeRequest not formatted body
   */
  subscribeOnRequestData(hash) {
    return this.apiRx.query.ethBridge.requests(this.externalNetwork, hash).pipe((0, _rxjs.map)(data => data.isSome ? data.unwrap() : null));
  }

  /**
   * Creates a subscription to bridge request
   * @param hash sora or evm transaction hash
   * @returns BridgeRequest if request is registered
   */
  subscribeOnRequest(hash) {
    const data = this.subscribeOnRequestData(hash);
    const status = this.subscribeOnRequestStatus(hash);
    return (0, _rxjs.combineLatest)([data, status]).pipe((0, _rxjs.map)(_ref3 => {
      let [data, status] = _ref3;
      return !!data && !!status ? (0, _methods2.formatRequest)(data, status) : null;
    }));
  }
  async getSoraHashByEthereumHash(ethereumHash) {
    return (await this.api.query.ethBridge.loadToIncomingRequestHash(this.externalNetwork, ethereumHash)).toString();
  }
  async getSoraBlockHashByRequestHash(requestHash) {
    const soraBlockNumber = (await this.api.query.ethBridge.requestSubmissionHeight(this.externalNetwork, requestHash)).toNumber();
    const soraBlockHash = (await this.api.rpc.chain.getBlockHash(soraBlockNumber)).toString();
    return soraBlockHash;
  }
  async getAssetKind(assetAddress) {
    const data = await this.api.query.ethBridge.registeredAsset(this.externalNetwork, assetAddress);
    if (!data.isSome) return null;
    const kind = data.unwrap();
    return kind.toString();
  }
  async getLockedAssets(evmNetwork, assetAddress) {
    return await (0, _methods.getLockedAssets)(this.api, {
      [_consts.BridgeNetworkType.Eth]: this.externalNetwork
    }, assetAddress);
  }
}
exports.EthBridgeApi = EthBridgeApi;