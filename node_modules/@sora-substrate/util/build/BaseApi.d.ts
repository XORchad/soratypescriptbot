import { Observable } from 'rxjs';
import { CodecString } from '@sora-substrate/math';
import type { ApiPromise, ApiRx } from '@polkadot/api';
import type { CreateResult } from '@polkadot/ui-keyring/types';
import type { KeyringPair, KeyringPair$Json } from '@polkadot/keyring/types';
import type { Signer } from '@polkadot/types/types';
import type { SubmittableExtrinsic } from '@polkadot/api-base/types';
import { AccountStorage, Storage } from './storage';
import { ReceiverHistoryItem } from './swap/types';
import type { EthHistory } from './bridgeProxy/eth/types';
import type { EvmHistory } from './bridgeProxy/evm/types';
import type { SubHistory } from './bridgeProxy/sub/types';
import type { RewardClaimHistory } from './rewards/types';
import type { OriginalIdentity, StakingHistory } from './staking/types';
import type { LimitOrderHistory } from './orderBook/types';
export declare type SaveHistoryOptions = {
    wasNotGenerated?: boolean;
    toCurrentAccount?: boolean;
};
export declare type ErrorMessageFields = {
    section: string;
    name: string;
};
export declare type NetworkFeesObject = {
    [key in Operation]: CodecString;
};
export declare type IBridgeTransaction = EvmHistory | SubHistory | EthHistory;
export declare type HistoryItem = History | IBridgeTransaction | RewardClaimHistory | StakingHistory | LimitOrderHistory;
export declare type FnResult = void | Observable<ExtrinsicEvent>;
export declare type ExtrinsicEvent = [TransactionStatus, HistoryItem];
interface ISubmitExtrinsic<T> {
    submitExtrinsic(extrinsic: SubmittableExtrinsic<'promise'>, signer: KeyringPair, historyData?: HistoryItem, unsigned?: boolean): Promise<T>;
}
export declare type AccountHistory<T> = {
    [key: string]: T;
};
export declare const isEthOperation: (operation: Operation) => boolean;
export declare const isEvmOperation: (operation: Operation) => boolean;
export declare const isSubstrateOperation: (operation: Operation) => boolean;
export declare const KeyringType = "sr25519";
export declare class BaseApi<T = void> implements ISubmitExtrinsic<T> {
    readonly historyNamespace: string;
    /**
     * Network fee values which can be used right after `calcStaticNetworkFees` method.
     *
     * Each value is represented as `CodecString`
     */
    NetworkFee: NetworkFeesObject;
    readonly prefix = 69;
    private _history;
    protected signer?: Signer;
    storage?: Storage;
    accountStorage?: AccountStorage;
    account: CreateResult;
    /** If `true` you might subscribe on extrinsic statuses (`false` by default) */
    shouldObservableBeUsed: boolean;
    /** If `true` it'll be locked during extrinsics submit (`false` by default) */
    shouldPairBeLocked: boolean;
    constructor(historyNamespace?: string);
    get api(): ApiPromise;
    get apiRx(): ApiRx;
    get accountPair(): KeyringPair;
    get address(): string;
    get accountJson(): KeyringPair$Json;
    logout(): void;
    initAccountStorage(): void;
    get history(): AccountHistory<HistoryItem>;
    set history(value: AccountHistory<HistoryItem>);
    get historyList(): Array<HistoryItem>;
    getHistory(id: string): HistoryItem | null;
    getFilteredHistory(filterFn: (item: HistoryItem) => boolean): AccountHistory<HistoryItem>;
    saveHistory(historyItem: HistoryItem, options?: SaveHistoryOptions): void;
    removeHistory(...ids: Array<string>): void;
    clearHistory(): void;
    /**
     * Set account data
     * @param account
     */
    setAccount(account: CreateResult): void;
    /**
     * Unlock pair to sign tx
     * @param password
     */
    unlockPair(password: string): void;
    /**
     * Lock pair
     */
    lockPair(): void;
    /**
     * Set signer if the pair is locked (For polkadot js extension usage)
     * @param signer
     */
    setSigner(signer: Signer): void;
    /**
     * Set storage if it should be used as data storage
     * @param storage
     */
    setStorage(storage: Storage): void;
    private getAccountWithOptions;
    submitApiExtrinsic(api: ApiPromise, extrinsic: SubmittableExtrinsic<'promise'>, signer: KeyringPair, historyData?: HistoryItem, unsigned?: boolean): Promise<T>;
    submitExtrinsic(extrinsic: SubmittableExtrinsic<'promise'>, signer: KeyringPair, historyData?: HistoryItem, unsigned?: boolean): Promise<T>;
    /**
     * Returns an extrinsic with the default or empty params.
     *
     * Actually, network fee value doesn't depend on extrinsic params, so, we can use empty/default values
     * @param operation
     */
    private getEmptyExtrinsic;
    /**
     * Calc all required network fees. The result will be written to `NetworkFee` object.
     *
     * For example, `api.NetworkFee[Operation.AddLiquidity]`
     */
    calcStaticNetworkFees(): Promise<void>;
    getTransactionFee(extrinsic: SubmittableExtrinsic<'promise'>): Promise<CodecString>;
    /**
     * Format address
     * @param withSoraPrefix `true` by default
     */
    formatAddress(address: string, withSoraPrefix?: boolean): string;
    /**
     * Validate address
     * @param address
     */
    validateAddress(address: string): boolean;
    /**
     * Get public key as hex string by account address
     * @param address
     * @returns
     */
    getPublicKeyByAddress(address: string): string;
    /**
     * Generate unique string from value
     * @param value
     * @returns
     */
    encrypt(value: string): string;
}
export declare enum TransactionStatus {
    Ready = "ready",
    Broadcast = "broadcast",
    InBlock = "inblock",
    Finalized = "finalized",
    Error = "error",
    Usurped = "usurped",
    Invalid = "invalid"
}
export declare enum Operation {
    Swap = "Swap",
    Transfer = "Transfer",
    AddLiquidity = "AddLiquidity",
    RemoveLiquidity = "RemoveLiquidity",
    CreatePair = "CreatePair",
    Faucet = "Faucet",
    RegisterAsset = "RegisterAsset",
    EthBridgeOutgoing = "EthBridgeOutgoing",
    EthBridgeIncoming = "EthBridgeIncoming",
    EvmOutgoing = "EvmOutgoing",
    EvmIncoming = "EvmIncoming",
    SubstrateOutgoing = "SubstrateOutgoing",
    SubstrateIncoming = "SubstrateIncoming",
    ClaimRewards = "ClaimRewards",
    /** it's used for calc network fee */
    ClaimVestedRewards = "ClaimVestedRewards",
    /** it's used for calc network fee */
    ClaimCrowdloanRewards = "ClaimCrowdloanRewards",
    /** it's used for calc network fee */
    ClaimLiquidityProvisionRewards = "LiquidityProvisionRewards",
    /** it's used for calc network fee */
    ClaimExternalRewards = "ClaimExternalRewards",
    /** it's used for internal needs as the MST batch with transfers  */
    TransferAll = "TransferAll",
    /** Complex Swap */
    SwapAndSend = "SwapAndSend",
    SwapTransferBatch = "SwapTransferBatch",
    /** Referral System */
    ReferralReserveXor = "ReferralReserveXor",
    ReferralUnreserveXor = "ReferralUnreserveXor",
    ReferralSetInvitedUser = "ReferralSetInvitedUser",
    /** Staking */
    StakingBond = "StakingBond",
    StakingBondExtra = "StakingBondExtra",
    StakingRebond = "StakingRebond",
    StakingUnbond = "StakingUnbond",
    StakingWithdrawUnbonded = "StakingWithdrawUnbonded",
    StakingNominate = "StakingNominate",
    StakingChill = "StakingChill",
    StakingSetPayee = "StakingSetPayee",
    StakingSetController = "StakingSetController",
    StakingPayout = "StakingPayout",
    /** Demeter Farming Platform  */
    DemeterFarmingDepositLiquidity = "DemeterFarmingDepositLiquidity",
    DemeterFarmingWithdrawLiquidity = "DemeterFarmingWithdrawLiquidity",
    DemeterFarmingStakeToken = "DemeterFarmingStakeToken",
    DemeterFarmingUnstakeToken = "DemeterFarmingUnstakeToken",
    DemeterFarmingGetRewards = "DemeterFarmingGetRewards",
    /** Ceres Liquidity Locker  */
    CeresLiquidityLockerLockLiquidity = "CeresLiquidityLockerLockLiquidity",
    /** Order Book */
    PlaceLimitOrder = "PlaceLimitOrder",
    CancelLimitOrder = "CancelLimitOrder",
    CancelLimitOrders = "CancelLimitOrders"
}
export interface History {
    txId?: string;
    type: Operation;
    amount?: string;
    symbol?: string;
    assetAddress?: string;
    id?: string;
    blockId?: string;
    blockHeight?: number;
    to?: string;
    receivers?: Array<ReceiverHistoryItem>;
    amount2?: string;
    symbol2?: string;
    asset2Address?: string;
    decimals?: number;
    decimals2?: number;
    startTime?: number;
    endTime?: number;
    from?: string;
    status?: string;
    errorMessage?: ErrorMessageFields | string;
    liquiditySource?: string;
    liquidityProviderFee?: CodecString;
    soraNetworkFee?: CodecString;
    payload?: any;
}
export interface OnChainIdentity {
    legalName: string;
    approved: boolean;
    identity: OriginalIdentity;
}
export {};
