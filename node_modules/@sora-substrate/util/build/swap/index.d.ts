import { NumberLike, FPNumber, CodecString } from '@sora-substrate/math';
import { LiquiditySourceTypes } from '@sora-substrate/liquidity-proxy';
import type { PrimaryMarketsEnabledAssets, QuotePayload, SwapResult } from '@sora-substrate/liquidity-proxy';
import type { Observable } from '@polkadot/types/types';
import { DexId } from '../dex/consts';
import { Api } from '../api';
import type { AccountAsset, Asset } from '../assets/types';
import type { SwapTransferBatchData, SwapQuoteData } from './types';
interface SwapResultWithDexId extends SwapResult {
    dexId: DexId;
}
export declare class SwapModule<T> {
    private readonly root;
    enabledAssets: PrimaryMarketsEnabledAssets;
    constructor(root: Api<T>);
    update(): Promise<void>;
    private prepareSourcesForSwapParams;
    /**
     * Get min or max value before Swap
     * @param tokenFrom Asset A address
     * @param tokenTo Asset B address
     * @param fromValue Asset A value
     * @param toValue Asset B value
     * @param isExchangeB If `isExchangeB` then Exchange B and it calculates max sold,
     * else - Exchange A and it calculates min received
     * @param slippageTolerance
     */
    getMinMaxValue(tokenFrom: Asset | AccountAsset, tokenTo: Asset | AccountAsset, fromValue: string, toValue: string, isExchangeB: boolean, slippageTolerance: NumberLike): CodecString;
    /**
     * Get price impact
     * @param tokenFrom Asset A address
     * @param tokenTo Asset B address
     * @param fromValue Asset A value
     * @param toValue Asset B value
     * @param amountWithoutImpact Amount without impact
     * @param isExchangeB
     */
    getPriceImpact(tokenFrom: Asset | AccountAsset, tokenTo: Asset | AccountAsset, fromValue: string, toValue: string, amountWithoutImpact: CodecString, isExchangeB: boolean): string;
    /**
     * Get swap result
     * @param assetAAddress Asset A address
     * @param assetBAddress Asset B address
     * @param value value (Asset A if Exchange A, else - Asset B)
     * @param isExchangeB Exchange A if `isExchangeB=false` else Exchange B
     * @param selectedSources Selected liquidity sources
     * @param payload Quote payload
     */
    getResult(assetAAddress: string, assetBAddress: string, value: NumberLike, isExchangeB: boolean, payload: QuotePayload, selectedSources?: Array<LiquiditySourceTypes>, dexId?: DexId, deduceFee?: boolean): SwapResult;
    getTbcAssets(): Promise<string[]>;
    getXstAssets(): Promise<Record<string, {
        referenceSymbol: string;
        feeRatio: FPNumber;
    }>>;
    /**
     * Get primary markets enabled assets observable
     */
    getPrimaryMarketsEnabledAssets(): Promise<PrimaryMarketsEnabledAssets>;
    /**
     * Get observable reserves for swapped tokens
     * @param firstAssetAddress Asset A address
     * @param secondAssetAddress Asset B address
     * @param selectedSources Selected liquidity sources
     * @param dexId Selected dex id for swap
     */
    subscribeOnReserves(firstAssetAddress: string, secondAssetAddress: string, selectedSources?: LiquiditySourceTypes[], dexId?: DexId): Observable<QuotePayload> | null;
    /**
     * Get observable liquidity proxy quote function for two assets
     * @param firstAssetAddress First swap token address
     * @param secondAssetAddress Second swap token address
     * @param sources Liquidity sources available for swap (all sources by default)
     * @param dexId Selected Dex Id
     */
    getSwapQuoteObservable(firstAssetAddress: string, secondAssetAddress: string, sources?: LiquiditySourceTypes[], dexId?: DexId): Observable<SwapQuoteData> | null;
    /**
     * Get observable liquidity proxy quote function for two assets across all Dexes
     * @param firstAssetAddress First swap token address
     * @param secondAssetAddress Second swap token address
     * @param sources Liquidity sources for swap (all sources by default)
     */
    getDexesSwapQuoteObservable(firstAssetAddress: string, secondAssetAddress: string, sources?: LiquiditySourceTypes[]): Observable<SwapQuoteData> | null;
    private calcTxParams;
    /**
     * Run swap operation
     * @param assetA Asset A
     * @param assetB Asset B
     * @param amountA Amount A value
     * @param amountB Amount B value
     * @param slippageTolerance Slippage tolerance coefficient (in %)
     * @param isExchangeB Exchange A if `isExchangeB=false` else Exchange B. `false` by default
     * @param dexId dex id to detect base asset (XOR or XSTUSD)
     */
    execute(assetA: Asset | AccountAsset, assetB: Asset | AccountAsset, amountA: NumberLike, amountB: NumberLike, slippageTolerance?: NumberLike, isExchangeB?: boolean, liquiditySource?: LiquiditySourceTypes, dexId?: DexId): Promise<T>;
    /**
     * Run swap & send batch operation
     * @param receiver Receiver account address
     * @param assetA Asset A
     * @param assetB Asset B
     * @param amountA Amount A value
     * @param amountB Amount B value
     * @param slippageTolerance Slippage tolerance coefficient (in %)
     * @param isExchangeB Exchange A if `isExchangeB=false` else Exchange B. `false` by default
     * @param dexId dex id to detect base asset (XOR or XSTUSD)
     */
    executeSwapAndSend(receiver: string, assetA: Asset | AccountAsset, assetB: Asset | AccountAsset, amountA: NumberLike, amountB: NumberLike, slippageTolerance?: NumberLike, isExchangeB?: boolean, liquiditySource?: LiquiditySourceTypes, dexId?: DexId): Promise<T>;
    private calcTxParamsSwapTransferBatch;
    /**
     * Run swap transfers batch operation
     * @param receivers the ordered map, which maps the asset id and dexId being bought to the vector of batch receivers
     * @param inputAsset asset being sold
     * @param maxInputAmount max amount being sold
     */
    executeSwapTransferBatch(receivers: Array<SwapTransferBatchData>, inputAsset: Asset | AccountAsset, maxInputAmount: NumberLike, liquiditySource?: LiquiditySourceTypes): Promise<T>;
    /**
     * **RPC**
     *
     * Get swap result using `liquidityProxy.quote` rpc call using predefined DEX ID.
     *
     * It's better to use `getResult` function because of the blockchain performance
     *
     * @param assetAAddress Asset A address
     * @param assetBAddress Asset B address
     * @param amount Amount value (Asset A if Exchange A, else - Asset B)
     * @param isExchangeB Exchange A if `isExchangeB=false` else Exchange B. `false` by default
     * @param liquiditySource Selected liquidity source; `''` by default
     * @param allowSelectedSorce Filter mode for source (`AllowSelected` or `ForbidSelected`); `true` by default
     * @param dexId DEX ID: might be `0` - XOR based or `1` - XSTUSD based; `0` by default
     */
    getResultFromDexRpc(assetAAddress: string, assetBAddress: string, amount: NumberLike, isExchangeB?: boolean, liquiditySource?: LiquiditySourceTypes, allowSelectedSorce?: boolean, dexId?: DexId): Promise<SwapResult>;
    /**
     * **RPC**
     *
     * Get swap result using `liquidityProxy.quote` rpc call for all DEX IDs (XOR & XSTUSD based).
     *
     * It's better to use `getResult` function because of the blockchain performance
     *
     * @param assetAAddress Asset A address
     * @param assetBAddress Asset B address
     * @param amount Amount value (Asset A if Exchange A, else - Asset B)
     * @param isExchangeB Exchange A if `isExchangeB=false` else Exchange B. `false` by default
     * @param liquiditySource Selected liquidity source; `''` by default
     * @param allowSelectedSorce Filter mode for source (`AllowSelected` or `ForbidSelected`); `true` by default
     */
    getResultRpc(assetAAddress: string, assetBAddress: string, amount: NumberLike, isExchangeB?: boolean, liquiditySource?: LiquiditySourceTypes, allowSelectedSorce?: boolean): Promise<SwapResultWithDexId>;
    /**
     * **RPC**
     *
     * Subscribe on swap result using `liquidityProxy.quote` rpc call for all DEX IDs (XOR & XSTUSD based).
     *
     * @param assetAAddress Asset A address
     * @param assetBAddress Asset B address
     * @param amount Amount value (Asset A if Exchange A, else - Asset B)
     * @param isExchangeB Exchange A if `isExchangeB=false` else Exchange B. `false` by default
     * @param liquiditySource Selected liquidity source; `''` by default
     * @param allowSelectedSorce Filter mode for source (`AllowSelected` or `ForbidSelected`); `true` by default
     */
    subscribeOnResultRpc(assetAAddress: string, assetBAddress: string, amount: NumberLike, isExchangeB?: boolean, liquiditySource?: LiquiditySourceTypes, allowSelectedSorce?: boolean): Observable<Promise<SwapResultWithDexId>>;
    /**
     * **RPC**
     *
     * Check swap operation using `liquidityProxy.isPathAvailable` rpc call
     * @param firstAssetAddress
     * @param secondAssetAddress
     * @param dexId
     * @returns availability of swap operation
     */
    checkSwap(firstAssetAddress: string, secondAssetAddress: string, dexId?: DexId): Promise<boolean>;
    /**
     * **RPC**
     *
     * Get liquidity sources for selected pair using `tradingPair.listEnabledSourcesForPair` rpc call
     * @param firstAssetAddress
     * @param secondAssetAddress
     * @param dexId
     */
    getEnabledLiquiditySourcesForPair(firstAssetAddress: string, secondAssetAddress: string, dexId?: DexId): Promise<Array<LiquiditySourceTypes>>;
    /**
     * **RPC**
     *
     * Check liquidity Source availability for the selected pair using `tradingPair.isSourceEnabledForPair` rpc call
     * @param firstAssetAddress
     * @param secondAssetAddress
     * @param liquiditySource
     * @param dexId
     */
    checkLiquiditySourceIsEnabledForPair(firstAssetAddress: string, secondAssetAddress: string, liquiditySource: LiquiditySourceTypes, dexId?: DexId): Promise<boolean>;
}
export {};
