"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SwapModule = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _util = require("@polkadot/util");
var _isEmpty = _interopRequireDefault(require("lodash/fp/isEmpty"));
var _rxjs = require("rxjs");
var _math = require("@sora-substrate/math");
var _liquidityProxy = require("@sora-substrate/liquidity-proxy");
var _consts = require("./consts");
var _consts2 = require("../assets/consts");
var _consts3 = require("../dex/consts");
var _logger = require("../logger");
var _BaseApi = require("../BaseApi");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const comparator = (prev, curr) => JSON.stringify(prev) === JSON.stringify(curr);
const toAssetId = o => o.pipe((0, _rxjs.map)(asset => asset.code.toString()), (0, _rxjs.distinctUntilChanged)(comparator));
const toCodec = o => o.pipe((0, _rxjs.map)(codec => {
  return Array.isArray(codec) ? codec.map(item => item.toString()) : codec.toString();
}), (0, _rxjs.distinctUntilChanged)(comparator));
const fromFixnumToCodec = o => o.pipe((0, _rxjs.map)(codec => codec.inner.toString()), (0, _rxjs.distinctUntilChanged)(comparator));
const toAveragePrice = o => o.pipe((0, _rxjs.map)(codec => ({
  [_liquidityProxy.PriceVariant.Buy]: codec.value.buy.averagePrice.toString(),
  [_liquidityProxy.PriceVariant.Sell]: codec.value.sell.averagePrice.toString()
})), (0, _rxjs.distinctUntilChanged)(comparator));
const toBandRate = o => o.pipe((0, _rxjs.map)(codec => {
  const data = codec.unwrap();
  const value = data.value.toString();
  const lastUpdated = data.lastUpdated.toNumber();
  const dynamicFee = data.dynamicFee.inner.toString();
  return {
    value,
    lastUpdated,
    dynamicFee
  };
}), (0, _rxjs.distinctUntilChanged)(comparator));
const toAssetIds = data => [...data.values()].map(asset => asset.code.toString());
const getAssetAveragePrice = (assetAddress, root) => {
  return toAveragePrice(root.apiRx.query.priceTools.priceInfos(assetAddress));
};
const getAggregatedOrderBook = (assetAddress, baseAssetId, root) => {
  return (0, _rxjs.combineLatest)([root.orderBook.getOrderBookObservable(assetAddress, baseAssetId), root.orderBook.subscribeOnAggregatedAsks(assetAddress, baseAssetId), root.orderBook.subscribeOnAggregatedBids(assetAddress, baseAssetId)]).pipe((0, _rxjs.map)(_ref => {
    let [book, asks, bids] = _ref;
    if (!book) return null;
    return _objectSpread(_objectSpread({}, book), {}, {
      aggregated: {
        asks,
        bids
      }
    });
  }), (0, _rxjs.distinctUntilChanged)(comparator));
};
const combineValuesWithKeys = (values, keys) => values.reduce((result, value, index) => _objectSpread(_objectSpread({}, result), {}, {
  [keys[index]]: value
}), {});
const emptySwapResult = {
  amount: 0,
  fee: 0,
  rewards: [],
  amountWithoutImpact: 0,
  route: []
};
class SwapModule {
  constructor(root) {
    this.root = root;
    this.enabledAssets = void 0;
  }
  async update() {
    this.enabledAssets = await this.getPrimaryMarketsEnabledAssets();
  }
  prepareSourcesForSwapParams(liquiditySource) {
    return liquiditySource ? [liquiditySource] : [];
  }

  /**
   * Get min or max value before Swap
   * @param tokenFrom Asset A address
   * @param tokenTo Asset B address
   * @param fromValue Asset A value
   * @param toValue Asset B value
   * @param isExchangeB If `isExchangeB` then Exchange B and it calculates max sold,
   * else - Exchange A and it calculates min received
   * @param slippageTolerance
   */
  getMinMaxValue(tokenFrom, tokenTo, fromValue, toValue, isExchangeB, slippageTolerance) {
    const value = isExchangeB ? fromValue : toValue;
    const token = isExchangeB ? tokenFrom : tokenTo;
    if (!token || !value) return _consts.Consts.ZERO_STR;
    const resultDecimals = token.decimals;
    const result = new _math.FPNumber(value, resultDecimals);
    const resultMulSlippage = result.mul(new _math.FPNumber(Number(slippageTolerance) / 100, resultDecimals));
    return (!isExchangeB ? result.sub(resultMulSlippage) : result.add(resultMulSlippage)).toCodecString();
  }

  /**
   * Get price impact
   * @param tokenFrom Asset A address
   * @param tokenTo Asset B address
   * @param fromValue Asset A value
   * @param toValue Asset B value
   * @param amountWithoutImpact Amount without impact
   * @param isExchangeB
   */
  getPriceImpact(tokenFrom, tokenTo, fromValue, toValue, amountWithoutImpact, isExchangeB) {
    const token = isExchangeB ? tokenFrom : tokenTo;
    const value = isExchangeB ? fromValue : toValue;
    if (!token || !value || !amountWithoutImpact) return _consts.Consts.ZERO_STR;
    const withoutImpact = _math.FPNumber.fromCodecValue(amountWithoutImpact, token.decimals);
    if (withoutImpact.isZero()) return _consts.Consts.ZERO_STR;
    const amount = new _math.FPNumber(value, token.decimals);
    const impact = isExchangeB ? withoutImpact.div(amount) : amount.div(withoutImpact);
    const result = _math.FPNumber.ONE.sub(impact).mul(_math.FPNumber.HUNDRED);
    return _math.FPNumber.lte(result, _math.FPNumber.ZERO) ? _consts.Consts.ZERO_STR : _math.FPNumber.ZERO.sub(result).toFixed(2);
  }

  /**
   * Get swap result
   * @param assetAAddress Asset A address
   * @param assetBAddress Asset B address
   * @param value value (Asset A if Exchange A, else - Asset B)
   * @param isExchangeB Exchange A if `isExchangeB=false` else Exchange B
   * @param selectedSources Selected liquidity sources
   * @param payload Quote payload
   */
  getResult(assetAAddress, assetBAddress, value, isExchangeB, payload) {
    let selectedSources = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
    let dexId = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : _consts3.DexId.XOR;
    let deduceFee = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;
    const amount = new _math.FPNumber(value);
    const baseAssetId = this.root.dex.getBaseAssetId(dexId);
    const syntheticBaseAssetId = this.root.dex.getSyntheticBaseAssetId(dexId);
    return (0, _liquidityProxy.quote)(assetAAddress, assetBAddress, amount, !isExchangeB, selectedSources, payload, deduceFee, baseAssetId, syntheticBaseAssetId);
  }
  async getTbcAssets() {
    const assets = await this.root.api.query.multicollateralBondingCurvePool.enabledTargets();
    return toAssetIds(assets);
  }
  async getXstAssets() {
    const entries = await this.root.api.query.xstPool.enabledSynthetics.entries();
    return entries.reduce((buffer, _ref2) => {
      let [key, value] = _ref2;
      const id = key.args[0].code.toString();
      const data = value.unwrap();
      const referenceSymbol = new TextDecoder().decode(data.referenceSymbol);
      const feeRatio = _math.FPNumber.fromCodecValue(data.feeRatio.inner.toString());
      buffer[id] = {
        referenceSymbol,
        feeRatio
      };
      return buffer;
    }, {});
  }

  /**
   * Get primary markets enabled assets observable
   */
  async getPrimaryMarketsEnabledAssets() {
    const [tbc, xst] = await Promise.all([this.getTbcAssets(), this.getXstAssets()]);
    return {
      tbc,
      xst
    };
  }

  /**
   * Get observable reserves for swapped tokens
   * @param firstAssetAddress Asset A address
   * @param secondAssetAddress Asset B address
   * @param selectedSources Selected liquidity sources
   * @param dexId Selected dex id for swap
   */
  subscribeOnReserves(firstAssetAddress, secondAssetAddress) {
    var _enabledAssets$tbc, _enabledAssets$xst;
    let selectedSources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    let dexId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _consts3.DexId.XOR;
    const isXorDex = dexId === _consts3.DexId.XOR;
    const xor = _consts2.XOR.address;
    const dai = _consts2.DAI.address;
    const xstusd = _consts2.XSTUSD.address;
    const baseAssetId = this.root.dex.getBaseAssetId(dexId);
    const syntheticBaseAssetId = this.root.dex.getSyntheticBaseAssetId(dexId);
    const enabledSources = [...this.root.dex.enabledSources];
    const lockedSources = [...this.root.dex.lockedSources];
    const enabledAssets = isXorDex ? _objectSpread({}, this.enabledAssets) : {
      tbc: [],
      xst: {}
    };
    const tbcAssets = (_enabledAssets$tbc = enabledAssets === null || enabledAssets === void 0 ? void 0 : enabledAssets.tbc) !== null && _enabledAssets$tbc !== void 0 ? _enabledAssets$tbc : [];
    const xstAssets = (_enabledAssets$xst = enabledAssets === null || enabledAssets === void 0 ? void 0 : enabledAssets.xst) !== null && _enabledAssets$xst !== void 0 ? _enabledAssets$xst : {};
    const isSourceUsed = source => enabledSources.includes(source) && (!selectedSources.length || selectedSources.includes(source));

    // is XYK and [TBC, XST, OrderBook](only for XOR Dex) sources used
    const xykUsed = isSourceUsed(_liquidityProxy.LiquiditySourceTypes.XYKPool);
    const tbcUsed = isXorDex && isSourceUsed(_liquidityProxy.LiquiditySourceTypes.MulticollateralBondingCurvePool);
    const xstUsed = isXorDex && isSourceUsed(_liquidityProxy.LiquiditySourceTypes.XSTPool);
    const orderBookUsed = isXorDex && isSourceUsed(_liquidityProxy.LiquiditySourceTypes.OrderBook);
    if ([xykUsed, tbcUsed, xstUsed, orderBookUsed].every(isUsed => !isUsed)) {
      return null;
    }

    // possible paths for swap (we need to find all possible assets)
    const exchangePaths = (0, _liquidityProxy.newTrivial)(baseAssetId, syntheticBaseAssetId, Object.keys(xstAssets), firstAssetAddress, secondAssetAddress);
    // list of all assets what could be used in swap
    const assetsInPaths = [...new Set(exchangePaths.flat(1))];
    // Assets that could have XYK reserves (with baseAssetId)
    const assetsWithXykReserves = assetsInPaths.filter(address => address !== baseAssetId);
    // Assets that could have TBC collateral reserves (not XOR)
    const assetsWithTbcReserves = assetsInPaths.filter(address => tbcAssets.includes(address));
    // Assets that could have OrderBook reserves (base: assetId; quote: baseAssetId)
    const assetsWithOrderBookReserves = assetsInPaths.filter(address => address !== baseAssetId);
    // Assets that have average price data (storage has prices only for collateral TBC assets), DAI required
    const assetsWithAveragePrices = [...new Set([...assetsWithTbcReserves, dai])];
    // Assets for which we need to know the total supply
    const assetsWithIssuances = [xor];
    // Tickers with rates in oracle (except USD ticker, because it is the same as DAI)
    const tickersWithOracleRates = assetsInPaths.reduce((buffer, address) => {
      if (address !== xstusd && !!xstAssets[address]) {
        buffer.push(xstAssets[address].referenceSymbol);
      }
      return buffer;
    }, []);
    const xykReserves = xykUsed ? assetsWithXykReserves.map(address => toCodec(this.root.apiRx.query.poolXYK.reserves(baseAssetId, address))) : [];
    const orderBookReserves = orderBookUsed ? assetsWithOrderBookReserves.map(address => getAggregatedOrderBook(address, baseAssetId, this.root)) : [];

    // fill array if TBC source available
    const tbcReserves = tbcUsed ? assetsWithTbcReserves.map(address => toCodec(this.root.apiRx.query.multicollateralBondingCurvePool.collateralReserves(address))) : [];

    // fill array if TBC or XST source available
    const assetsPrices = tbcUsed || xstUsed ? assetsWithAveragePrices.map(address => getAssetAveragePrice(address, this.root)) : [];

    // if TBC source available
    const assetsIssuances = tbcUsed ? [toCodec(this.root.apiRx.query.balances.totalIssuance())] : [];
    const tickersRates = xstUsed ? tickersWithOracleRates.map(symbol => toBandRate(this.root.apiRx.query.band.symbolRates(symbol))) : [];
    const tbcConsts = tbcUsed ? [fromFixnumToCodec(this.root.apiRx.query.multicollateralBondingCurvePool.initialPrice()), fromFixnumToCodec(this.root.apiRx.query.multicollateralBondingCurvePool.priceChangeStep()), fromFixnumToCodec(this.root.apiRx.query.multicollateralBondingCurvePool.priceChangeRate()), fromFixnumToCodec(this.root.apiRx.query.multicollateralBondingCurvePool.sellPriceCoefficient()), toAssetId(this.root.apiRx.query.multicollateralBondingCurvePool.referenceAssetId())] : [];
    const xstConsts = xstUsed ? [toCodec(this.root.apiRx.query.xstPool.syntheticBaseAssetFloorPrice()), toAssetId(this.root.apiRx.query.xstPool.referenceAssetId())] : [];

    // storage consts
    const bandRateStalePeriod = this.root.api.consts.band.getBandRateStalePeriod.toNumber();
    const syntheticBaseBuySellLimit = this.root.api.consts.xstPool.getSyntheticBaseBuySellLimit.toString();
    return (0, _rxjs.combineLatest)([...tickersRates, ...assetsIssuances, ...assetsPrices, ...orderBookReserves, ...tbcReserves, ...xykReserves, ...tbcConsts, ...xstConsts]).pipe((0, _rxjs.map)(data => {
      let position = tickersRates.length;
      const rates = data.slice(0, position);
      const issuances = data.slice(position, position += assetsIssuances.length);
      const prices = data.slice(position, position += assetsPrices.length);
      const orderBook = data.slice(position, position += orderBookReserves.length);
      const tbc = data.slice(position, position += tbcReserves.length);
      const xyk = data.slice(position, position += xykReserves.length);
      const [initialPrice, priceChangeStep, priceChangeRate, sellPriceCoefficient, tbcReferenceAsset] = data.slice(position, position += tbcConsts.length);
      const [floorPrice, xstReferenceAsset] = data.slice(position, position += xstConsts.length);
      const xykData = combineValuesWithKeys(xyk, assetsWithXykReserves);
      const orderBookData = combineValuesWithKeys(orderBook, assetsWithOrderBookReserves);
      const sources = (0, _liquidityProxy.getAssetsLiquiditySources)(baseAssetId, syntheticBaseAssetId, exchangePaths, enabledAssets, xykData, orderBookData);
      const payload = {
        enabledAssets,
        enabledSources,
        lockedSources,
        sources,
        rates: combineValuesWithKeys(rates, tickersWithOracleRates),
        reserves: {
          xyk: xykData,
          tbc: combineValuesWithKeys(tbc, assetsWithTbcReserves),
          orderBook: orderBookData
        },
        prices: combineValuesWithKeys(prices, assetsWithAveragePrices),
        issuances: combineValuesWithKeys(issuances, assetsWithIssuances),
        consts: {
          tbc: {
            initialPrice,
            priceChangeStep,
            priceChangeRate,
            sellPriceCoefficient,
            referenceAsset: tbcReferenceAsset
          },
          xst: {
            floorPrice,
            referenceAsset: xstReferenceAsset,
            syntheticBaseBuySellLimit
          },
          band: {
            rateStalePeriod: bandRateStalePeriod
          }
        }
      };
      return payload;
    }));
  }

  /**
   * Get observable liquidity proxy quote function for two assets
   * @param firstAssetAddress First swap token address
   * @param secondAssetAddress Second swap token address
   * @param sources Liquidity sources available for swap (all sources by default)
   * @param dexId Selected Dex Id
   */
  getSwapQuoteObservable(firstAssetAddress, secondAssetAddress) {
    var _this = this;
    let sources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    let dexId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _consts3.DexId.XOR;
    const dexReservesObservable = this.subscribeOnReserves(firstAssetAddress, secondAssetAddress, sources, dexId);
    if (!dexReservesObservable) return null;
    const swapQuoteObservable = dexReservesObservable.pipe((0, _rxjs.map)(payload => {
      const {
        assetPaths,
        liquiditySources
      } = payload.sources;
      const isAvailable = !(0, _isEmpty.default)(assetPaths) && Object.values(assetPaths).every(paths => !(0, _isEmpty.default)(paths));
      const quote = function (inputAssetAddress, outputAssetAddress, value, isExchangeB) {
        let selectedSources = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
        let deduceFee = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
        const result = _this.getResult(inputAssetAddress, outputAssetAddress, value, isExchangeB, payload, selectedSources, dexId, deduceFee);
        return {
          result,
          dexId
        };
      };
      return {
        quote,
        isAvailable,
        liquiditySources
      };
    }));
    return swapQuoteObservable;
  }

  /**
   * Get observable liquidity proxy quote function for two assets across all Dexes
   * @param firstAssetAddress First swap token address
   * @param secondAssetAddress Second swap token address
   * @param sources Liquidity sources for swap (all sources by default)
   */
  getDexesSwapQuoteObservable(firstAssetAddress, secondAssetAddress) {
    let sources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    const observables = [];
    for (const {
      dexId
    } of this.root.dex.dexList) {
      const swapQuoteDataObservable = this.getSwapQuoteObservable(firstAssetAddress, secondAssetAddress, sources, dexId);
      if (swapQuoteDataObservable) {
        observables.push(swapQuoteDataObservable);
      }
    }
    if (observables.length === 0) return null;
    if (observables.length === 1) return observables[0];
    return (0, _rxjs.combineLatest)(observables).pipe((0, _rxjs.map)(swapQuoteData => {
      const isAvailable = swapQuoteData.some(_ref3 => {
        let {
          isAvailable
        } = _ref3;
        return !!isAvailable;
      });
      const liquiditySources = [...new Set(swapQuoteData.map(_ref4 => {
        let {
          liquiditySources
        } = _ref4;
        return liquiditySources;
      }).flat(1))];
      const quote = function (inputAssetAddress, outputAssetAddress, value, isExchangeB) {
        let selectedSources = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
        let deduceFee = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
        let bestDexId = _consts3.DexId.XOR;
        const results = swapQuoteData.reduce((buffer, _ref5) => {
          let {
            quote
          } = _ref5;
          const {
            dexId,
            result
          } = quote(inputAssetAddress, outputAssetAddress, value, isExchangeB, selectedSources, deduceFee);
          return _objectSpread(_objectSpread({}, buffer), {}, {
            [dexId]: result
          });
        }, {});
        for (const currentDexId in results) {
          const currAmount = _math.FPNumber.fromCodecValue(results[currentDexId].amount);
          const bestAmount = _math.FPNumber.fromCodecValue(results[bestDexId].amount);
          if (currAmount.isZero()) continue;
          if (_math.FPNumber.isLessThan(currAmount, bestAmount) && isExchangeB || _math.FPNumber.isLessThan(bestAmount, currAmount) && !isExchangeB) {
            bestDexId = +currentDexId;
          }
        }
        return {
          dexId: bestDexId,
          result: results[bestDexId]
        };
      };
      return {
        quote,
        isAvailable,
        liquiditySources
      };
    }));
  }
  calcTxParams(assetA, assetB, amountA, amountB) {
    let slippageTolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.root.defaultSlippageTolerancePercent;
    let isExchangeB = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    let liquiditySource = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : _liquidityProxy.LiquiditySourceTypes.Default;
    let dexId = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : _consts3.DexId.XOR;
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    const desiredDecimals = (!isExchangeB ? assetA : assetB).decimals;
    const resultDecimals = (!isExchangeB ? assetB : assetA).decimals;
    const desiredCodecString = new _math.FPNumber(!isExchangeB ? amountA : amountB, desiredDecimals).toCodecString();
    const result = new _math.FPNumber(!isExchangeB ? amountB : amountA, resultDecimals);
    const resultMulSlippage = result.mul(new _math.FPNumber(Number(slippageTolerance) / 100));
    const liquiditySources = this.prepareSourcesForSwapParams(liquiditySource);
    const params = {};
    if (!isExchangeB) {
      params.WithDesiredInput = {
        desiredAmountIn: desiredCodecString,
        minAmountOut: result.sub(resultMulSlippage).toCodecString()
      };
    } else {
      params.WithDesiredOutput = {
        desiredAmountOut: desiredCodecString,
        maxAmountIn: result.add(resultMulSlippage).toCodecString()
      };
    }
    return {
      args: [dexId, assetA.address, assetB.address, params, liquiditySources, liquiditySource === _liquidityProxy.LiquiditySourceTypes.Default ? 'Disabled' : 'AllowSelected']
    };
  }

  /**
   * Run swap operation
   * @param assetA Asset A
   * @param assetB Asset B
   * @param amountA Amount A value
   * @param amountB Amount B value
   * @param slippageTolerance Slippage tolerance coefficient (in %)
   * @param isExchangeB Exchange A if `isExchangeB=false` else Exchange B. `false` by default
   * @param dexId dex id to detect base asset (XOR or XSTUSD)
   */
  execute(assetA, assetB, amountA, amountB) {
    let slippageTolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.root.defaultSlippageTolerancePercent;
    let isExchangeB = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    let liquiditySource = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : _liquidityProxy.LiquiditySourceTypes.Default;
    let dexId = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : _consts3.DexId.XOR;
    const params = this.calcTxParams(assetA, assetB, amountA, amountB, slippageTolerance, isExchangeB, liquiditySource, dexId);
    this.root.assets.addAccountAsset(assetB.address);
    return this.root.submitExtrinsic(this.root.api.tx.liquidityProxy.swap(...params.args), this.root.account.pair, {
      symbol: assetA.symbol,
      assetAddress: assetA.address,
      amount: `${amountA}`,
      symbol2: assetB.symbol,
      asset2Address: assetB.address,
      amount2: `${amountB}`,
      liquiditySource,
      type: _BaseApi.Operation.Swap
    });
  }

  /**
   * Run swap & send batch operation
   * @param receiver Receiver account address
   * @param assetA Asset A
   * @param assetB Asset B
   * @param amountA Amount A value
   * @param amountB Amount B value
   * @param slippageTolerance Slippage tolerance coefficient (in %)
   * @param isExchangeB Exchange A if `isExchangeB=false` else Exchange B. `false` by default
   * @param dexId dex id to detect base asset (XOR or XSTUSD)
   */
  executeSwapAndSend(receiver, assetA, assetB, amountA, amountB) {
    let slippageTolerance = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.root.defaultSlippageTolerancePercent;
    let isExchangeB = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    let liquiditySource = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : _liquidityProxy.LiquiditySourceTypes.Default;
    let dexId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : _consts3.DexId.XOR;
    const params = this.calcTxParams(assetA, assetB, amountA, amountB, slippageTolerance, isExchangeB, liquiditySource, dexId);
    this.root.assets.addAccountAsset(assetB.address);
    const formattedToAddress = receiver.slice(0, 2) === 'cn' ? receiver : this.root.formatAddress(receiver);
    return this.root.submitExtrinsic(this.root.api.tx.liquidityProxy.swapTransfer(receiver, ...params.args), this.root.account.pair, {
      symbol: assetA.symbol,
      assetAddress: assetA.address,
      amount: `${amountA}`,
      symbol2: assetB.symbol,
      asset2Address: assetB.address,
      amount2: `${amountB}`,
      liquiditySource,
      to: formattedToAddress,
      type: _BaseApi.Operation.SwapAndSend
    });
  }
  calcTxParamsSwapTransferBatch(asset, maxAmount) {
    let liquiditySource = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _liquidityProxy.LiquiditySourceTypes.Default;
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    const amount = _math.FPNumber.fromCodecValue(maxAmount, asset.decimals).toCodecString();
    const liquiditySources = liquiditySource ? [liquiditySource] : [];
    return {
      args: [asset.address, amount, liquiditySources, liquiditySource === _liquidityProxy.LiquiditySourceTypes.Default ? 'Disabled' : 'AllowSelected']
    };
  }

  /**
   * Run swap transfers batch operation
   * @param receivers the ordered map, which maps the asset id and dexId being bought to the vector of batch receivers
   * @param inputAsset asset being sold
   * @param maxInputAmount max amount being sold
   */
  executeSwapTransferBatch(receivers, inputAsset, maxInputAmount) {
    let liquiditySource = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _liquidityProxy.LiquiditySourceTypes.Default;
    const params = this.calcTxParamsSwapTransferBatch(inputAsset, maxInputAmount, liquiditySource);
    const recipients = receivers.reduce((acc, curr) => {
      const arr = curr.receivers.map(item => {
        return {
          accountId: item.accountId,
          amount: item.targetAmount,
          assetId: curr.outcomeAssetId
        };
      });
      acc.push(...arr);
      return acc;
    }, []);
    return this.root.submitExtrinsic(this.root.api.tx.liquidityProxy.swapTransferBatch(receivers, ...params.args), this.root.account.pair, {
      symbol: inputAsset.symbol,
      assetAddress: inputAsset.address,
      receivers: recipients,
      type: _BaseApi.Operation.SwapTransferBatch
    });
  }

  /**
   * **RPC**
   *
   * Get swap result using `liquidityProxy.quote` rpc call using predefined DEX ID.
   *
   * It's better to use `getResult` function because of the blockchain performance
   *
   * @param assetAAddress Asset A address
   * @param assetBAddress Asset B address
   * @param amount Amount value (Asset A if Exchange A, else - Asset B)
   * @param isExchangeB Exchange A if `isExchangeB=false` else Exchange B. `false` by default
   * @param liquiditySource Selected liquidity source; `''` by default
   * @param allowSelectedSorce Filter mode for source (`AllowSelected` or `ForbidSelected`); `true` by default
   * @param dexId DEX ID: might be `0` - XOR based or `1` - XSTUSD based; `0` by default
   */
  async getResultFromDexRpc(assetAAddress, assetBAddress, amount) {
    let isExchangeB = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    let liquiditySource = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _liquidityProxy.LiquiditySourceTypes.Default;
    let allowSelectedSorce = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    let dexId = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : _consts3.DexId.XOR;
    const [assetA, assetB] = await Promise.all([this.root.assets.getAssetInfo(assetAAddress), this.root.assets.getAssetInfo(assetBAddress)]);
    const toCodecString = value => new _math.FPNumber(value, (!isExchangeB ? assetB : assetA).decimals).toCodecString();
    const liquiditySources = this.prepareSourcesForSwapParams(liquiditySource);
    const filterMode = liquiditySource !== _liquidityProxy.LiquiditySourceTypes.Default ? allowSelectedSorce ? 'AllowSelected' : 'ForbidSelected' : 'Disabled';
    const result = await this.root.api.rpc.liquidityProxy.quote(dexId, assetAAddress, assetBAddress, toCodecString(amount), !isExchangeB ? 'WithDesiredInput' : 'WithDesiredOutput', liquiditySources, filterMode);
    const value = result.unwrapOr(emptySwapResult);
    return {
      amount: toCodecString(value.amount),
      fee: new _math.FPNumber(value.fee, _consts2.XOR.decimals).toCodecString(),
      rewards: 'toJSON' in value.rewards ? value.rewards.toJSON() : value.rewards,
      route: 'toJSON' in value.route ? value.route.toJSON() : value.route
    };
  }

  /**
   * **RPC**
   *
   * Get swap result using `liquidityProxy.quote` rpc call for all DEX IDs (XOR & XSTUSD based).
   *
   * It's better to use `getResult` function because of the blockchain performance
   *
   * @param assetAAddress Asset A address
   * @param assetBAddress Asset B address
   * @param amount Amount value (Asset A if Exchange A, else - Asset B)
   * @param isExchangeB Exchange A if `isExchangeB=false` else Exchange B. `false` by default
   * @param liquiditySource Selected liquidity source; `''` by default
   * @param allowSelectedSorce Filter mode for source (`AllowSelected` or `ForbidSelected`); `true` by default
   */
  async getResultRpc(assetAAddress, assetBAddress, amount) {
    let isExchangeB = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    let liquiditySource = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _liquidityProxy.LiquiditySourceTypes.Default;
    let allowSelectedSorce = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    const [assetA, assetB] = await Promise.all([this.root.assets.getAssetInfo(assetAAddress), this.root.assets.getAssetInfo(assetBAddress)]);
    const resultDecimals = (!isExchangeB ? assetB : assetA).decimals;
    const toCodecString = value => new _math.FPNumber(value, resultDecimals).toCodecString();
    const toFP = value => new _math.FPNumber(value, resultDecimals);
    const liquiditySources = this.prepareSourcesForSwapParams(liquiditySource);
    const filterMode = liquiditySource !== _liquidityProxy.LiquiditySourceTypes.Default ? allowSelectedSorce ? 'AllowSelected' : 'ForbidSelected' : 'Disabled';
    const codecAmount = toCodecString(amount);
    const swapVariant = !isExchangeB ? 'WithDesiredInput' : 'WithDesiredOutput';
    const quote = this.root.api.rpc.liquidityProxy.quote;
    const [resDex0, resDex1] = await Promise.all([quote(_consts3.DexId.XOR, assetAAddress, assetBAddress, codecAmount, swapVariant, liquiditySources, filterMode), quote(_consts3.DexId.XSTUSD, assetAAddress, assetBAddress, codecAmount, swapVariant, liquiditySources, filterMode)]);
    const valueDex0 = resDex0.unwrapOr(emptySwapResult);
    const valueDex1 = resDex1.unwrapOr(emptySwapResult);
    const isDex0Better = _math.FPNumber.gte(toFP(valueDex0.amount), toFP(valueDex1.amount));
    const value = isDex0Better ? valueDex0 : valueDex1;
    return {
      amount: toCodecString(value.amount),
      fee: new _math.FPNumber(value.fee, _consts2.XOR.decimals).toCodecString(),
      rewards: 'toJSON' in value.rewards ? value.rewards.toJSON() : value.rewards,
      route: 'toJSON' in value.route ? value.route.toJSON() : value.route,
      dexId: isDex0Better ? _consts3.DexId.XOR : _consts3.DexId.XSTUSD
    };
  }

  /**
   * **RPC**
   *
   * Subscribe on swap result using `liquidityProxy.quote` rpc call for all DEX IDs (XOR & XSTUSD based).
   *
   * @param assetAAddress Asset A address
   * @param assetBAddress Asset B address
   * @param amount Amount value (Asset A if Exchange A, else - Asset B)
   * @param isExchangeB Exchange A if `isExchangeB=false` else Exchange B. `false` by default
   * @param liquiditySource Selected liquidity source; `''` by default
   * @param allowSelectedSorce Filter mode for source (`AllowSelected` or `ForbidSelected`); `true` by default
   */
  subscribeOnResultRpc(assetAAddress, assetBAddress, amount) {
    let isExchangeB = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    let liquiditySource = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _liquidityProxy.LiquiditySourceTypes.Default;
    let allowSelectedSorce = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    return this.root.system.getBlockNumberObservable().pipe((0, _rxjs.map)(() => this.getResultRpc(assetAAddress, assetBAddress, amount, isExchangeB, liquiditySource, allowSelectedSorce)));
  }

  /**
   * **RPC**
   *
   * Check swap operation using `liquidityProxy.isPathAvailable` rpc call
   * @param firstAssetAddress
   * @param secondAssetAddress
   * @param dexId
   * @returns availability of swap operation
   */
  async checkSwap(firstAssetAddress, secondAssetAddress) {
    let dexId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _consts3.DexId.XOR;
    return (await this.root.api.rpc.liquidityProxy.isPathAvailable(dexId, firstAssetAddress, secondAssetAddress)).isTrue;
  }

  /**
   * **RPC**
   *
   * Get liquidity sources for selected pair using `tradingPair.listEnabledSourcesForPair` rpc call
   * @param firstAssetAddress
   * @param secondAssetAddress
   * @param dexId
   */
  async getEnabledLiquiditySourcesForPair(firstAssetAddress, secondAssetAddress) {
    let dexId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _consts3.DexId.XOR;
    const baseAssetId = secondAssetAddress === _consts2.XOR.address ? secondAssetAddress : firstAssetAddress;
    const targetAssetId = baseAssetId === secondAssetAddress ? firstAssetAddress : secondAssetAddress;
    const list = (await this.root.api.rpc.tradingPair.listEnabledSourcesForPair(dexId, baseAssetId, targetAssetId)).toJSON();
    return list;
  }

  /**
   * **RPC**
   *
   * Check liquidity Source availability for the selected pair using `tradingPair.isSourceEnabledForPair` rpc call
   * @param firstAssetAddress
   * @param secondAssetAddress
   * @param liquiditySource
   * @param dexId
   */
  async checkLiquiditySourceIsEnabledForPair(firstAssetAddress, secondAssetAddress, liquiditySource) {
    let dexId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _consts3.DexId.XOR;
    const isEnabled = (await this.root.api.rpc.tradingPair.isSourceEnabledForPair(dexId, firstAssetAddress, secondAssetAddress, liquiditySource)).isTrue;
    return isEnabled;
  }
}
exports.SwapModule = SwapModule;