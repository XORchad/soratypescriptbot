"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OrderBookModule = void 0;
var _rxjs = require("rxjs");
var _math = require("@sora-substrate/math");
var _BaseApi = require("../BaseApi");
var _consts = require("./consts");
var _liquidityProxy = require("@sora-substrate/liquidity-proxy");
const toAssetId = asset => asset.code.toString();
function toFP(value) {
  const decimals = value.isDivisible.isTrue ? _math.FPNumber.DEFAULT_PRECISION : 0;
  return _math.FPNumber.fromCodecValue(value.inner.toString(), decimals);
}
const getStatus = status => {
  if (status.isTrade) return _liquidityProxy.OrderBookStatus.Trade;
  if (status.isPlaceAndCancel) return _liquidityProxy.OrderBookStatus.PlaceAndCancel;
  if (status.isOnlyCancel) return _liquidityProxy.OrderBookStatus.OnlyCancel;
  return _liquidityProxy.OrderBookStatus.Stop;
};
const getPriceVariant = variant => {
  if (variant.isBuy) {
    return _liquidityProxy.PriceVariant.Buy;
  } else {
    return _liquidityProxy.PriceVariant.Sell;
  }
};
const formatOrderBookOption = option => {
  if (!option.isSome) return null;
  const {
    orderBookId,
    status,
    lastOrderId,
    tickSize,
    stepLotSize,
    minLotSize,
    maxLotSize
  } = option.unwrap();
  const dexId = orderBookId.dexId.toNumber();
  const base = toAssetId(orderBookId.base);
  const quote = toAssetId(orderBookId.quote);
  return {
    orderBookId: {
      dexId,
      base,
      quote
    },
    status: getStatus(status),
    lastOrderId: lastOrderId.toNumber(),
    tickSize: toFP(tickSize),
    stepLotSize: toFP(stepLotSize),
    minLotSize: toFP(minLotSize),
    maxLotSize: toFP(maxLotSize)
  };
};
class OrderBookModule {
  constructor(root) {
    this.root = root;
  }
  serializedKey(base, quote) {
    if (!(base && quote)) return '';
    return `${base},${quote}`;
  }
  deserializeKey(key) {
    if (!key) return null;
    const [base, quote] = key.split(',');
    return {
      base,
      quote
    };
  }

  /**
   * Get order books and set to public orderBooks object
   *
   */
  async getOrderBooks() {
    const entries = await this.root.api.query.orderBook.orderBooks.entries();
    const orderBooks = entries.reduce((buffer, _ref) => {
      let [_, value] = _ref;
      const book = formatOrderBookOption(value);
      if (!book) return buffer;
      const {
        base,
        quote
      } = book.orderBookId;
      buffer[this.serializedKey(base, quote)] = book;
      return buffer;
    }, {});
    return orderBooks;
  }

  /**
   * Get user's order book addresses and set to public userOrderBooks array
   */
  async getUserOrderBooks(account) {
    const entries = await this.root.api.query.orderBook.userLimitOrders.entries(account);
    return entries.map(_ref2 => {
      let [key, _] = _ref2;
      const {
        base,
        quote
      } = key.args[1];
      return this.serializedKey(toAssetId(base), toAssetId(quote));
    });
  }

  /**
   * Creates a subscription that relies on block emitting
   * @param account account address
   * @returns array of book addresses the user is in
   */
  subscribeOnUserOrderBooks(account) {
    return this.root.system.getBlockNumberObservable().pipe((0, _rxjs.map)(() => this.getUserOrderBooks(account)));
  }

  /**
   * Get observable order book data
   * @param orderBookId base and quote addresses
   */
  getOrderBookObservable(base, quote) {
    const dexId = this.root.dex.getDexId(quote);
    return this.root.apiRx.query.orderBook.orderBooks({
      dexId,
      base,
      quote
    }).pipe((0, _rxjs.map)(option => formatOrderBookOption(option)));
  }

  /**
   * Get mappings price to amount of asks
   *
   * Represented as **[[price, amount], [price, amount], ...]**
   * @param orderBookId base and quote addresses
   */
  subscribeOnAggregatedAsks(base, quote) {
    const dexId = this.root.dex.getDexId(quote);
    return this.root.apiRx.query.orderBook.aggregatedAsks({
      dexId,
      base,
      quote
    }).pipe((0, _rxjs.map)(data => {
      const asks = [];
      data.forEach((value, key) => {
        const price = toFP(key);
        const amount = toFP(value);
        asks.push([price, amount]);
      });
      return asks;
    }));
  }

  /**
   * Get mappings price to amount of bids
   *
   * Represented as **[[price, amount], [price, amount], ...]**
   * @param orderBookId base and quote addresses
   */
  subscribeOnAggregatedBids(base, quote) {
    const dexId = this.root.dex.getDexId(quote);
    return this.root.apiRx.query.orderBook.aggregatedBids({
      dexId,
      base,
      quote
    }).pipe((0, _rxjs.map)(data => {
      const bids = [];
      data.forEach((value, key) => {
        const price = toFP(key);
        const amount = toFP(value);
        bids.push([price, amount]);
      });
      return bids;
    }));
  }

  /**
   * Get user's limit order ids
   * @param orderBookId base and quote addresses
   * @param account account address
   */
  subscribeOnUserLimitOrdersIds(base, quote, account) {
    const dexId = this.root.dex.getDexId(quote);
    return this.root.apiRx.query.orderBook.userLimitOrders(account, {
      dexId,
      base,
      quote
    }).pipe((0, _rxjs.map)(idsCodec => idsCodec.unwrapOrDefault().toJSON()));
  }

  /**
   * Get user's limit order info
   * @param orderBookId base and quote addresses
   * @param id limit order id
   * @returns formatted limit order info
   */
  async getLimitOrder(base, quote, id) {
    const dexId = this.root.dex.getDexId(quote);
    const orderCodec = await this.root.api.query.orderBook.limitOrders({
      dexId,
      base,
      quote
    }, id);
    if (!orderCodec.isSome) return null;
    const order = orderCodec.unwrap();
    return {
      orderBookId: {
        dexId,
        base,
        quote
      },
      id: order.id.toNumber(),
      expiresAt: order.expiresAt.toNumber(),
      lifespan: order.lifespan.toNumber(),
      time: order.time.toNumber(),
      owner: order.owner.toString(),
      side: getPriceVariant(order.side),
      price: toFP(order.price),
      amount: toFP(order.amount),
      originalAmount: toFP(order.originalAmount)
    };
  }

  /**
   * Place limit order
   * @param orderBookId base and quote addresses
   * @param price order price
   * @param amount order amount
   * @param side buy or sell
   * @param timestamp order expiration
   */
  placeLimitOrder(base, quote, price, amount, side) {
    let timestamp = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _consts.MAX_TIMESTAMP;
    const dexId = this.root.dex.getDexId(quote);
    return this.root.submitExtrinsic(this.root.api.tx.orderBook.placeLimitOrder({
      dexId,
      base,
      quote
    }, price, amount, side, timestamp), this.root.account.pair, {
      type: _BaseApi.Operation.PlaceLimitOrder,
      assetAddress: base,
      asset2Address: quote,
      price,
      amount,
      side,
      limitOrderTimestamp: timestamp
    });
  }

  /**
   * Cancel one limit order by id
   * @param orderBookId base and quote addresses
   * @param orderId number
   */
  cancelLimitOrder(base, quote, orderId) {
    const dexId = this.root.dex.getDexId(quote);
    return this.root.submitExtrinsic(this.root.api.tx.orderBook.cancelLimitOrder({
      dexId,
      base,
      quote
    }, orderId), this.root.account.pair, {
      type: _BaseApi.Operation.CancelLimitOrder,
      assetAddress: base,
      asset2Address: quote,
      limitOrderIds: [orderId]
    });
  }

  /**
   * Cancel several limit orders at once
   * @param orderBookId base and quote addresses
   * @param orderIds array ids
   */
  cancelLimitOrderBatch(base, quote, orderIds) {
    const dexId = this.root.dex.getDexId(quote);
    return this.root.submitExtrinsic(this.root.api.tx.orderBook.cancelLimitOrdersBatch([[{
      dexId,
      base,
      quote
    }, orderIds]]), this.root.account.pair, {
      type: _BaseApi.Operation.CancelLimitOrders,
      assetAddress: base,
      asset2Address: quote,
      limitOrderIds: orderIds
    });
  }
}
exports.OrderBookModule = OrderBookModule;