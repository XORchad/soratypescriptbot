import { Subject } from 'rxjs';
import { NumberLike, CodecString } from '@sora-substrate/math';
import type { Observable } from '@polkadot/types/types';
import type { Subscription } from 'rxjs';
import type { Api } from '../api';
import type { AccountLiquidity } from './types';
import type { Asset, AccountAsset } from '../assets/types';
export declare class PoolXykModule<T> {
    private readonly root;
    constructor(root: Api<T>);
    /** key = `baseAssetId,targetAssetId` */
    private subscriptions;
    private subject;
    updated: Observable<void>;
    accountLiquidity: Array<AccountLiquidity>;
    accountLiquidityLoaded: Subject<void> | null;
    private addToLiquidityList;
    /**
     * Get liquidity
     * @param firstAssetAddress
     * @param secondAssetAddress
     */
    getInfoByPoolAccount(poolTokenAccount: string): Asset;
    /**
     * Get liquidity
     * @param firstAssetAddress
     * @param secondAssetAddress
     */
    getInfo(firstAssetAddress: string, secondAssetAddress: string): Asset | null;
    /**
     * Check liquidity create/add operation
     * @param firstAssetAddress
     * @param secondAssetAddress
     */
    check(firstAssetAddress: string, secondAssetAddress: string): Promise<boolean>;
    getAccountPoolBalanceObservable(firstAddress: string, secondAddress: string): Observable<string | null>;
    getTotalSupplyObservable(firstAddress: string, secondAddress: string): Observable<string | null>;
    /**
     * Get pool properties observable
     * @param firstAssetAddress
     * @param secondAssetAddress
     */
    getPoolPropertiesObservable(firstAssetAddress: string, secondAssetAddress: string): Observable<string[] | null>;
    /**
     * Get pool reserves observable
     * @param firstAssetAddress
     * @param secondAssetAddress
     */
    getReservesObservable(firstAssetAddress: string, secondAssetAddress: string): Observable<[CodecString, CodecString]>;
    /**
     * Get liquidity reserves.
     * If the output will be `['0', '0']` then the client is the first liquidity provider
     * @param firstAssetAddress
     * @param secondAssetAddress
     */
    getReserves(firstAssetAddress: string, secondAssetAddress: string): Promise<Array<CodecString>>;
    getAllReserves(): Promise<Record<string, Array<CodecString>>>;
    /**
     * Estimate tokens retrieved.
     * Also it returns the total supply as `result[2]`
     * @param firstAssetAddress
     * @param secondAssetAddress
     * @param amount
     * @param firstTotal Reserve A from `getReserves()[0]`
     * @param secondTotal Reserve B from `getReserves()[1]`
     * @param totalSupply Total issuance of pool
     * @param firstAssetDecimals If it's not set then request about asset info will be performed
     * @param secondAssetDecimals If it's not set then request about asset info will be performed
     */
    estimateTokensRetrieved(firstAssetAddress: string, secondAssetAddress: string, amount: CodecString, firstTotal: CodecString, secondTotal: CodecString, totalSupply: CodecString, firstAssetDecimals?: number, secondAssetDecimals?: number): Array<CodecString>;
    /**
     * Estimate pool tokens minted.
     * @param firstAsset First asset
     * @param secondAsset Second asset
     * @param firstAmount First asset amount
     * @param secondAmount Second asset amount
     * @param firstTotal getReserves()[0]
     * @param secondTotal getReserves()[1]
     * @param totalSupply Pool total issuance
     */
    estimatePoolTokensMinted(firstAsset: Asset, secondAsset: Asset, firstAmount: NumberLike, secondAmount: NumberLike, firstTotal: CodecString, secondTotal: CodecString, totalSupply: CodecString): Array<CodecString>;
    private subscribeOnAccountLiquidity;
    private arrangeAssetsForParams;
    private getAccountLiquidityItem;
    unsubscribeFromAccountLiquidity(liquidity: Partial<AccountLiquidity>): void;
    unsubscribeFromAllUpdates(): void;
    private removeAccountLiquidity;
    clearAccountLiquidity(): void;
    /**
     * Set subscriptions for balance updates of the account asset list
     * @param assetIdPairs
     */
    private updateAccountLiquiditySubscriptions;
    /**
     * Subscription which should be used when user is on the pool page.
     * Also, it can be used in a background - it depends on the performance.
     *
     * Do not forget to call `unsubscribe`
     */
    getUserPoolsSubscription(): Subscription;
    private calcAddTxParams;
    /**
     * Add liquidity
     * @param firstAsset
     * @param secondAsset
     * @param firstAmount
     * @param secondAmount // TODO: add a case when 'B' should be calculated automatically
     * @param slippageTolerance Slippage tolerance coefficient (in %)
     */
    add(firstAsset: Asset | AccountAsset, secondAsset: Asset | AccountAsset, firstAmount: NumberLike, secondAmount: NumberLike, slippageTolerance?: NumberLike): Promise<T>;
    private calcCreateTxParams;
    /**
     * Create token pair if user is the first liquidity provider and pair is not created.
     * Before it you should check liquidity
     * (`checkLiquidity()` -> `false`).
     *
     * Condition: Account **must** have CAN_MANAGE_DEX( DEXId ) permission,
     * XOR asset **should** be required for any pair
     * @param firstAsset
     * @param secondAsset
     * @param firstAmount
     * @param secondAmount
     * @param slippageTolerance Slippage tolerance coefficient (in %)
     */
    create(firstAsset: Asset | AccountAsset, secondAsset: Asset | AccountAsset, firstAmount: NumberLike, secondAmount: NumberLike, slippageTolerance?: NumberLike): Promise<T>;
    private calcRemoveTxParams;
    /**
     * Remove liquidity
     * @param firstAsset
     * @param secondAsset
     * @param desiredMarker
     * @param firstTotal getReserves()[0]
     * @param secondTotal getReserves()[1]
     * @param totalSupply Total supply coefficient, estimateTokensRetrieved()[2]
     * @param slippageTolerance Slippage tolerance coefficient (in %)
     */
    remove(firstAsset: Asset | AccountAsset, secondAsset: Asset | AccountAsset, desiredMarker: string, firstTotal: CodecString, secondTotal: CodecString, totalSupply: CodecString, slippageTolerance?: NumberLike): Promise<T>;
}
