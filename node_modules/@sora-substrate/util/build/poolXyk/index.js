"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PoolXykModule = void 0;
var _util = require("@polkadot/util");
var _rxjs = require("rxjs");
var _math = require("@sora-substrate/math");
var _account = require("./account");
var _consts = require("../dex/consts");
var _logger = require("../logger");
var _BaseApi = require("../BaseApi");
function serializeLPKey(liquidity) {
  if (!(liquidity.firstAddress && liquidity.secondAddress)) {
    return '';
  }
  return `${liquidity.firstAddress},${liquidity.secondAddress}`;
}
function deserializeLPKey(key) {
  const [firstAddress, secondAddress] = key.split(',');
  if (!(firstAddress && secondAddress)) {
    return null;
  }
  return {
    firstAddress,
    secondAddress
  };
}
function toReserve(value) {
  return new _math.FPNumber(value).toCodecString();
}
function parseReserves(reserves) {
  if (!reserves || reserves.length !== 2) {
    return ['0', '0'];
  }
  return [toReserve(reserves[0]), toReserve(reserves[1])];
}
class PoolXykModule {
  constructor(root) {
    this.root = root;
    this.subscriptions = new Map();
    this.subject = new _rxjs.Subject();
    this.updated = this.subject.asObservable();
    this.accountLiquidity = [];
    this.accountLiquidityLoaded = null;
  }
  /** key = `baseAssetId,targetAssetId` */

  addToLiquidityList(asset) {
    const liquidityCopy = [...this.accountLiquidity];
    const index = liquidityCopy.findIndex(item => item.address === asset.address);
    ~index ? liquidityCopy[index] = asset : liquidityCopy.push(asset);
    this.accountLiquidity = liquidityCopy;
  }

  /**
   * Get liquidity
   * @param firstAssetAddress
   * @param secondAssetAddress
   */
  getInfoByPoolAccount(poolTokenAccount) {
    return {
      address: poolTokenAccount,
      decimals: _math.FPNumber.DEFAULT_PRECISION,
      // [DECIMALS]
      name: 'Pool XYK Token',
      symbol: 'POOLXYK'
    };
  }

  /**
   * Get liquidity
   * @param firstAssetAddress
   * @param secondAssetAddress
   */
  getInfo(firstAssetAddress, secondAssetAddress) {
    const poolTokenAccount = (0, _account.poolAccountIdFromAssetPair)(this.root, firstAssetAddress, secondAssetAddress).toString();
    if (!poolTokenAccount) {
      return null;
    }
    return this.getInfoByPoolAccount(poolTokenAccount);
  }

  /**
   * Check liquidity create/add operation
   * @param firstAssetAddress
   * @param secondAssetAddress
   */
  async check(firstAssetAddress, secondAssetAddress) {
    const props = await this.root.api.query.poolXYK.properties(firstAssetAddress, secondAssetAddress);
    if (!props || !props.isSome) {
      return false;
    }
    return true;
  }
  getAccountPoolBalanceObservable(firstAddress, secondAddress) {
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    const poolAccount = (0, _account.poolAccountIdFromAssetPair)(this.root, firstAddress, secondAddress).toString();
    return this.root.apiRx.query.poolXYK.poolProviders(poolAccount, this.root.account.pair.address).pipe((0, _rxjs.map)(result => {
      if (!result || !result.isSome) return null;
      return toReserve(result.value);
    }));
  }
  getTotalSupplyObservable(firstAddress, secondAddress) {
    const poolAccount = (0, _account.poolAccountIdFromAssetPair)(this.root, firstAddress, secondAddress).toString();
    return this.root.apiRx.query.poolXYK.totalIssuances(poolAccount).pipe((0, _rxjs.map)(result => {
      if (!result || !result.isSome) return null;
      return toReserve(result.value);
    }));
  }

  /**
   * Get pool properties observable
   * @param firstAssetAddress
   * @param secondAssetAddress
   */
  getPoolPropertiesObservable(firstAssetAddress, secondAssetAddress) {
    return this.root.apiRx.query.poolXYK.properties(firstAssetAddress, secondAssetAddress).pipe((0, _rxjs.map)(result => {
      if (!result || !result.isSome) return null;
      return result.value.map(accountId => accountId.toString());
    }));
  }

  /**
   * Get pool reserves observable
   * @param firstAssetAddress
   * @param secondAssetAddress
   */
  getReservesObservable(firstAssetAddress, secondAssetAddress) {
    return this.root.apiRx.query.poolXYK.reserves(firstAssetAddress, secondAssetAddress).pipe((0, _rxjs.map)(reserves => parseReserves(reserves)));
  }

  /**
   * Get liquidity reserves.
   * If the output will be `['0', '0']` then the client is the first liquidity provider
   * @param firstAssetAddress
   * @param secondAssetAddress
   */
  async getReserves(firstAssetAddress, secondAssetAddress) {
    const reserves = await this.root.api.query.poolXYK.reserves(firstAssetAddress, secondAssetAddress);
    return parseReserves(reserves);
  }
  async getAllReserves() {
    const toKey = address => address.code.toString();
    const reserves = {};
    const baseAssetIds = this.root.dex.baseAssetsIds;
    const allReserves = (await Promise.all(baseAssetIds.map(baseAssetId => this.root.api.query.poolXYK.reserves.entries(baseAssetId)))).flat(1);
    allReserves.forEach(item => {
      var _item$;
      // [DECIMALS] Decimals = 18 here
      const [key1, key2] = item[0].args;
      if (((_item$ = item[1]) === null || _item$ === void 0 ? void 0 : _item$.length) == 2) {
        const [value1, value2] = item[1];
        reserves[toKey(key1) + toKey(key2)] = [toReserve(value1), toReserve(value2)];
      }
    });
    return reserves;
  }

  /**
   * Estimate tokens retrieved.
   * Also it returns the total supply as `result[2]`
   * @param firstAssetAddress
   * @param secondAssetAddress
   * @param amount
   * @param firstTotal Reserve A from `getReserves()[0]`
   * @param secondTotal Reserve B from `getReserves()[1]`
   * @param totalSupply Total issuance of pool
   * @param firstAssetDecimals If it's not set then request about asset info will be performed
   * @param secondAssetDecimals If it's not set then request about asset info will be performed
   */
  estimateTokensRetrieved(firstAssetAddress, secondAssetAddress, amount, firstTotal, secondTotal, totalSupply, firstAssetDecimals, secondAssetDecimals) {
    // [DECIMALS] actually, we don't need to use decimals here, so, we don't need to send these requests
    // firstAssetDecimals = firstAssetDecimals ?? (await this.getAssetInfo(firstAssetAddress)).decimals
    // secondAssetDecimals = secondAssetDecimals ?? (await this.getAssetInfo(secondAssetAddress)).decimals
    const a = _math.FPNumber.fromCodecValue(firstTotal, firstAssetDecimals);
    const b = _math.FPNumber.fromCodecValue(secondTotal, secondAssetDecimals);
    if (a.isZero() && b.isZero()) {
      return ['0', '0'];
    }
    const pIn = _math.FPNumber.fromCodecValue(amount);
    const pts = _math.FPNumber.fromCodecValue(totalSupply);
    const ptsFirstAsset = _math.FPNumber.fromCodecValue(totalSupply, firstAssetDecimals);
    const ptsSecondAsset = _math.FPNumber.fromCodecValue(totalSupply, secondAssetDecimals);
    const aOut = pIn.mul(a).div(ptsFirstAsset);
    const bOut = pIn.mul(b).div(ptsSecondAsset);
    return [aOut.toCodecString(), bOut.toCodecString(), pts.toCodecString()];
  }

  /**
   * Estimate pool tokens minted.
   * @param firstAsset First asset
   * @param secondAsset Second asset
   * @param firstAmount First asset amount
   * @param secondAmount Second asset amount
   * @param firstTotal getReserves()[0]
   * @param secondTotal getReserves()[1]
   * @param totalSupply Pool total issuance
   */
  estimatePoolTokensMinted(firstAsset, secondAsset, firstAmount, secondAmount, firstTotal, secondTotal, totalSupply) {
    const decimals = Math.max(firstAsset.decimals, secondAsset.decimals);
    const aIn = new _math.FPNumber(firstAmount, decimals);
    const bIn = new _math.FPNumber(secondAmount, decimals);
    const a = _math.FPNumber.fromCodecValue(firstTotal, decimals);
    const b = _math.FPNumber.fromCodecValue(secondTotal, decimals);
    if (a.isZero() && b.isZero()) {
      const inaccuracy = new _math.FPNumber('0.000000000000001');
      return [aIn.mul(bIn).sqrt().sub(inaccuracy).toCodecString()];
    }
    const poolToken = this.getInfo(firstAsset.address, secondAsset.address);
    const pts = _math.FPNumber.fromCodecValue(totalSupply, poolToken.decimals);
    const result = _math.FPNumber.min(aIn.mul(pts).div(a), bIn.mul(pts).div(b));
    return [result.toCodecString(), pts.toCodecString()];
  }
  async subscribeOnAccountLiquidity(liquidity) {
    if (this.subscriptions.has(serializeLPKey(liquidity))) return;
    const {
      firstAddress,
      secondAddress
    } = liquidity;
    const poolAccount = (0, _account.poolAccountIdFromAssetPair)(this.root, firstAddress, secondAddress).toString();
    const accountPoolBalanceObservable = this.getAccountPoolBalanceObservable(firstAddress, secondAddress);
    const poolReservesObservable = this.getReservesObservable(firstAddress, secondAddress);
    const poolTotalSupplyObservable = this.getTotalSupplyObservable(firstAddress, secondAddress);
    let subscription;
    let isFirstTick = true;
    const key = serializeLPKey(liquidity);
    await new Promise(resolve => {
      subscription = (0, _rxjs.combineLatest)([poolReservesObservable, accountPoolBalanceObservable, poolTotalSupplyObservable]).subscribe(_ref => {
        let [reserves, balance, supply] = _ref;
        const updatedLiquidity = this.getAccountLiquidityItem(poolAccount, firstAddress, secondAddress, reserves, balance, supply);
        // add or update liquidity only if subscription exists, or this is first subscription result
        if (updatedLiquidity && (this.subscriptions.has(key) || isFirstTick)) {
          this.addToLiquidityList(updatedLiquidity);
        } else {
          this.removeAccountLiquidity(liquidity); // Remove it from list if something was wrong
        }

        isFirstTick = false;
        this.subject.next();
        resolve();
      });
    });
    this.subscriptions.set(key, subscription);
  }
  arrangeAssetsForParams(firstAsset, secondAsset, firstAmount, secondAmount) {
    const isBaseAssetId = address => this.root.dex.baseAssetsIds.includes(address);
    const isFirstAssetSuitable = isBaseAssetId(firstAsset.address);
    const isSecondAssetSuitable = isBaseAssetId(secondAsset.address);
    (0, _util.assert)(isFirstAssetSuitable || isSecondAssetSuitable, _logger.Messages.xorOrXstIsRequired);
    let baseAsset, targetAsset, baseAssetAmount, targetAssetAmount, DEXId;
    if (isFirstAssetSuitable) {
      DEXId = this.root.dex.getDexId(firstAsset.address);
      baseAsset = firstAsset;
      targetAsset = secondAsset;
      baseAssetAmount = firstAmount;
      targetAssetAmount = secondAmount;
    } else if (isSecondAssetSuitable) {
      DEXId = this.root.dex.getDexId(secondAsset.address);
      baseAsset = secondAsset;
      targetAsset = firstAsset;
      baseAssetAmount = secondAmount;
      targetAssetAmount = firstAmount;
    }
    return [baseAsset, targetAsset, baseAssetAmount, targetAssetAmount, DEXId];
  }
  getAccountLiquidityItem(poolAccount, firstAddress, secondAddress, reserves, balance, totalSupply) {
    if (!(balance && Number(balance) && totalSupply)) return null;
    const {
      decimals,
      symbol,
      name
    } = this.getInfoByPoolAccount(poolAccount);
    // [DECIMALS] actually, we don't need to use decimals here, so, we don't need to send these requests
    // const [{ decimals: decimals1 }, { decimals: decimals2 }] = await Promise.all([
    //   this.root.assets.getAssetInfo(firstAddress),
    //   this.root.assets.getAssetInfo(secondAddress)
    // ]);
    const decimals1 = decimals;
    const decimals2 = decimals;
    const [reserveA, reserveB] = reserves;
    const [balanceA, balanceB] = this.estimateTokensRetrieved(firstAddress, secondAddress, balance, reserveA, reserveB, totalSupply, decimals1, decimals2);
    const fpBalance = _math.FPNumber.fromCodecValue(balance, decimals);
    const pts = _math.FPNumber.fromCodecValue(totalSupply, decimals);
    const poolShare = fpBalance.div(pts).mul(_math.FPNumber.HUNDRED).toString() || '0';
    return {
      address: poolAccount,
      firstAddress,
      secondAddress,
      firstBalance: balanceA,
      secondBalance: balanceB,
      symbol,
      decimals: decimals1,
      decimals2,
      balance,
      name,
      poolShare,
      reserveA,
      reserveB,
      totalSupply
    };
  }
  unsubscribeFromAccountLiquidity(liquidity) {
    var _this$subscriptions$g;
    const key = serializeLPKey(liquidity);
    (_this$subscriptions$g = this.subscriptions.get(key)) === null || _this$subscriptions$g === void 0 ? void 0 : _this$subscriptions$g.unsubscribe();
    this.subscriptions.delete(key);
  }
  unsubscribeFromAllUpdates() {
    for (const key of this.subscriptions.keys()) {
      const liquidity = deserializeLPKey(key);
      this.unsubscribeFromAccountLiquidity(liquidity);
    }
  }
  removeAccountLiquidity(liquidity) {
    this.unsubscribeFromAccountLiquidity(liquidity);
    this.accountLiquidity = this.accountLiquidity.filter(_ref2 => {
      let {
        firstAddress,
        secondAddress
      } = _ref2;
      return !(liquidity.firstAddress === firstAddress && liquidity.secondAddress === secondAddress);
    });
  }
  clearAccountLiquidity() {
    this.unsubscribeFromAllUpdates();
    this.accountLiquidity = [];
  }

  /**
   * Set subscriptions for balance updates of the account asset list
   * @param assetIdPairs
   */
  async updateAccountLiquiditySubscriptions(assetIdPairs) {
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);

    // liquidities to be subscribed
    const includedLiquidityList = assetIdPairs.map(_ref3 => {
      let [first, second] = _ref3;
      return {
        firstAddress: first,
        secondAddress: second
      };
    });
    // liquidities to be unsubscribed and removed
    const excludedLiquidityList = this.accountLiquidity.reduce((result, liquidity) => assetIdPairs.find(_ref4 => {
      let [first, second] = _ref4;
      return liquidity.firstAddress === first && liquidity.secondAddress === second;
    }) ? result : [...result, liquidity], []);
    for (const liquidity of excludedLiquidityList) {
      this.removeAccountLiquidity(liquidity);
    }
    const subscribeOnAccountLiquidityPromises = includedLiquidityList.map(liquidity => {
      return this.subscribeOnAccountLiquidity(liquidity);
    });
    await Promise.all(subscribeOnAccountLiquidityPromises);
    this.subject.next();
  }

  /**
   * Subscription which should be used when user is on the pool page.
   * Also, it can be used in a background - it depends on the performance.
   *
   * Do not forget to call `unsubscribe`
   */
  getUserPoolsSubscription() {
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    this.accountLiquidityLoaded = new _rxjs.Subject();
    const account = this.root.accountPair.address;
    const baseAssetIds = this.root.dex.baseAssetsIds;
    const multiEntries = baseAssetIds.map(baseAssetId => [account, baseAssetId]);
    return this.root.apiRx.query.poolXYK.accountPools.multi(multiEntries).subscribe(async lists => {
      const assetIdPairs = [];
      lists.forEach((list, index) => {
        const baseAssetId = baseAssetIds[index];
        list.forEach(targetAssetId => {
          const pair = [baseAssetId, targetAssetId.code.toString()];
          assetIdPairs.push(pair);
        });
      });
      await this.updateAccountLiquiditySubscriptions(assetIdPairs);
      this.accountLiquidityLoaded.next(); // Do not remove it to avoid 'no elements in sequence' error
      this.accountLiquidityLoaded.complete();
    });
  }
  calcAddTxParams(firstAsset, secondAsset, firstAmount, secondAmount) {
    let slippageTolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.root.defaultSlippageTolerancePercent;
    let DEXId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _consts.DexId.XOR;
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    const firstAmountNum = new _math.FPNumber(firstAmount, firstAsset.decimals);
    const secondAmountNum = new _math.FPNumber(secondAmount, secondAsset.decimals);
    const slippage = new _math.FPNumber(Number(slippageTolerance) / 100);
    return {
      args: [DEXId, firstAsset.address, secondAsset.address, firstAmountNum.toCodecString(), secondAmountNum.toCodecString(), firstAmountNum.sub(firstAmountNum.mul(slippage)).toCodecString(), secondAmountNum.sub(secondAmountNum.mul(slippage)).toCodecString()]
    };
  }

  /**
   * Add liquidity
   * @param firstAsset
   * @param secondAsset
   * @param firstAmount
   * @param secondAmount // TODO: add a case when 'B' should be calculated automatically
   * @param slippageTolerance Slippage tolerance coefficient (in %)
   */
  add(firstAsset, secondAsset, firstAmount, secondAmount) {
    let slippageTolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.root.defaultSlippageTolerancePercent;
    const [baseAsset, targetAsset, baseAssetAmount, targetAssetAmount, DEXId] = this.arrangeAssetsForParams(firstAsset, secondAsset, firstAmount, secondAmount);
    const params = this.calcAddTxParams(baseAsset, targetAsset, baseAssetAmount, targetAssetAmount, slippageTolerance, DEXId);
    this.root.assets.addAccountAsset(secondAsset.address);
    return this.root.submitExtrinsic(this.root.api.tx.poolXYK.depositLiquidity(...params.args), this.root.account.pair, {
      type: _BaseApi.Operation.AddLiquidity,
      symbol: firstAsset.symbol,
      assetAddress: firstAsset.address,
      symbol2: secondAsset.symbol,
      asset2Address: secondAsset.address,
      amount: `${firstAmount}`,
      amount2: `${secondAmount}`,
      decimals: firstAsset.decimals,
      decimals2: secondAsset.decimals
    });
  }
  async calcCreateTxParams(firstAsset, secondAsset, firstAmount, secondAmount) {
    let slippageTolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.root.defaultSlippageTolerancePercent;
    const [baseAsset, targetAsset, baseAssetAmount, targetAssetAmount, DEXId] = this.arrangeAssetsForParams(firstAsset, secondAsset, firstAmount, secondAmount);
    const baseAssetAllowed = this.root.dex.poolBaseAssetsIds.includes(baseAsset.address);
    (0, _util.assert)(baseAssetAllowed, _logger.Messages.pairBaseAssetNotAllowed);
    const exists = await this.check(baseAsset.address, targetAsset.address);
    (0, _util.assert)(!exists, _logger.Messages.pairAlreadyCreated);
    const params = this.calcAddTxParams(baseAsset, targetAsset, baseAssetAmount, targetAssetAmount, slippageTolerance, DEXId);
    return {
      pairCreationArgs: [DEXId, baseAsset.address, targetAsset.address],
      addLiquidityArgs: params.args,
      baseAssetAmount,
      targetAssetAmount
    };
  }

  /**
   * Create token pair if user is the first liquidity provider and pair is not created.
   * Before it you should check liquidity
   * (`checkLiquidity()` -> `false`).
   *
   * Condition: Account **must** have CAN_MANAGE_DEX( DEXId ) permission,
   * XOR asset **should** be required for any pair
   * @param firstAsset
   * @param secondAsset
   * @param firstAmount
   * @param secondAmount
   * @param slippageTolerance Slippage tolerance coefficient (in %)
   */
  async create(firstAsset, secondAsset, firstAmount, secondAmount) {
    let slippageTolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.root.defaultSlippageTolerancePercent;
    const params = await this.calcCreateTxParams(firstAsset, secondAsset, firstAmount, secondAmount, slippageTolerance);
    const [dexId, baseAddress, targetAddress] = params.pairCreationArgs;
    const isPairAlreadyCreated = (await this.root.api.rpc.tradingPair.isPairEnabled(dexId, baseAddress, targetAddress)).isTrue;
    const transactions = [];
    if (!isPairAlreadyCreated) {
      transactions.push(this.root.api.tx.tradingPair.register(...params.pairCreationArgs));
    }
    transactions.push(...[this.root.api.tx.poolXYK.initializePool(...params.pairCreationArgs), this.root.api.tx.poolXYK.depositLiquidity(...params.addLiquidityArgs)]);
    this.root.assets.addAccountAsset(secondAsset.address);
    return this.root.submitExtrinsic(this.root.api.tx.utility.batchAll(transactions), this.root.account.pair, {
      type: _BaseApi.Operation.CreatePair,
      symbol: firstAsset.symbol,
      assetAddress: firstAsset.address,
      symbol2: secondAsset.symbol,
      asset2Address: secondAsset.address,
      amount: `${params.baseAssetAmount}`,
      amount2: `${params.targetAssetAmount}`
    });
  }
  calcRemoveTxParams(firstAsset, secondAsset, desiredMarker, firstTotal, secondTotal, totalSupply) {
    let slippageTolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this.root.defaultSlippageTolerancePercent;
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    const poolToken = this.getInfo(firstAsset.address, secondAsset.address);
    const desired = new _math.FPNumber(desiredMarker, poolToken.decimals);
    const reserveA = _math.FPNumber.fromCodecValue(firstTotal, firstAsset.decimals);
    const reserveB = _math.FPNumber.fromCodecValue(secondTotal, secondAsset.decimals);
    const pts = _math.FPNumber.fromCodecValue(totalSupply, poolToken.decimals);
    const desiredA = desired.mul(reserveA).div(pts);
    const desiredB = desired.mul(reserveB).div(pts);
    const slippage = new _math.FPNumber(Number(slippageTolerance) / 100);
    const dexId = this.root.dex.getDexId(firstAsset.address);
    // The order of args is important
    return {
      args: [dexId, firstAsset.address, secondAsset.address, desired.toCodecString(), desiredA.sub(desiredA.mul(slippage)).toCodecString(), desiredB.sub(desiredB.mul(slippage)).toCodecString()],
      // amountA, amountB - without slippage (for initial history)
      amountA: desiredA.toString(),
      amountB: desiredB.toString()
    };
  }

  /**
   * Remove liquidity
   * @param firstAsset
   * @param secondAsset
   * @param desiredMarker
   * @param firstTotal getReserves()[0]
   * @param secondTotal getReserves()[1]
   * @param totalSupply Total supply coefficient, estimateTokensRetrieved()[2]
   * @param slippageTolerance Slippage tolerance coefficient (in %)
   */
  remove(firstAsset, secondAsset, desiredMarker, firstTotal, secondTotal, totalSupply) {
    let slippageTolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this.root.defaultSlippageTolerancePercent;
    const params = this.calcRemoveTxParams(firstAsset, secondAsset, desiredMarker, firstTotal, secondTotal, totalSupply, slippageTolerance);
    return this.root.submitExtrinsic(this.root.api.tx.poolXYK.withdrawLiquidity(...params.args), this.root.account.pair, {
      type: _BaseApi.Operation.RemoveLiquidity,
      symbol: firstAsset.symbol,
      assetAddress: firstAsset.address,
      symbol2: secondAsset.symbol,
      asset2Address: secondAsset.address,
      amount: params.amountA,
      amount2: params.amountB
    });
  }
}
exports.PoolXykModule = PoolXykModule;