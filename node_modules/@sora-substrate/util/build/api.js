"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.api = exports.Api = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _util = require("@polkadot/util");
var _utilCrypto = require("@polkadot/util-crypto");
var _uiKeyring = require("@polkadot/ui-keyring");
var _math = require("@sora-substrate/math");
var _crypto = require("./crypto");
var _BaseApi = require("./BaseApi");
var _logger = require("./logger");
var _bridgeProxy = require("./bridgeProxy");
var _swap = require("./swap");
var _rewards = require("./rewards");
var _poolXyk = require("./poolXyk");
var _referralSystem = require("./referralSystem");
var _assets = require("./assets");
var _orderBook = require("./orderBook");
var _mstTransfers = require("./mstTransfers");
var _system = require("./system");
var _staking = require("./staking");
var _demeterFarming = require("./demeterFarming");
var _dex = require("./dex");
var _ceresLiquidityLocker = require("./ceresLiquidityLocker");
var _consts = require("./assets/consts");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
let keyring;

/**
 * Contains all necessary data and functions for the wallet & polkaswap client
 */
class Api extends _BaseApi.BaseApi {
  constructor() {
    super(...arguments);
    this.type = _BaseApi.KeyringType;
    this.defaultSlippageTolerancePercent = 0.5;
    this.seedLength = 12;
    this.bridgeProxy = new _bridgeProxy.BridgeProxyModule(this);
    this.swap = new _swap.SwapModule(this);
    this.rewards = new _rewards.RewardsModule(this);
    this.poolXyk = new _poolXyk.PoolXykModule(this);
    this.referralSystem = new _referralSystem.ReferralSystemModule(this);
    this.assets = new _assets.AssetsModule(this);
    this.orderBook = new _orderBook.OrderBookModule(this);
    this.mstTransfers = new _mstTransfers.MstTransfersModule(this);
    this.system = new _system.SystemModule(this);
    this.staking = new _staking.StakingModule(this);
    this.demeterFarming = new _demeterFarming.DemeterFarmingModule(this);
    this.dex = new _dex.DexModule(this);
    this.ceresLiquidityLocker = new _ceresLiquidityLocker.CeresLiquidityLockerModule(this);
  }
  /** This module is used for internal needs */
  initAccountStorage() {
    super.initAccountStorage();
    this.bridgeProxy.initAccountStorage();
  }

  // # History methods
  /**
   * Remove all history
   * @param assetAddress If it's empty then all history will be removed, else - only history of the specific asset
   */
  clearHistory(assetAddress) {
    if (assetAddress) {
      const filterFn = item => !!assetAddress && ![item.assetAddress, item.asset2Address].includes(assetAddress);
      this.history = this.getFilteredHistory(filterFn);
    } else {
      super.clearHistory();
    }
  }

  /**
   * Set storage if it should be used as data storage
   * @param storage
   */
  setStorage(storage) {
    super.setStorage(storage);
    this.bridgeProxy.setStorage(storage);
  }

  // # Account management methods

  /**
   * Set signer if the pair is locked (For polkadot js extension usage)
   * @param signer
   */
  setSigner(signer) {
    super.setSigner(signer);
    this.bridgeProxy.setSigner(signer);
  }

  /**
   * Set account data
   * @param account
   */
  setAccount(account) {
    super.setAccount(account);
    this.bridgeProxy.setAccount(account);
  }
  async initKeyring() {
    let silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    keyring = new _uiKeyring.Keyring();
    await (0, _utilCrypto.cryptoWaitReady)();
    try {
      // Restore accounts from keyring storage (localStorage)
      keyring.loadAll({
        type: this.type
      });
    } catch (error) {
      // Dont throw "Unable to initialise options more than once" error in silent mode
      if (!silent) {
        throw error;
      }
    }
  }
  async restoreActiveAccount() {
    var _this$storage;
    const address = (_this$storage = this.storage) === null || _this$storage === void 0 ? void 0 : _this$storage.get('address');
    if (address) {
      var _this$storage2, _this$storage3, _this$storage4;
      const defaultAddress = this.formatAddress(address, false);
      const name = (_this$storage2 = this.storage) === null || _this$storage2 === void 0 ? void 0 : _this$storage2.get('name');
      const source = (_this$storage3 = this.storage) === null || _this$storage3 === void 0 ? void 0 : _this$storage3.get('source');
      const isExternalFlag = (_this$storage4 = this.storage) === null || _this$storage4 === void 0 ? void 0 : _this$storage4.get('isExternal');
      const isExternal = isExternalFlag ? JSON.parse(isExternalFlag) : null;
      const isExternalAccount = isExternal || isExternal === null && !!source;
      await this.loginAccount(defaultAddress, name, source, isExternalAccount);
    }
  }

  /**
   * The first method you should run. Includes initialization process
   * @param withKeyringLoading `true` by default
   */
  async initialize() {
    let withKeyringLoading = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    if (withKeyringLoading) {
      await this.initKeyring();
      await this.restoreActiveAccount();
    }

    // Update dex data
    await Promise.allSettled([this.dex.update(), this.swap.update()]);
  }

  /**
   * Before use the seed for wallet connection you may want to check its correctness
   * @param suri Seed which is set by the user
   */
  checkSeed(suri) {
    const {
      phrase
    } = (0, _utilCrypto.keyExtractSuri)(suri);
    if ((0, _util.isHex)(phrase)) {
      (0, _util.assert)((0, _util.isHex)(phrase, 256), 'Hex seed is not 256-bits');
    } else {
      (0, _util.assert)(String(phrase).split(' ').length === this.seedLength, `Mnemonic should contain ${this.seedLength} words`);
      (0, _util.assert)((0, _utilCrypto.mnemonicValidate)(phrase), 'There is no valid mnemonic seed');
    }
    return {
      address: this.createAccountPair(suri).address,
      suri
    };
  }

  /**
   * Get on-chain account's identity
   * @param address account address
   */
  async getAccountOnChainIdentity(address) {
    const data = await this.api.query.identity.identityOf(address);
    if (data.isEmpty || data.isNone) return null;
    const result = data.unwrap();
    return {
      legalName: result.info.legal.value.toHuman(),
      approved: Boolean(result.judgements.length),
      identity: result.toHuman()
    };
  }
  updateAccountData(account, name, source, isExternal) {
    this.setAccount(account);
    if (this.storage) {
      const soraAddress = this.formatAddress(account.pair.address);
      this.storage.set('address', soraAddress);
      // Optional params are just for External clients for now
      name && this.storage.set('name', name);
      source && this.storage.set('source', source);
      typeof isExternal === 'boolean' && this.storage.set('isExternal', isExternal);
    }
    this.initAccountStorage();
  }

  /**
   * Login to account
   * @param address account address
   * @param name account name
   * @param source wallet identity
   * @param isExternal is account from extension or not
   */
  async loginAccount(address, name, source, isExternal) {
    try {
      const meta = {
        name: name || ''
      };
      let account;
      if (isExternal) {
        account = keyring.addExternal(address, meta);
      } else {
        const accounts = this.getAccounts();
        if (!accounts.find(acc => acc.address === address)) {
          // [Multiple Tabs] to restore accounts from keyring storage (localStorage)
          await this.initKeyring(true);
        }
        account = {
          pair: this.getAccountPair(address),
          json: null
        };
      }
      this.updateAccountData(account, name, source, isExternal);
    } catch (error) {
      console.error(error);
      this.logout();
    }
  }

  /**
   * Import account using credentials
   * @param suri Seed of the account
   * @param name Name of the account
   * @param password Password which will be set for the account
   */
  addAccount(suri, name, password) {
    return keyring.addUri(suri, password, {
      name
    }, this.type);
  }

  /**
   * Create account pair from json
   * @param json account json
   * @param meta account meta
   */
  createAccountPairFromJson(json, meta) {
    return keyring.createFromJson(json, meta);
  }

  /**
   * Create an account pair
   * It could be added to account list using addAccountPair method
   * @param suri Seed of the account
   * @param name Name of the account
   */
  createAccountPair(suri, name) {
    const meta = {
      name: name || ''
    };
    return keyring.createFromUri(suri, meta, this.type);
  }

  /**
   * Get already imported account pair by address
   * @param address account address
   */
  getAccountPair(address) {
    const defaultAddress = this.formatAddress(address, false);
    return keyring.getPair(defaultAddress);
  }

  /**
   * Import account using account pair
   * @param pair account pair to add
   * @param password account password
   */
  addAccountPair(pair, password) {
    keyring.addPair(pair, password);
  }

  /**
   * Import account & login
   * @param suri Seed of the account
   * @param name Name of the account
   * @param password Password which will be set for the account
   */
  importAccount(suri, name, password) {
    const account = this.addAccount(suri, name, password);
    this.updateAccountData(account, name);
  }

  /**
   * Get all imported accounts.
   * It returns list of imported accounts
   * added via api.importAccount()
   */
  getAccounts() {
    return keyring.getAccounts();
  }

  /**
   * Change the account password.
   * It generates an error if `oldPassword` is invalid
   * @param oldPassword
   * @param newPassword
   */
  changeAccountPassword(oldPassword, newPassword) {
    const pair = this.accountPair;
    try {
      if (!pair.isLocked) {
        pair.lock();
      }
      pair.decodePkcs8(oldPassword);
    } catch (error) {
      throw new Error('Old password is invalid');
    }
    keyring.encryptAccount(pair, newPassword);
    if (this.storage) {
      this.storage.set('password', (0, _crypto.encrypt)(newPassword));
    }
  }

  /**
   * Change the account name
   * TODO: check it, polkadot-js extension doesn't change account name
   * @param address account address
   * @param name New name
   */
  changeAccountName(address, name) {
    const pair = this.getAccountPair(address);
    keyring.saveAccountMeta(pair, _objectSpread(_objectSpread({}, pair.meta), {}, {
      name
    }));
    if (this.storage && this.accountPair && pair.address === this.accountPair.address) {
      this.storage.set('name', name);
    }
  }

  /**
   * Restore from JSON object.
   * Adds it to keyring storage
   * It generates an error if JSON or/and password are not valid
   * @param json
   * @param password
   */
  restoreAccountFromJson(json, password) {
    const pair = keyring.restoreAccount(json, password);
    return {
      address: pair.address,
      name: (pair.meta || {}).name || ''
    };
  }

  /**
   * Export a JSON with the account data
   * @param password
   * @param encrypted If `true` then it will be decrypted. `false` by default
   */
  exportAccount(pair, password) {
    let encrypted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    const pass = encrypted ? (0, _crypto.decrypt)(password) : password;
    return JSON.stringify(keyring.backupAccount(pair, pass));
  }

  /**
   * Create seed phrase. It returns `{ address, seed }` object.
   */
  createSeed() {
    const seed = (0, _utilCrypto.mnemonicGenerate)(this.seedLength);
    return {
      address: this.createAccountPair(seed).address,
      seed
    };
  }

  // # API methods

  /**
   * Transfer amount from account
   * @param asset Asset object
   * @param toAddress Account address
   * @param amount Amount value
   */
  transfer(asset, toAddress, amount) {
    (0, _util.assert)(this.account, _logger.Messages.connectWallet);
    const assetAddress = asset.address;
    const formattedToAddress = toAddress.slice(0, 2) === 'cn' ? toAddress : this.formatAddress(toAddress);
    return this.submitExtrinsic(this.api.tx.assets.transfer(assetAddress, toAddress, new _math.FPNumber(amount, asset.decimals).toCodecString()), this.account.pair, {
      symbol: asset.symbol,
      to: formattedToAddress,
      amount: `${amount}`,
      assetAddress,
      type: _BaseApi.Operation.Transfer
    });
  }

  // # Logout & reset methods

  /**
   * Forget account from keyring
   * @param address account address to forget
   */
  forgetAccount() {
    let address = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.address;
    if (address) {
      const defaultAddress = this.formatAddress(address, false);
      keyring.forgetAccount(defaultAddress);
      keyring.forgetAddress(defaultAddress);
    }
  }

  /**
   * Remove all wallet data
   */
  logout() {
    this.assets.clearAccountAssets();
    this.poolXyk.clearAccountLiquidity();
    super.logout();
    this.bridgeProxy.logout();
  }

  // # Formatter methods
  hasEnoughXor(asset, amount, fee) {
    const xorDecimals = _consts.XOR.decimals;
    const fpFee = fee instanceof _math.FPNumber ? fee : _math.FPNumber.fromCodecValue(fee, xorDecimals);
    if (asset.address === _consts.XOR.address) {
      const fpBalance = _math.FPNumber.fromCodecValue(asset.balance.transferable, xorDecimals);
      const fpAmount = new _math.FPNumber(amount, xorDecimals);
      return _math.FPNumber.lte(fpFee, fpBalance.sub(fpAmount));
    }
    // Here we should be sure that xor value of account was tracked & updated
    const xorAccountAsset = this.assets.getAsset(_consts.XOR.address);
    if (!xorAccountAsset) {
      return false;
    }
    const xorBalance = _math.FPNumber.fromCodecValue(xorAccountAsset.balance.transferable, xorDecimals);
    return _math.FPNumber.lte(fpFee, xorBalance);
  }
  divideAssetsInternal(firstAsset, secondAsset, firstAmount, secondAmount, reversed) {
    const decimals = Math.max(firstAsset.decimals, secondAsset.decimals);
    const one = new _math.FPNumber(1, decimals);
    const firstAmountNum = new _math.FPNumber(firstAmount, decimals);
    const secondAmountNum = new _math.FPNumber(secondAmount, decimals);
    const result = !reversed ? firstAmountNum.div(!secondAmountNum.isZero() ? secondAmountNum : one) : secondAmountNum.div(!firstAmountNum.isZero() ? firstAmountNum : one);
    return result.format();
  }

  /**
   * Divide the first asset by the second
   * @param firstAsset
   * @param secondAsset
   * @param firstAmount
   * @param secondAmount
   * @param reversed If `true`: the second by the first (`false` by default)
   * @returns Formatted string
   */
  divideAssets(firstAsset, secondAsset, firstAmount, secondAmount) {
    let reversed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    return this.divideAssetsInternal(firstAsset, secondAsset, firstAmount, secondAmount, reversed);
  }

  /**
   * Divide the first asset by the second
   * @param firstAssetAddress
   * @param secondAssetAddress
   * @param firstAmount
   * @param secondAmount
   * @param reversed If `true`: the second by the first (`false` by default)
   * @returns Promise with formatted string
   */
  async divideAssetsByAssetIds(firstAssetAddress, secondAssetAddress, firstAmount, secondAmount) {
    let reversed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    const firstAsset = await this.assets.getAssetInfo(firstAssetAddress);
    const secondAsset = await this.assets.getAssetInfo(secondAssetAddress);
    return this.divideAssetsInternal(firstAsset, secondAsset, firstAmount, secondAmount, reversed);
  }
}

/** Api object */
exports.Api = Api;
const api = new Api();
exports.api = api;