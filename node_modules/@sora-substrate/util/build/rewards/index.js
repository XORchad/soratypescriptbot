"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RewardsModule = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _util = require("@polkadot/util");
var _rxjs = require("rxjs");
var _math = require("@sora-substrate/math");
var _consts = require("./consts");
var _consts2 = require("../assets/consts");
var _logger = require("../logger");
var _BaseApi = require("../BaseApi");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const getCrowdloanRewardsMap = data => {
  return data.reduce((buffer, tuple) => {
    if (!tuple.isEmpty) {
      const [assetId, amount] = tuple;
      const assetAddress = assetId.code.toString();
      const claimedAmount = new _math.FPNumber(amount);
      buffer[assetAddress] = (buffer[assetAddress] || _math.FPNumber.ZERO).add(claimedAmount);
    }
    return buffer;
  }, {});
};
class RewardsModule {
  constructor(root) {
    this.root = root;
  }
  isClaimableReward(reward) {
    const fpAmount = _math.FPNumber.fromCodecValue(reward.amount, reward.asset.decimals);
    return !fpAmount.isZero();
  }
  containsRewardsForType(items, type) {
    return items.some(item => {
      const key = 'rewards' in item ? item.rewards : [item];
      return key.some(item => this.isClaimableReward(item) && item.type[0] === type);
    });
  }
  prepareRewardInfo(type, amount, rewardAsset) {
    const asset = rewardAsset !== null && rewardAsset !== void 0 ? rewardAsset : _consts2.PSWAP;
    const fpAmount = amount instanceof _math.FPNumber ? amount : new _math.FPNumber(amount, asset === null || asset === void 0 ? void 0 : asset.decimals);
    const rewardInfo = {
      type,
      asset,
      amount: fpAmount.toCodecString()
    };
    return rewardInfo;
  }
  prepareVestedRewardsInfo(limit, total, rewards) {
    const asset = _consts2.PSWAP;
    // reward table with zero amount for each event
    const buffer = [_consts.RewardingEvents.BuyOnBondingCurve, _consts.RewardingEvents.LiquidityProvisionFarming, _consts.RewardingEvents.MarketMakerVolume].reduce((result, key) => {
      return _objectSpread(_objectSpread({}, result), {}, {
        [key]: this.prepareRewardInfo([_consts.RewardType.Strategic, key], 0, asset)
      });
    }, {});

    // update reward table with real values
    for (const [event, balance] of rewards.entries()) {
      const key = event.toString();
      buffer[key] = this.prepareRewardInfo([_consts.RewardType.Strategic, key], balance, asset);
    }
    const fpLimit = new _math.FPNumber(limit, asset.decimals);
    const fpTotal = new _math.FPNumber(total, asset.decimals);
    return {
      limit: fpLimit.toCodecString(),
      total: fpTotal.toCodecString(),
      rewards: Object.values(buffer)
    };
  }

  /**
   * Check rewards for external account
   * @param externalAddress address of external account (ethereum account address)
   * @returns rewards array with not zero amount
   */
  async checkForExternalAccount(externalAddress) {
    const [xorErc20Amount, soraFarmHarvestAmount, nftAirdropAmount] = await this.root.api.rpc.rewards.claimables(externalAddress);
    const rewards = [this.prepareRewardInfo([_consts.RewardType.External, _consts.RewardingEvents.SoraFarmHarvest], soraFarmHarvestAmount, _consts2.PSWAP), this.prepareRewardInfo([_consts.RewardType.External, _consts.RewardingEvents.NftAirdrop], nftAirdropAmount, _consts2.PSWAP), this.prepareRewardInfo([_consts.RewardType.External, _consts.RewardingEvents.XorErc20], xorErc20Amount, _consts2.VAL)].filter(item => this.isClaimableReward(item));
    return rewards;
  }

  /**
   * Get observable reward for liqudity provision
   * @returns observable liquidity provision RewardInfo
   */
  getLiquidityProvisionRewardsSubscription() {
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    return this.root.apiRx.query.pswapDistribution.shareholderAccounts(this.root.account.pair.address).pipe((0, _rxjs.map)(balance => /* FixnumFixedPoint.inner: CodecString */
    this.prepareRewardInfo([_consts.RewardType.Provision, _consts.RewardingEvents.LiquidityProvision], _math.FPNumber.fromCodecValue(balance.inner.toString()), _consts2.PSWAP)));
  }
  getVestedRewardsSubscription() {
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    return this.root.apiRx.query.vestedRewards.rewards(this.root.account.pair.address).pipe((0, _rxjs.map)(data => this.prepareVestedRewardsInfo(data.limit, data.totalAvailable, data.rewards)));
  }

  /**
   * Get all crowdloans infos
   */
  async getCrowdloans() {
    const data = await this.root.api.query.vestedRewards.crowdloanInfos.entries();
    return data.reduce((buffer, _ref) => {
      let [key, info] = _ref;
      if (!info.isEmpty) {
        const data = info.unwrap();
        buffer.push({
          totalContribution: new _math.FPNumber(data.totalContribution),
          rewards: getCrowdloanRewardsMap(data.rewards),
          startBlock: data.startBlock.toNumber(),
          length: data.length.toNumber(),
          account: data.account.toString(),
          tag: new TextDecoder().decode(key.args[0])
        });
      }
      return buffer;
    }, []);
  }

  /**
   * Get observable map of rewards user already claimed
   */
  getCrowdloanUserInfoObservable(tag) {
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    return this.root.apiRx.query.vestedRewards.crowdloanUserInfos(this.root.account.pair.address, tag).pipe((0, _rxjs.map)(result => {
      if (result.isEmpty) return {
        contribution: _math.FPNumber.ZERO,
        rewarded: {}
      };
      const data = result.unwrap();
      const contribution = new _math.FPNumber(data.contribution);
      const rewarded = getCrowdloanRewardsMap(data.rewarded);
      return {
        contribution,
        rewarded
      };
    }));
  }

  /**
   * Get observable crowdloan rewards
   */
  async getCrowdloanRewardsSubscription() {
    (0, _util.assert)(this.root.account, _logger.Messages.connectWallet);
    const blocksPerDay = 14400;
    const crowdloans = await this.getCrowdloans();
    const assetsIds = [...new Set(crowdloans.map(_ref2 => {
      let {
        rewards
      } = _ref2;
      return Object.keys(rewards);
    }).flat(1))];
    const assets = await Promise.all(assetsIds.map(assetId => this.root.assets.getAssetInfo(assetId)));
    const assetsMap = assets.reduce((buffer, asset) => _objectSpread(_objectSpread({}, buffer), {}, {
      [asset.address]: asset
    }), {});
    const userCrowdloansObservable = crowdloans.map(crowdloan => this.getCrowdloanUserInfoObservable(crowdloan.tag));
    const currentBlockObservable = this.root.system.getBlockNumberObservable();
    return (0, _rxjs.combineLatest)([currentBlockObservable, ...userCrowdloansObservable]).pipe((0, _rxjs.map)(_ref3 => {
      let [currentBlock, ...userCrowdloans] = _ref3;
      return crowdloans.reduce((buffer, crowdloan, index) => {
        const endBlock = crowdloan.startBlock + crowdloan.length;
        const elapsedBlocks = Math.max(Math.min(endBlock, currentBlock) - crowdloan.startBlock, 0);
        const userCrowdloan = userCrowdloans[index];
        const userContributionPart = crowdloan.totalContribution.isZero() ? _math.FPNumber.ZERO : userCrowdloan.contribution.div(crowdloan.totalContribution);
        const lenghtDays = Math.floor(crowdloan.length / blocksPerDay);
        const elapsedDays = Math.floor(elapsedBlocks / blocksPerDay);
        const elapsedPart = _math.FPNumber.fromNatural(elapsedDays).div(_math.FPNumber.fromNatural(lenghtDays));
        const rewards = Object.entries(crowdloan.rewards).map(_ref4 => {
          var _userCrowdloan$reward;
          let [assetId, assetTotalAmount] = _ref4;
          const asset = _objectSpread({}, assetsMap[assetId]);
          const totalAmount = assetTotalAmount.mul(userContributionPart);
          const currentAmount = totalAmount.mul(elapsedPart);
          const rewardedAmount = (_userCrowdloan$reward = userCrowdloan.rewarded[assetId]) !== null && _userCrowdloan$reward !== void 0 ? _userCrowdloan$reward : _math.FPNumber.ZERO;
          const claimableAmount = _math.FPNumber.isGreaterThanOrEqualTo(currentAmount, rewardedAmount) ? currentAmount.sub(rewardedAmount) : _math.FPNumber.ZERO;
          const rewardInfo = this.prepareRewardInfo([_consts.RewardType.Crowdloan, crowdloan.tag], claimableAmount, asset);
          return _objectSpread(_objectSpread({}, rewardInfo), {}, {
            total: totalAmount.sub(rewardedAmount).toCodecString()
          });
        });
        buffer[crowdloan.tag] = rewards;
        return buffer;
      }, {});
    }));
  }

  /**
   * Returns a params object { extrinsic, args }
   * @param rewards claiming rewards
   * @param signature message signed in external wallet (if want to claim external rewards), otherwise empty string
   */
  calcTxParams(rewards) {
    let signature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    const transactions = [];

    // liquidity provision
    if (this.containsRewardsForType(rewards, _consts.RewardType.Provision)) {
      transactions.push({
        extrinsic: this.root.api.tx.pswapDistribution.claimIncentive,
        args: []
      });
    }

    // vested
    if (this.containsRewardsForType(rewards, _consts.RewardType.Strategic)) {
      transactions.push({
        extrinsic: this.root.api.tx.vestedRewards.claimRewards,
        args: []
      });
    }

    // external
    if (this.containsRewardsForType(rewards, _consts.RewardType.External)) {
      transactions.push({
        extrinsic: this.root.api.tx.rewards.claim,
        args: [signature]
      });
    }

    // crowdloan
    const crowdloanTags = rewards.map(reward => {
      const items = 'rewards' in reward ? reward.rewards : [reward];
      const tags = items.reduce((buffer, item) => {
        const [rewardType, rewardEvent] = item.type;
        if (rewardType === _consts.RewardType.Crowdloan) {
          buffer.push(rewardEvent);
        }
        return buffer;
      }, []);
      return tags;
    }).flat(1);
    const uniqueTags = [...new Set(crowdloanTags)];
    uniqueTags.forEach(tag => {
      transactions.push({
        extrinsic: this.root.api.tx.vestedRewards.claimCrowdloanRewards,
        args: [tag]
      });
    });

    // batch or simple tx
    if (transactions.length > 1) return {
      extrinsic: this.root.api.tx.utility.batchAll,
      args: [transactions.map(_ref5 => {
        let {
          extrinsic,
          args
        } = _ref5;
        return extrinsic(...args);
      })]
    };
    if (transactions.length === 1) return transactions[0];

    // for current compability
    return {
      extrinsic: this.root.api.tx.rewards.claim,
      args: [signature]
    };
  }

  /**
   * Get network fee for claim rewards operation
   */
  async getNetworkFee(rewards) {
    let signature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    const {
      extrinsic,
      args
    } = this.calcTxParams(rewards, signature);
    switch (extrinsic) {
      case this.root.api.tx.pswapDistribution.claimIncentive:
        return this.root.NetworkFee[_BaseApi.Operation.ClaimLiquidityProvisionRewards];
      case this.root.api.tx.vestedRewards.claimRewards:
        return this.root.NetworkFee[_BaseApi.Operation.ClaimVestedRewards];
      case this.root.api.tx.vestedRewards.claimCrowdloanRewards:
        return this.root.NetworkFee[_BaseApi.Operation.ClaimCrowdloanRewards];
      case this.root.api.tx.rewards.claim:
        return this.root.NetworkFee[_BaseApi.Operation.ClaimExternalRewards];
      default:
        {
          const tx = extrinsic(...args);
          return await this.root.getTransactionFee(tx);
        }
    }
  }

  /**
   * Claim rewards
   * @param signature message signed in external wallet (if want to claim external rewards)
   */
  claim(rewards, signature, fee, externalAddress) {
    const {
      extrinsic,
      args
    } = this.calcTxParams(rewards, signature);
    const tx = extrinsic(...args);
    const historyItem = {
      type: _BaseApi.Operation.ClaimRewards,
      externalAddress,
      soraNetworkFee: fee,
      rewards
    };
    return this.root.submitExtrinsic(tx, this.root.account.pair, historyItem);
  }
}
exports.RewardsModule = RewardsModule;