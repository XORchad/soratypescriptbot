import BigNumber from 'bignumber.js';
import type { Codec } from '@polkadot/types/types';
export declare type CodecString = string;
export declare type NumberLike = number | string;
declare type NumberType = Codec | string | number | BigNumber | FPNumber;
export declare class FPNumber {
    precision: number;
    /**
     * Numbers' delimiters config
     */
    static DELIMITERS_CONFIG: {
        thousand: string;
        decimal: string;
    };
    /**
     * Default precision = `18`
     */
    static DEFAULT_PRECISION: number;
    /**
     * Default decimal places = `7`
     */
    static DEFAULT_DECIMAL_PLACES: number;
    /**
     * Default round type = `3`
     *
     * `0` Rounds away from zero
     * `1` Rounds towards zero
     * `2` Rounds towards Infinity
     * `3` Rounds towards -Infinity
     * `4` Rounds towards nearest neighbour. If equidistant, rounds away from zero
     * `5` Rounds towards nearest neighbour. If equidistant, rounds towards zero
     * `6` Rounds towards nearest neighbour. If equidistant, rounds towards even neighbour
     * `7` Rounds towards nearest neighbour. If equidistant, rounds towards Infinity
     * `8` Rounds towards nearest neighbour. If equidistant, rounds towards -Infinity
     */
    static DEFAULT_ROUND_MODE: BigNumber.RoundingMode;
    /** Zero value (0) */
    static ZERO: FPNumber;
    /** One value (1) */
    static ONE: FPNumber;
    /** Two value (2) */
    static TWO: FPNumber;
    /** Three value (3) */
    static THREE: FPNumber;
    /** Four value (4) */
    static FOUR: FPNumber;
    /** Five value (5) */
    static FIVE: FPNumber;
    /** Ten value (10) */
    static TEN: FPNumber;
    /** Hundred value (100) */
    static HUNDRED: FPNumber;
    /** Thousand value (1000) */
    static THOUSAND: FPNumber;
    /**
     * Return the **max** value, `null` if an array is empty
     * @param {...FPNumber} numbers
     */
    static max(...numbers: Array<FPNumber>): FPNumber | null;
    /**
     * Return the **min** value, `null` if an array is empty
     * @param {...FPNumber} numbers
     */
    static min(...numbers: Array<FPNumber>): FPNumber | null;
    /**
     * Return `true` if the first value is less than the second
     * @param {FPNumber} first First number
     * @param {FPNumber} second Second number
     */
    static lt(first: FPNumber, second: FPNumber): boolean;
    /**
     * Return `true` if the first value is less than the second
     * @param {FPNumber} first First number
     * @param {FPNumber} second Second number
     */
    static isLessThan: typeof FPNumber.lt;
    /**
     * Return `true` if the first value is less of equal than the second
     * @param {FPNumber} first First number
     * @param {FPNumber} second Second number
     */
    static lte(first: FPNumber, second: FPNumber): boolean;
    /**
     * Return `true` if the first value is less of equal than the second
     * @param {FPNumber} first First number
     * @param {FPNumber} second Second number
     */
    static isLessThanOrEqualTo: typeof FPNumber.lte;
    /**
     * Return `true` if the first value is greater than the second
     * @param {FPNumber} first First number
     * @param {FPNumber} second Second number
     */
    static gt(first: FPNumber, second: FPNumber): boolean;
    /**
     * Return `true` if the first value is greater than the second
     * @param {FPNumber} first First number
     * @param {FPNumber} second Second number
     */
    static isGreaterThan: typeof FPNumber.gt;
    /**
     * Return `true` if the first value is greater or equal than the second
     * @param {FPNumber} first First number
     * @param {FPNumber} second Second number
     */
    static gte(first: FPNumber, second: FPNumber): boolean;
    /**
     * Return `true` if the first value is greater or equal than the second
     * @param {FPNumber} first First number
     * @param {FPNumber} second Second number
     */
    static isGreaterThanOrEqualTo: typeof FPNumber.gte;
    /**
     * Return `true` if values are equal
     * @param {FPNumber} first First number
     * @param {FPNumber} second Second number
     */
    static eq(first: FPNumber, second: FPNumber): boolean;
    /**
     * Return `true` if values are equal
     * @param {FPNumber} first First number
     * @param {FPNumber} second Second number
     */
    static isEqualTo: typeof FPNumber.eq;
    /**
     * Get FPNumber from real number, will multiply by precision
     * @param {(string | number)} value Target number
     * @param {number} precision Precision
     */
    static fromNatural(value: number | string, precision?: number): FPNumber;
    /**
     * Get FPNumber from codec value
     * @param {(string | number)} value Codec value `(value * 10^precision)`
     * @param {number} precision Precision
     */
    static fromCodecValue(value: number | string, precision?: number): FPNumber;
    value: BigNumber;
    /**
     * Supports `data` as `string`, `number`, `BigNumber`, `FPNumber` and `Codec` data types.
     * It's better not to use `number` parameter as data if you want the strict rules for rounding
     * @param data
     * @param precision
     */
    constructor(data: NumberType, precision?: number);
    /**
     * Format number to Codec string
     */
    toCodecString(): string;
    format(dp?: number, format?: BigNumber.Format): string;
    toLocaleString(): string;
    /**
     * Format real number (divided by precision) to string
     */
    toString(): string;
    /**
     * Format real number string (divided by precision) to fixed string (like `Number.toFixed`)
     * @param {number} [dp=4] Decimal places deafult is 4
     */
    toFixed(dp?: number): string;
    /**
     * Format inner BigNumber value to string
     * @param {number} [dp=0] Decimal places deafult is 0
     */
    bnToString(dp?: number): string;
    /**
     * Format inner BigNumber value to number
     * @param {number} [dp=0] - Decimal places deafult is 0
     */
    bnToNumber(dp?: number): number;
    /**
     * Format real number (divided by precision) to number
     * @param {number} [dp=6] Decimal places
     */
    toNumber(dp?: number): number;
    /**
     * Returns a FPNumber whose value is the value of this FPNumber to a maximum of decimalPlaces decimal places.
     * @param {number} [dp=precision] Decimal places
     */
    dp(dp?: number): FPNumber;
    /**
     * Addition operator
     * @param {FPNumber} target Target number
     */
    add(target: FPNumber): FPNumber;
    /**
     * Subtraction operator
     * @param {FPNumber} target Target number
     */
    sub(target: FPNumber): FPNumber;
    /**
     * Multiplication operator
     * @param {FPNumber} target Target number
     */
    mul(target: FPNumber): FPNumber;
    /**
     * Dividion operator
     * @param {FPNumber} target Target number
     */
    div(target: FPNumber): FPNumber;
    /**
     * Mod operator TODO: Add tests
     * @param {FPNumber} target Target number
     */
    mod(target: FPNumber): FPNumber;
    /**
     * Returns `true` if mod operation returns zero.
     *
     * For instance, 4 % 2 = 0, so it returns `true` in this case.
     *
     * TODO: Add tests
     * @param {FPNumber} target Target number
     */
    isZeroMod(target: FPNumber): boolean;
    /**
     * Return the nagetive number
     */
    negative(): FPNumber;
    /**
     * Return the sqrt number
     */
    sqrt(): FPNumber;
    /**
     * Return `true` if the value of inner is NaN
     */
    isNaN(): boolean;
    /**
     * Return `true` if the value of inner is finity, only return `false` when the value is `NaN`, `-Infinity` or `Infinity`.
     */
    isFinity(): boolean;
    /**
     * Return `true` if the value is 0
     */
    isZero(): boolean;
    /**
     * Return `true` if the value is less than 0
     */
    isLtZero(): boolean;
    /**
     * Return `true` if the value is less than or equal to 0
     */
    isLteZero(): boolean;
    /**
     * Return `true` if the value is greater than 0
     */
    isGtZero(): boolean;
    /**
     * Return `true` if the value is greater than or equal to 0
     */
    isGteZero(): boolean;
    /**
     * Return the **max** value (this number or the number from params)
     * @param {Array<FPNumber>} numbers Other numbers
     */
    max(...numbers: Array<FPNumber>): FPNumber;
    /**
     * Return the **min** value (this number or the number from params)
     * @param {Array<FPNumber>} numbers Other numbers
     */
    min(...numbers: Array<FPNumber>): FPNumber;
    /**
     * Return `true` if this number is less than the number from param
     * @param {FPNumber} number Another number
     */
    lt(number: FPNumber): boolean;
    /**
     * Return `true` if this number is less than the number from param
     * @param {FPNumber} number Another number
     */
    isLessThan: (number: FPNumber) => boolean;
    /**
     * Return `true` if this number is less of equal than the number from param
     * @param {FPNumber} number Another number
     */
    lte(number: FPNumber): boolean;
    /**
     * Return `true` if this number is less of equal than the number from param
     * @param {FPNumber} number Another number
     */
    isLessThanOrEqualTo: (number: FPNumber) => boolean;
    /**
     * Return `true` if this number is greater than the number from param
     * @param {FPNumber} number Another number
     */
    gt(number: FPNumber): boolean;
    /**
     * Return `true` if this number is greater than the number from param
     * @param {FPNumber} number Another number
     */
    isGreaterThan: (number: FPNumber) => boolean;
    /**
     * Return `true` if this number is greater or equal than the number from param
     * @param {FPNumber} number Another number
     */
    gte(number: FPNumber): boolean;
    /**
     * Return `true` if this number is greater or equal than the number from param
     * @param {FPNumber} number Another number
     */
    isGreaterThanOrEqualTo: (number: FPNumber) => boolean;
    /**
     * Return `true` if values are equal
     * @param {FPNumber} number Another number
     */
    eq(number: FPNumber): boolean;
    /**
     * Return `true` if values are equal
     * @param {FPNumber} number Another number
     */
    isEqualTo: (number: FPNumber) => boolean;
}
export {};
