"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FPNumber = void 0;
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var _isNil = _interopRequireDefault(require("lodash/fp/isNil"));
_bignumber.default.config({
  FORMAT: {
    decimalSeparator: '.',
    groupSeparator: '',
    fractionGroupSeparator: ''
  }
});
const equalizedBN = (target, precision) => {
  return target.precision === precision ? target.value : target.value.times(10 ** precision).div(10 ** target.precision);
};
const checkFinityString = str => !['-Infinity', 'Infinity', 'NaN'].includes(str);
class FPNumber {
  /**
   * Numbers' delimiters config
   */

  /**
   * Default precision = `18`
   */

  /**
   * Default decimal places = `7`
   */

  /**
   * Default round type = `3`
   *
   * `0` Rounds away from zero
   * `1` Rounds towards zero
   * `2` Rounds towards Infinity
   * `3` Rounds towards -Infinity
   * `4` Rounds towards nearest neighbour. If equidistant, rounds away from zero
   * `5` Rounds towards nearest neighbour. If equidistant, rounds towards zero
   * `6` Rounds towards nearest neighbour. If equidistant, rounds towards even neighbour
   * `7` Rounds towards nearest neighbour. If equidistant, rounds towards Infinity
   * `8` Rounds towards nearest neighbour. If equidistant, rounds towards -Infinity
   */

  /** Zero value (0) */

  /** One value (1) */

  /** Two value (2) */

  /** Three value (3) */

  /** Four value (4) */

  /** Five value (5) */

  /** Ten value (10) */

  /** Hundred value (100) */

  /** Thousand value (1000) */

  /**
   * Return the **max** value, `null` if an array is empty
   * @param {...FPNumber} numbers
   */
  static max() {
    for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
      numbers[_key] = arguments[_key];
    }
    if (!numbers || !numbers.length) {
      return null;
    }
    const precision = numbers[0].precision;
    const filtered = numbers.map(item => equalizedBN(item, precision));
    return new FPNumber(_bignumber.default.max(...filtered), precision);
  }

  /**
   * Return the **min** value, `null` if an array is empty
   * @param {...FPNumber} numbers
   */
  static min() {
    for (var _len2 = arguments.length, numbers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      numbers[_key2] = arguments[_key2];
    }
    if (!(numbers !== null && numbers !== void 0 && numbers.length)) {
      return null;
    }
    const precision = numbers[0].precision;
    const filtered = numbers.map(item => equalizedBN(item, precision));
    return new FPNumber(_bignumber.default.min(...filtered), precision);
  }

  /**
   * Return `true` if the first value is less than the second
   * @param {FPNumber} first First number
   * @param {FPNumber} second Second number
   */
  static lt(first, second) {
    return first.value.lt(equalizedBN(second, first.precision));
  }

  /**
   * Return `true` if the first value is less than the second
   * @param {FPNumber} first First number
   * @param {FPNumber} second Second number
   */

  /**
   * Return `true` if the first value is less of equal than the second
   * @param {FPNumber} first First number
   * @param {FPNumber} second Second number
   */
  static lte(first, second) {
    return first.value.lte(equalizedBN(second, first.precision));
  }

  /**
   * Return `true` if the first value is less of equal than the second
   * @param {FPNumber} first First number
   * @param {FPNumber} second Second number
   */

  /**
   * Return `true` if the first value is greater than the second
   * @param {FPNumber} first First number
   * @param {FPNumber} second Second number
   */
  static gt(first, second) {
    return first.value.gt(equalizedBN(second, first.precision));
  }

  /**
   * Return `true` if the first value is greater than the second
   * @param {FPNumber} first First number
   * @param {FPNumber} second Second number
   */

  /**
   * Return `true` if the first value is greater or equal than the second
   * @param {FPNumber} first First number
   * @param {FPNumber} second Second number
   */
  static gte(first, second) {
    return first.value.gte(equalizedBN(second, first.precision));
  }

  /**
   * Return `true` if the first value is greater or equal than the second
   * @param {FPNumber} first First number
   * @param {FPNumber} second Second number
   */

  /**
   * Return `true` if values are equal
   * @param {FPNumber} first First number
   * @param {FPNumber} second Second number
   */
  static eq(first, second) {
    return first.value.eq(equalizedBN(second, first.precision));
  }

  /**
   * Return `true` if values are equal
   * @param {FPNumber} first First number
   * @param {FPNumber} second Second number
   */

  /**
   * Get FPNumber from real number, will multiply by precision
   * @param {(string | number)} value Target number
   * @param {number} precision Precision
   */
  static fromNatural(value) {
    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FPNumber.DEFAULT_PRECISION;
    return new FPNumber(value, precision);
  }

  /**
   * Get FPNumber from codec value
   * @param {(string | number)} value Codec value `(value * 10^precision)`
   * @param {number} precision Precision
   */
  static fromCodecValue(value) {
    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FPNumber.DEFAULT_PRECISION;
    const filtered = typeof value === 'string' ? value.replace(/[, ]/g, '') : value;
    return new FPNumber(new _bignumber.default(filtered), precision);
  }
  /**
   * Supports `data` as `string`, `number`, `BigNumber`, `FPNumber` and `Codec` data types.
   * It's better not to use `number` parameter as data if you want the strict rules for rounding
   * @param data
   * @param precision
   */
  constructor(data) {
    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FPNumber.DEFAULT_PRECISION;
    this.precision = precision;
    this.value = void 0;
    this.isLessThan = this.lt;
    this.isLessThanOrEqualTo = this.lte;
    this.isGreaterThan = this.gt;
    this.isGreaterThanOrEqualTo = this.gte;
    this.isEqualTo = this.eq;
    if (data instanceof _bignumber.default) {
      this.value = data;
    } else if (data instanceof FPNumber) {
      this.value = data.value;
      this.precision = data.precision;
    } else {
      const formatted = () => {
        if (typeof data === 'number') {
          return (data * 10 ** precision).toFixed();
        }
        if (typeof data === 'string') {
          if (!checkFinityString(data)) {
            return data;
          }
          const withoutFormatting = data.replace(/[, ]/g, '');
          const [integer, fractional] = withoutFormatting.split('.');
          let fractionalPart = '';
          if (fractional) {
            fractionalPart = fractional.length > precision ? fractional.substring(0, precision) : `${fractional}${Array(precision - fractional.length).fill(0).join('')}`;
          } else {
            fractionalPart = `${Array(precision).fill(0).join('')}`;
          }
          return `${integer}${fractionalPart}`;
        }
        if ('toString' in data) {
          const json = data.toJSON();
          // `BalanceInfo` or `Balance` check
          return json && !(0, _isNil.default)(json.balance) ? `${json.balance}`.replace(/[, ]/g, '') : data.toString();
        }
        return 0;
      };
      this.value = new _bignumber.default(formatted()).dp(0, FPNumber.DEFAULT_ROUND_MODE);
    }
  }

  /**
   * Format number to Codec string
   */
  toCodecString() {
    return this.value.toFormat();
  }
  format() {
    let dp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : FPNumber.DEFAULT_DECIMAL_PLACES;
    let format = arguments.length > 1 ? arguments[1] : undefined;
    const value = this.value.div(10 ** this.precision);
    if (value.isZero()) {
      return format ? value.toFormat(format) : value.toFormat();
    }
    let formatted = value.dp(dp, FPNumber.DEFAULT_ROUND_MODE);
    if (formatted.isZero()) {
      // First significant character
      formatted = new _bignumber.default(value.toFormat().replace(/(0\.0*[1-9])([0-9]*)/, '$1'));
    }
    return format ? formatted.toFormat(format) : formatted.toFormat();
  }
  toLocaleString() {
    let [integer, decimal] = this.format().split('.');
    if (integer.length > 3) {
      const integerReversed = integer.split('').reverse();
      const lastIndex = integerReversed.length - 1;
      integer = integerReversed.reduce((prev, current, index) => {
        prev += current;
        if (++index % 3 === 0 && index !== integerReversed.length) {
          // Avoid thousands' delimiter for negative numbers
          if (index === lastIndex && integerReversed[lastIndex] === '-') {
            return prev;
          }
          prev += FPNumber.DELIMITERS_CONFIG.thousand;
        }
        return prev;
      }).split('').reverse().join('');
    }
    return decimal ? integer.concat(FPNumber.DELIMITERS_CONFIG.decimal, decimal) : integer;
  }

  /**
   * Format real number (divided by precision) to string
   */
  toString() {
    const result = this.value.div(10 ** this.precision);
    return result.toFormat();
  }

  /**
   * Format real number string (divided by precision) to fixed string (like `Number.toFixed`)
   * @param {number} [dp=4] Decimal places deafult is 4
   */
  toFixed() {
    let dp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;
    const result = this.value.div(10 ** this.precision);
    return result.toFixed(dp, FPNumber.DEFAULT_ROUND_MODE);
  }

  /**
   * Format inner BigNumber value to string
   * @param {number} [dp=0] Decimal places deafult is 0
   */
  bnToString() {
    let dp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    // Return 0 if the value is Infinity, -Infinity and NaN
    if (!this.isFinity()) {
      return '0';
    }
    return this.value.dp(dp, FPNumber.DEFAULT_ROUND_MODE).toFixed();
  }

  /**
   * Format inner BigNumber value to number
   * @param {number} [dp=0] - Decimal places deafult is 0
   */
  bnToNumber() {
    let dp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    // Return 0 if the value is Infinity, -Infinity and NaN
    if (!this.isFinity()) {
      return 0;
    }
    return this.value.dp(dp, FPNumber.DEFAULT_ROUND_MODE).toNumber();
  }

  /**
   * Format real number (divided by precision) to number
   * @param {number} [dp=6] Decimal places
   */
  toNumber() {
    let dp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : FPNumber.DEFAULT_DECIMAL_PLACES;
    let result = this.value.div(10 ** this.precision);
    result = result.dp(dp, FPNumber.DEFAULT_ROUND_MODE);
    return result.toNumber();
  }

  /**
   * Returns a FPNumber whose value is the value of this FPNumber to a maximum of decimalPlaces decimal places.
   * @param {number} [dp=precision] Decimal places
   */
  dp() {
    let dp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.precision;
    return FPNumber.fromNatural(this.toNumber(dp));
  }

  /**
   * Addition operator
   * @param {FPNumber} target Target number
   */
  add(target) {
    return new FPNumber(this.value.plus(equalizedBN(target, this.precision)).dp(0, FPNumber.DEFAULT_ROUND_MODE), this.precision);
  }

  /**
   * Subtraction operator
   * @param {FPNumber} target Target number
   */
  sub(target) {
    return new FPNumber(this.value.minus(equalizedBN(target, this.precision)).dp(0, FPNumber.DEFAULT_ROUND_MODE), this.precision);
  }

  /**
   * Multiplication operator
   * @param {FPNumber} target Target number
   */
  mul(target) {
    return new FPNumber(this.value.times(equalizedBN(target, this.precision)).div(10 ** this.precision).dp(0, FPNumber.DEFAULT_ROUND_MODE), this.precision);
  }

  /**
   * Dividion operator
   * @param {FPNumber} target Target number
   */
  div(target) {
    return new FPNumber(this.value.div(equalizedBN(target, this.precision)).times(10 ** this.precision).dp(0, FPNumber.DEFAULT_ROUND_MODE), this.precision);
  }

  /**
   * Mod operator TODO: Add tests
   * @param {FPNumber} target Target number
   */
  mod(target) {
    return new FPNumber(this.value.mod(equalizedBN(target, this.precision)).dp(0, FPNumber.DEFAULT_ROUND_MODE), this.precision);
  }

  /**
   * Returns `true` if mod operation returns zero.
   *
   * For instance, 4 % 2 = 0, so it returns `true` in this case.
   *
   * TODO: Add tests
   * @param {FPNumber} target Target number
   */
  isZeroMod(target) {
    return new FPNumber(this.value.mod(equalizedBN(target, this.precision)).times(10 ** this.precision).dp(0, FPNumber.DEFAULT_ROUND_MODE), this.precision).isZero();
  }

  /**
   * Return the nagetive number
   */
  negative() {
    return new FPNumber(this.value.negated());
  }

  /**
   * Return the sqrt number
   */
  sqrt() {
    return new FPNumber(this.value.times(10 ** this.precision).sqrt().dp(0, FPNumber.DEFAULT_ROUND_MODE), this.precision);
  }

  /**
   * Return `true` if the value of inner is NaN
   */
  isNaN() {
    return this.value.isNaN();
  }

  /**
   * Return `true` if the value of inner is finity, only return `false` when the value is `NaN`, `-Infinity` or `Infinity`.
   */
  isFinity() {
    return this.value.isFinite();
  }

  /**
   * Return `true` if the value is 0
   */
  isZero() {
    return this.value.isZero();
  }

  /**
   * Return `true` if the value is less than 0
   */
  isLtZero() {
    return this.lt(FPNumber.ZERO);
  }

  /**
   * Return `true` if the value is less than or equal to 0
   */
  isLteZero() {
    return this.lte(FPNumber.ZERO);
  }

  /**
   * Return `true` if the value is greater than 0
   */
  isGtZero() {
    return this.gt(FPNumber.ZERO);
  }

  /**
   * Return `true` if the value is greater than or equal to 0
   */
  isGteZero() {
    return this.gte(FPNumber.ZERO);
  }

  /**
   * Return the **max** value (this number or the number from params)
   * @param {Array<FPNumber>} numbers Other numbers
   */
  max() {
    for (var _len3 = arguments.length, numbers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      numbers[_key3] = arguments[_key3];
    }
    return FPNumber.max(this, ...numbers);
  }

  /**
   * Return the **min** value (this number or the number from params)
   * @param {Array<FPNumber>} numbers Other numbers
   */
  min() {
    for (var _len4 = arguments.length, numbers = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      numbers[_key4] = arguments[_key4];
    }
    return FPNumber.min(this, ...numbers);
  }

  /**
   * Return `true` if this number is less than the number from param
   * @param {FPNumber} number Another number
   */
  lt(number) {
    return FPNumber.lt(this, number);
  }

  /**
   * Return `true` if this number is less than the number from param
   * @param {FPNumber} number Another number
   */

  /**
   * Return `true` if this number is less of equal than the number from param
   * @param {FPNumber} number Another number
   */
  lte(number) {
    return FPNumber.lte(this, number);
  }

  /**
   * Return `true` if this number is less of equal than the number from param
   * @param {FPNumber} number Another number
   */

  /**
   * Return `true` if this number is greater than the number from param
   * @param {FPNumber} number Another number
   */
  gt(number) {
    return FPNumber.gt(this, number);
  }

  /**
   * Return `true` if this number is greater than the number from param
   * @param {FPNumber} number Another number
   */

  /**
   * Return `true` if this number is greater or equal than the number from param
   * @param {FPNumber} number Another number
   */
  gte(number) {
    return FPNumber.gte(this, number);
  }

  /**
   * Return `true` if this number is greater or equal than the number from param
   * @param {FPNumber} number Another number
   */

  /**
   * Return `true` if values are equal
   * @param {FPNumber} number Another number
   */
  eq(number) {
    return FPNumber.eq(this, number);
  }

  /**
   * Return `true` if values are equal
   * @param {FPNumber} number Another number
   */
}
exports.FPNumber = FPNumber;
FPNumber.DELIMITERS_CONFIG = {
  thousand: ',',
  decimal: '.'
};
FPNumber.DEFAULT_PRECISION = 18;
FPNumber.DEFAULT_DECIMAL_PLACES = 7;
FPNumber.DEFAULT_ROUND_MODE = 3;
FPNumber.ZERO = FPNumber.fromNatural(0);
FPNumber.ONE = FPNumber.fromNatural(1);
FPNumber.TWO = FPNumber.fromNatural(2);
FPNumber.THREE = FPNumber.fromNatural(3);
FPNumber.FOUR = FPNumber.fromNatural(4);
FPNumber.FIVE = FPNumber.fromNatural(5);
FPNumber.TEN = FPNumber.fromNatural(10);
FPNumber.HUNDRED = FPNumber.fromNatural(100);
FPNumber.THOUSAND = FPNumber.fromNatural(1000);
FPNumber.isLessThan = FPNumber.lt;
FPNumber.isLessThanOrEqualTo = FPNumber.lte;
FPNumber.isGreaterThan = FPNumber.gt;
FPNumber.isGreaterThanOrEqualTo = FPNumber.gte;
FPNumber.isEqualTo = FPNumber.eq;