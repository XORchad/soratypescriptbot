"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connection = exports.Connection = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _api = require("@polkadot/api");
var _rpcProvider = require("@polkadot/rpc-provider");
var _api2 = require("@sora-substrate/api");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const disconnectApi = async (api, eventListeners) => {
  if (!api) return;
  eventListeners.forEach(_ref => {
    let [eventName, eventHandler] = _ref;
    return api.off(eventName, eventHandler);
  });

  // close the connection manually
  if (api.isConnected) {
    try {
      await api.disconnect();
    } catch (error) {
      console.error(error);
    }
  }
};
const createConnectionTimeout = timeout => {
  return new Promise((_, reject) => {
    setTimeout(() => reject('Connection Timeout'), timeout);
  });
};
class Connection {
  constructor(apiOptions) {
    this.apiOptions = apiOptions;
    this.api = null;
    this.endpoint = '';
    this.loading = false;
    this.eventListeners = [];
  }
  async withLoading(func) {
    this.loading = true;
    try {
      return await func();
    } catch (e) {
      throw e;
    } finally {
      this.loading = false;
    }
  }
  async run(endpoint, runOptions) {
    const {
      once = false,
      timeout = 0,
      autoConnectMs = 5000,
      eventListeners = []
    } = runOptions || {};
    const providerAutoConnectMs = once ? false : autoConnectMs;
    const apiConnectionPromise = once ? 'isReadyOrError' : 'isReady';
    const provider = new _rpcProvider.WsProvider(endpoint, providerAutoConnectMs);
    this.api = new _api.ApiPromise(_objectSpread(_objectSpread({}, this.apiOptions), {}, {
      provider,
      noInitWarn: true
    }));
    this.endpoint = endpoint;
    const connectionRequests = [this.api[apiConnectionPromise]];
    if (timeout) connectionRequests.push(createConnectionTimeout(timeout));
    try {
      eventListeners.forEach(_ref2 => {
        let [eventName, eventHandler] = _ref2;
        this.addEventListener(eventName, eventHandler);
      });

      // we should manually call connect fn without autoConnectMs
      if (!providerAutoConnectMs) {
        this.api.connect();
      }
      await Promise.race(connectionRequests);
    } catch (error) {
      this.stop();
      throw error;
    }
  }
  async stop() {
    await disconnectApi(this.api, this.eventListeners);
    this.api = null;
    this.endpoint = '';
    this.eventListeners = [];
  }
  addEventListener(eventName, eventHandler) {
    this.api.on(eventName, eventHandler);
    this.eventListeners.push([eventName, eventHandler]);
  }
  get opened() {
    return !!this.api;
  }

  /**
   * Open connection
   * @param endpoint address of node
   * @param options
   */
  async open(endpoint, options) {
    if (!(endpoint || this.endpoint)) throw new Error('You should set endpoint for connection');
    await this.withLoading(async () => await this.run(endpoint || this.endpoint, options));
  }

  /**
   * Close connection
   */
  async close() {
    await this.withLoading(async () => await this.stop());
  }
}

/**
 * Base SORA connection object
 */
exports.Connection = Connection;
const connection = new Connection((0, _api2.options)());
exports.connection = connection;