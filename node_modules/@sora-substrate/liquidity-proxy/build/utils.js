"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toFp = exports.safeQuoteResult = exports.safeDivide = exports.matchType = exports.isXorAsset = exports.isBetter = exports.isAssetAddress = exports.intersection = exports.getMaxPositive = exports.extremum = void 0;
var _math = require("@sora-substrate/math");
var _consts = require("./consts");
// UTILS
const toFp = item => _math.FPNumber.fromCodecValue(item);
exports.toFp = toFp;
const getMaxPositive = value => _math.FPNumber.max(value, _math.FPNumber.ZERO);
exports.getMaxPositive = getMaxPositive;
const isAssetAddress = (a, b) => a === b;
exports.isAssetAddress = isAssetAddress;
const isXorAsset = function (asset) {
  let dexBaseAsset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _consts.Consts.XOR;
  return isAssetAddress(asset, dexBaseAsset);
};
exports.isXorAsset = isXorAsset;
const matchType = (iType, oType) => function (a, b) {
  let bidirect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return iType === a && oType === b || bidirect && iType === b && oType === a;
};
exports.matchType = matchType;
const isBetter = (isDesiredInput, amountA, amountB) => {
  if (isDesiredInput) {
    return _math.FPNumber.isGreaterThan(amountA, amountB);
  } else {
    return amountA.isGtZero() && (amountB.isZero() || _math.FPNumber.isLessThan(amountA, amountB));
  }
};
exports.isBetter = isBetter;
const extremum = isDesiredInput => {
  if (isDesiredInput) {
    return _math.FPNumber.ZERO;
  } else {
    return _consts.Consts.MAX;
  }
};
exports.extremum = extremum;
const intersection = (a, b) => {
  return a.filter(item => b.includes(item));
};
exports.intersection = intersection;
const safeDivide = (value, divider) => {
  if (divider.isZero() || divider.isNaN()) {
    throw new Error(`[liquidityProxy] Division error: ${value.toString()} / ${divider.toString()}`);
  } else {
    return value.div(divider);
  }
};
exports.safeDivide = safeDivide;
const safeQuoteResult = (inputAsset, outputAsset, amount, market) => {
  return {
    amount: _math.FPNumber.ZERO,
    fee: _math.FPNumber.ZERO,
    rewards: [],
    distribution: [{
      input: inputAsset,
      output: outputAsset,
      market,
      income: amount,
      outcome: _math.FPNumber.ZERO,
      fee: _math.FPNumber.ZERO
    }]
  };
};
exports.safeQuoteResult = safeQuoteResult;