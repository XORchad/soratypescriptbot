"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.quote = exports.newTrivial = exports.getAssetsLiquiditySources = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _math = require("@sora-substrate/math");
var _consts = require("./consts");
var _xyk = require("./quote/xyk");
var _tbc = require("./quote/tbc");
var _xst = require("./quote/xst");
var _orderBook = require("./quote/orderBook");
var _utils = require("./utils");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * Get asset type in terms of exchange nature
 * @param baseAssetId Dex base asset id
 * @param syntheticBaseAssetId Dex synthetic base asset id
 * @param syntheticAssets collateral synthetic assets
 * @param assetId asset to determine
 */
const determine = (baseAssetId, syntheticBaseAssetId, syntheticAssets, assetId) => {
  if (assetId === baseAssetId) {
    return _consts.AssetType.Base;
  } else if (assetId === syntheticBaseAssetId) {
    return _consts.AssetType.SyntheticBase;
  } else if (syntheticAssets.includes(assetId)) {
    return _consts.AssetType.Synthetic;
  } else {
    return _consts.AssetType.Basic;
  }
};

/**
 * Get possible exchange routes between two assets
 * @param baseAssetId Dex base asset id
 * @param syntheticBaseAssetId Dex synthetic base asset id
 * @param syntheticAssets collateral synthetic assets
 * @param inputAssetId input asset id
 * @param outputAssetId output asset id
 */
const newTrivial = (baseAssetId, syntheticBaseAssetId, syntheticAssets, inputAssetId, outputAssetId) => {
  const iType = determine(baseAssetId, syntheticBaseAssetId, syntheticAssets, inputAssetId);
  const oType = determine(baseAssetId, syntheticBaseAssetId, syntheticAssets, outputAssetId);
  if ((0, _utils.matchType)(iType, oType)(_consts.AssetType.Base, _consts.AssetType.Basic, true) || (0, _utils.matchType)(iType, oType)(_consts.AssetType.Base, _consts.AssetType.SyntheticBase, true)) {
    return [
    // F.E: XOR-VAL; VAL-XOR; XOR-XST; XST-XOR;
    [inputAssetId, outputAssetId]];
  } else if ((0, _utils.matchType)(iType, oType)(_consts.AssetType.SyntheticBase, _consts.AssetType.Synthetic, true)) {
    return [
    // F.E: XST-XSTUSD; XSTUSD-XST;
    [inputAssetId, outputAssetId],
    // F.E: XST-XOR-XSTUSD; XSTUSD-XOR-XST;
    [inputAssetId, baseAssetId, outputAssetId]];
  } else if ((0, _utils.matchType)(iType, oType)(_consts.AssetType.Basic, _consts.AssetType.Basic) || (0, _utils.matchType)(iType, oType)(_consts.AssetType.Basic, _consts.AssetType.SyntheticBase, true)) {
    return [
    // F.E: VAL-XOR-PSWAP; VAL-XOR-XST; XST-XOR-VAL;
    [inputAssetId, baseAssetId, outputAssetId]];
  } else if ((0, _utils.matchType)(iType, oType)(_consts.AssetType.Synthetic, _consts.AssetType.Synthetic)) {
    return [
    // F.E: XSTUSD-XST-XSTGPB;
    [inputAssetId, syntheticBaseAssetId, outputAssetId],
    // F.E: XSTUSD-XOR-XSTGPB;
    [inputAssetId, baseAssetId, outputAssetId]];
  } else if ((0, _utils.matchType)(iType, oType)(_consts.AssetType.Base, _consts.AssetType.Synthetic, true)) {
    return [
    // F.E: XOR-XSTUSD; XSTUSD-XOR;
    [inputAssetId, outputAssetId],
    // F.E: XOR-XST-XSTUSD; XSTUSD-XST-XOR;
    [inputAssetId, syntheticBaseAssetId, outputAssetId]];
  } else if ((0, _utils.matchType)(iType, oType)(_consts.AssetType.Basic, _consts.AssetType.Synthetic)) {
    return [
    // F.E: VAL-XOR-XST-XSTUSD;
    [inputAssetId, baseAssetId, syntheticBaseAssetId, outputAssetId],
    // F.E: VAL-XOR-XSTUSD;
    [inputAssetId, baseAssetId, outputAssetId]];
  } else if ((0, _utils.matchType)(iType, oType)(_consts.AssetType.Synthetic, _consts.AssetType.Basic)) {
    return [
    // F.E: XSTUSD-XST-XOR-VAL;
    [inputAssetId, syntheticBaseAssetId, baseAssetId, outputAssetId],
    // F.E: XSTUSD-XOR-VAL;
    [inputAssetId, baseAssetId, outputAssetId]];
  }
  return [];
};

/**
 * Get available list of liquidity sources for the selected asset
 * @param address Asset ID
 * @param payload Quote payload
 * @param enabledAssets Primary markets enabled assets
 * @param baseAssetId Dex base asset id
 * @param syntheticBaseAssetId Dex synthetic base asset id
 */
exports.newTrivial = newTrivial;
const getAssetLiquiditySources = (baseAssetId, syntheticBaseAssetId, address, enabledAssets, xykReserves, orderBookReserves) => {
  const rules = {
    [_consts.LiquiditySourceTypes.MulticollateralBondingCurvePool]: () => baseAssetId === _consts.Consts.XOR && [...enabledAssets.tbc, _consts.Consts.XOR].includes(address),
    [_consts.LiquiditySourceTypes.XYKPool]: () => baseAssetId === address || Array.isArray(xykReserves[address]) && xykReserves[address].every(tokenReserve => !!Number(tokenReserve)),
    [_consts.LiquiditySourceTypes.XSTPool]: () => baseAssetId === _consts.Consts.XOR && (address === syntheticBaseAssetId || !!enabledAssets.xst[address]),
    [_consts.LiquiditySourceTypes.OrderBook]: () => baseAssetId === _consts.Consts.XOR && !!orderBookReserves[address]
  };
  return Object.entries(rules).reduce((acc, _ref) => {
    let [source, rule] = _ref;
    if (rule()) {
      acc.push(source);
    }
    return acc;
  }, []);
};

/**
 * Liquidity sources for direct exchange between two asssets
 * @param inputAssetId input asset id
 * @param outputAssetId output asset id
 * @param assetPaths liquidity sources for assets
 * @param baseAssetId Dex base asset id
 */
const listLiquiditySources = function (inputAssetId, outputAssetId, assetPaths, baseAssetId) {
  let selectedSources = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  const getSource = asset => {
    var _assetPaths$asset;
    return (_assetPaths$asset = assetPaths[asset]) !== null && _assetPaths$asset !== void 0 ? _assetPaths$asset : [];
  };
  const commonSources = (0, _utils.intersection)(getSource(inputAssetId), getSource(outputAssetId));
  const directSources = commonSources.filter(source => {
    return source === _consts.LiquiditySourceTypes.XSTPool || [inputAssetId, outputAssetId].includes(baseAssetId) // TBC, XYK, OrderBook uses baseAsset
    ;
  });

  if (!selectedSources.length) return directSources;
  return directSources.filter(source => selectedSources.includes(source));
};

/**
 * Get available liquidity sources for the tokens & exchange pair\
 * @param inputAssetId Input asset address
 * @param outputAssetId Output asset address
 * @param enabledAssets List of enabled assets
 * @param xykReserves Xyk reserves of assets in exchange paths
 * @param baseAssetId Dex base asset id
 * @param syntheticBaseAssetId Dex synthetic base asset id
 */
const getAssetsLiquiditySources = (baseAssetId, syntheticBaseAssetId, exchangePaths, enabledAssets, xykReserves, orderBookReserves) => {
  const assetPaths = {};
  let liquiditySources = [];
  for (const exchangePath of exchangePaths) {
    let exchangePathSources = [];
    exchangePath.forEach((asset, index) => {
      const assetSources = assetPaths[asset] = assetPaths[asset] || getAssetLiquiditySources(baseAssetId, syntheticBaseAssetId, asset, enabledAssets, xykReserves, orderBookReserves);
      exchangePathSources = index === 0 ? assetSources : (0, _utils.intersection)(exchangePathSources, assetSources);
    });
    liquiditySources = [...new Set([...liquiditySources, ...exchangePathSources])];
  }
  return {
    assetPaths,
    liquiditySources
  };
};

// AGGREGATOR
exports.getAssetsLiquiditySources = getAssetsLiquiditySources;
const quotePrimaryMarket = (inputAssetAddress, outputAssetAddress, amount, isDesiredInput, payload, deduceFee) => {
  if ([inputAssetAddress, outputAssetAddress].includes(_consts.Consts.XSTUSD)) {
    return (0, _xst.xstQuote)(inputAssetAddress, outputAssetAddress, amount, isDesiredInput, payload, deduceFee);
  } else {
    return (0, _tbc.tbcQuote)(inputAssetAddress, outputAssetAddress, amount, isDesiredInput, payload, deduceFee);
  }
};

/**
 * Determines the share of a swap that should be exchanged in the primary market
 * (i.e., the multi-collateral bonding curve pool) based on the current reserves of
 * the base asset and the collateral asset in the secondary market (e.g., an XYK pool)
 * provided the base asset is being bought.
 */
const primaryMarketAmountBuyingBaseAsset = (collateralAsset, amount, isDesiredInput, baseReserve, otherReserve, payload) => {
  try {
    const secondaryPrice = baseReserve.isGtZero() ? (0, _utils.safeDivide)(otherReserve, baseReserve) : _consts.Consts.MAX;
    const primaryBuyPrice = (0, _utils.isAssetAddress)(collateralAsset, _consts.Consts.XSTUSD) ? (0, _xst.xstBuyPriceNoVolume)(collateralAsset, payload) : (0, _tbc.tbcBuyPriceNoVolume)(collateralAsset, payload);
    const k = baseReserve.mul(otherReserve);
    if (isDesiredInput) {
      if (_math.FPNumber.isLessThan(secondaryPrice, primaryBuyPrice)) {
        const amountSecondary = k.mul(primaryBuyPrice).sqrt().sub(otherReserve);
        if (_math.FPNumber.isGreaterThanOrEqualTo(amountSecondary, amount)) {
          return _math.FPNumber.ZERO;
        } else if (amountSecondary.isLteZero()) {
          return amount;
        } else {
          return amount.sub(amountSecondary);
        }
      } else {
        return amount;
      }
    } else {
      if (_math.FPNumber.isLessThan(secondaryPrice, primaryBuyPrice)) {
        const amountSecondary = baseReserve.sub((0, _utils.safeDivide)(k, primaryBuyPrice).sqrt());
        if (_math.FPNumber.isGreaterThanOrEqualTo(amountSecondary, amount)) {
          return _math.FPNumber.ZERO;
        } else if (amountSecondary.isLteZero()) {
          return amount;
        } else {
          return amount.sub(amountSecondary);
        }
      } else {
        return amount;
      }
    }
  } catch (error) {
    return _math.FPNumber.ZERO;
  }
};

/**
 * Determines the share of a swap that should be exchanged in the primary market
 * (i.e. the multi-collateral bonding curve pool) based on the current reserves of
 * the base asset and the collateral asset in the secondary market (e.g. an XYK pool)
 * provided the base asset is being sold.
 */
const primaryMarketAmountSellingBaseAsset = (collateralAsset, amount, isDesiredInput, xorReserve, otherReserve, payload) => {
  try {
    const secondaryPrice = xorReserve.isGtZero() ? (0, _utils.safeDivide)(otherReserve, xorReserve) : _math.FPNumber.ZERO;
    const primarySellPrice = (0, _utils.isAssetAddress)(collateralAsset, _consts.Consts.XSTUSD) ? (0, _xst.xstSellPriceNoVolume)(collateralAsset, payload) : (0, _tbc.tbcSellPriceNoVolume)(collateralAsset, payload);
    const k = xorReserve.mul(otherReserve);
    if (isDesiredInput) {
      if (_math.FPNumber.isGreaterThan(secondaryPrice, primarySellPrice)) {
        const amountSecondary = (0, _utils.safeDivide)(k, primarySellPrice).sqrt().sub(xorReserve);
        if (_math.FPNumber.isGreaterThan(amountSecondary, amount)) {
          return _math.FPNumber.ZERO;
        } else if (amountSecondary.isLteZero()) {
          return amount;
        } else {
          return amount.sub(amountSecondary);
        }
      } else {
        return amount;
      }
    } else {
      if (_math.FPNumber.isGreaterThan(secondaryPrice, primarySellPrice)) {
        const amountSecondary = otherReserve.sub(k.mul(primarySellPrice).sqrt());
        if (_math.FPNumber.isGreaterThanOrEqualTo(amountSecondary, amount)) {
          return _math.FPNumber.ZERO;
        } else if (amountSecondary.isLteZero()) {
          return amount;
        } else {
          return amount.sub(amountSecondary);
        }
      } else {
        return amount;
      }
    }
  } catch (error) {
    return _math.FPNumber.ZERO;
  }
};

/**
 * Implements the "smart" split algorithm.
 */
const smartSplit = function (inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee) {
  let baseAssetId = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : _consts.Consts.XOR;
  let bestOutcome = (0, _utils.extremum)(isDesiredInput);
  let bestFee = _math.FPNumber.ZERO;
  let bestDistribution = [];
  let bestRewards = [];
  const isBaseAssetInput = (0, _utils.isAssetAddress)(inputAsset, baseAssetId);
  const [inputReserves, outputReserves] = (0, _xyk.getXykReserves)(inputAsset, outputAsset, payload, baseAssetId);
  const [baseReserve, otherReserve] = isBaseAssetInput ? [inputReserves, outputReserves] : [outputReserves, inputReserves];
  const primaryAmount = isBaseAssetInput ? primaryMarketAmountSellingBaseAsset(outputAsset, amount, isDesiredInput, baseReserve, otherReserve, payload) : primaryMarketAmountBuyingBaseAsset(inputAsset, amount, isDesiredInput, baseReserve, otherReserve, payload);
  if (primaryAmount.isGtZero()) {
    const outcomePrimary = quotePrimaryMarket(inputAsset, outputAsset, primaryAmount, isDesiredInput, payload, deduceFee);
    // check that outcomePrimary is not zero
    if (_math.FPNumber.isLessThan(primaryAmount, amount) && !outcomePrimary.amount.isZero()) {
      const incomeSecondary = amount.sub(primaryAmount);
      const outcomeSecondary = (0, _xyk.xykQuote)(inputAsset, outputAsset, incomeSecondary, isDesiredInput, payload, deduceFee, baseAssetId);
      bestOutcome = outcomePrimary.amount.add(outcomeSecondary.amount);
      bestFee = outcomePrimary.fee.add(outcomeSecondary.fee);
      bestRewards = [...outcomePrimary.rewards, ...outcomeSecondary.rewards];
      bestDistribution = [...outcomeSecondary.distribution, ...outcomePrimary.distribution];
    } else {
      bestOutcome = outcomePrimary.amount;
      bestFee = outcomePrimary.fee;
      bestRewards = outcomePrimary.rewards;
      bestDistribution = outcomePrimary.distribution;
    }
  }

  // check xyk only result regardless of split, because it might be better
  const outcomeSecondary = (0, _xyk.xykQuote)(inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee, baseAssetId);
  if ((0, _utils.isBetter)(isDesiredInput, outcomeSecondary.amount, bestOutcome)) {
    bestOutcome = outcomeSecondary.amount;
    bestFee = outcomeSecondary.fee;
    bestRewards = outcomeSecondary.rewards;
    bestDistribution = outcomeSecondary.distribution;
  }
  if (_math.FPNumber.isEqualTo(bestOutcome, _consts.Consts.MAX)) {
    bestOutcome = _math.FPNumber.ZERO;
    bestFee = _math.FPNumber.ZERO;
    bestRewards = [];
  }
  return {
    amount: bestOutcome,
    fee: bestFee,
    rewards: bestRewards,
    distribution: bestDistribution
  };
};

/**
 * Computes the optimal distribution across available liquidity sources to exectute the requested trade
 * given the input and output assets, the trade amount and a liquidity sources filter.
 */
const quoteSingle = function (inputAsset, outputAsset, amount, isDesiredInput, selectedSources, payload, deduceFee) {
  let baseAssetId = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : _consts.Consts.XOR;
  const allSources = listLiquiditySources(inputAsset, outputAsset, payload.sources.assetPaths, baseAssetId, selectedSources);
  let sources = allSources.filter(source => !payload.lockedSources.includes(source));
  if (!sources.length) {
    throw new Error(`[liquidityProxy] Path doesn't exist: [${inputAsset}, ${outputAsset}]`);
  }

  // The temp solution is to exclude OrderBook source if there are multiple sources.
  // Will be removed in ALT implementation
  if (sources.length > 1) {
    sources = sources.filter(source => source !== _consts.LiquiditySourceTypes.OrderBook);
  }
  if (sources.length === 1) {
    switch (sources[0]) {
      case _consts.LiquiditySourceTypes.XYKPool:
        {
          return (0, _xyk.xykQuote)(inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee, baseAssetId);
        }
      case _consts.LiquiditySourceTypes.MulticollateralBondingCurvePool:
        {
          return (0, _tbc.tbcQuote)(inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee);
        }
      case _consts.LiquiditySourceTypes.XSTPool:
        {
          return (0, _xst.xstQuote)(inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee);
        }
      case _consts.LiquiditySourceTypes.OrderBook:
        {
          return (0, _orderBook.orderBookQuote)(baseAssetId, inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee);
        }
      default:
        {
          throw new Error(`[liquidityProxy] Unexpected liquidity source: ${sources[0]}`);
        }
    }
  }
  if (sources.length === 2) {
    if (sources.includes(_consts.LiquiditySourceTypes.XYKPool) &&
    // We can't use XST as primary market for smart split, because it use XST asset as base
    sources.includes(_consts.LiquiditySourceTypes.MulticollateralBondingCurvePool)) {
      return smartSplit(inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee, baseAssetId);
    }
  }
  throw new Error('[liquidityProxy] Unsupported operation');
};
const quote = function (firstAssetAddress, secondAssetAddress, amount, isDesiredInput, selectedSources, payload, deduceFee) {
  let baseAssetId = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : _consts.Consts.XOR;
  let syntheticBaseAssetId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : _consts.Consts.XST;
  let bestQuote = {
    amount: _math.FPNumber.ZERO,
    amountWithoutImpact: _math.FPNumber.ZERO,
    fee: _math.FPNumber.ZERO,
    rewards: [],
    route: [],
    distribution: []
  };

  // directed exchange paths
  const exchangePaths = newTrivial(baseAssetId, syntheticBaseAssetId, Object.keys(payload.enabledAssets.xst), firstAssetAddress, secondAssetAddress);
  const results = exchangePaths.map(exchangePath => {
    // if isDesiredInput = false, we compute the swaps from output asset to input asset
    const directedPath = isDesiredInput ? exchangePath : exchangePath.slice().reverse();
    try {
      const result = directedPath.reduce((buffer, currentAsset) => {
        if (buffer.amount.isZero()) {
          throw new Error('[liquidityProxy]: zero amount received while processing exchange path');
        }
        const {
          route
        } = buffer;
        if (route.length) {
          const prevAsset = route[route.length - 1];
          const [assetA, assetB] = isDesiredInput ? [prevAsset, currentAsset] : [currentAsset, prevAsset];
          const result = quoteSingle(assetA, assetB, buffer.amount, isDesiredInput, selectedSources, payload, deduceFee, baseAssetId);
          const ratioToActual = buffer.amount.isZero() || buffer.amountWithoutImpact.isZero() ? _math.FPNumber.ONE : (0, _utils.safeDivide)(buffer.amountWithoutImpact, buffer.amount);

          // multiply all amounts in distribution to adjust prev quote without impact:
          const distributionAmounts = result.distribution.map(_ref2 => {
            let {
              market,
              income,
              outcome
            } = _ref2;
            return {
              market,
              amount: (isDesiredInput ? income : outcome).mul(ratioToActual)
            };
          });
          const amountWithoutImpact = quoteWithoutImpactSingle(assetA, assetB, isDesiredInput, distributionAmounts, payload, deduceFee, baseAssetId);
          buffer.amount = result.amount;
          buffer.amountWithoutImpact = amountWithoutImpact;
          buffer.fee = buffer.fee.add(result.fee);
          buffer.rewards.push(...result.rewards);
          if (isDesiredInput) {
            buffer.distribution.push(result.distribution);
          } else {
            buffer.distribution.unshift(result.distribution);
          }
        }
        buffer.route.push(currentAsset);
        return buffer;
      }, {
        amount,
        amountWithoutImpact: _math.FPNumber.ZERO,
        fee: _math.FPNumber.ZERO,
        rewards: [],
        route: [],
        distribution: []
      });
      return _objectSpread(_objectSpread({}, result), {}, {
        // return real exchange route
        route: exchangePath
      });
    } catch (error) {
      return _objectSpread(_objectSpread({}, bestQuote), {}, {
        // return real exchange route
        route: exchangePath
      });
    }
  });
  for (const result of results) {
    const currentAmount = result.amount;
    const bestAmount = bestQuote.amount;
    if (currentAmount.isZero()) continue;
    if (_math.FPNumber.isLessThan(bestAmount, currentAmount) && isDesiredInput || _math.FPNumber.isLessThan(currentAmount, bestAmount) && !isDesiredInput || bestAmount.isZero()) {
      bestQuote = result;
    }
  }
  return {
    amount: bestQuote.amount.toCodecString(),
    amountWithoutImpact: bestQuote.amountWithoutImpact.toCodecString(),
    fee: bestQuote.fee.toCodecString(),
    rewards: bestQuote.rewards,
    route: bestQuote.route,
    distribution: bestQuote.distribution
  };
};
exports.quote = quote;
const quoteWithoutImpactSingle = function (inputAsset, outputAsset, isDesiredInput, distribution, payload, deduceFee) {
  let baseAssetId = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : _consts.Consts.XOR;
  return distribution.reduce((result, _ref3) => {
    let {
      market,
      amount
    } = _ref3;
    let value = _math.FPNumber.ZERO;
    if (market === _consts.LiquiditySourceTypes.XYKPool) {
      value = (0, _xyk.xykQuoteWithoutImpact)(inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee, baseAssetId);
    } else if (market === _consts.LiquiditySourceTypes.MulticollateralBondingCurvePool) {
      value = (0, _tbc.tbcQuoteWithoutImpact)(inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee);
    } else if (market === _consts.LiquiditySourceTypes.XSTPool) {
      value = (0, _xst.xstQuoteWithoutImpact)(inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee);
    } else if (market === _consts.LiquiditySourceTypes.OrderBook) {
      value = (0, _orderBook.orderBookQuoteWithoutImpact)(baseAssetId, inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee);
    }
    return result.add(value);
  }, _math.FPNumber.ZERO);
};