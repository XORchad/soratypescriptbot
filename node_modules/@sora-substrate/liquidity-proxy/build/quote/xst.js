"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.xstSellPriceNoVolume = exports.xstQuoteWithoutImpact = exports.xstQuote = exports.xstBuyPriceNoVolume = void 0;
var _math = require("@sora-substrate/math");
var _consts = require("../consts");
var _utils = require("../utils");
var _price = require("./price");
var _oracleProxy = require("./oracleProxy");
const ensureBaseAssetAmountWithinLimit = function (amount, payload) {
  let checkLimits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (!checkLimits) return;
  const limit = _math.FPNumber.fromCodecValue(payload.consts.xst.syntheticBaseBuySellLimit);
  if (_math.FPNumber.isGreaterThan(amount, limit)) {
    throw new Error('Input/output amount of synthetic base asset exceeds the limit');
  }
};
const getAggregatedFee = (syntheticAssetId, payload) => {
  var _rate$dynamicFee;
  const asset = payload.enabledAssets.xst[syntheticAssetId];
  if (!asset) throw new Error(`Synthetic asset "${syntheticAssetId}" does not exist`);
  const {
    feeRatio,
    referenceSymbol
  } = asset;
  const rate = (0, _oracleProxy.oracleProxyQuoteUnchecked)(referenceSymbol, payload);
  const dynamicFeeRatio = _math.FPNumber.fromCodecValue((_rate$dynamicFee = rate === null || rate === void 0 ? void 0 : rate.dynamicFee) !== null && _rate$dynamicFee !== void 0 ? _rate$dynamicFee : '0');
  const resultingFeeRatio = feeRatio.add(dynamicFeeRatio);
  if (!_math.FPNumber.isLessThan(resultingFeeRatio, _math.FPNumber.ONE)) throw new Error('Invalid fee ratio value');
  return resultingFeeRatio;
};

// Used for converting XST fee to XOR
const convertFee = (feeAmount, payload) => {
  const outputToBase = (0, _price.getAveragePrice)(_consts.Consts.XST, _consts.Consts.XOR,
  // Since `Buy` is more expensive in case if we are buying XOR
  // (x XST -> y XOR; y XOR -> x' XST, x' < x),
  // it seems logical to show this amount in order
  // to not accidentally lie about the price.
  _consts.PriceVariant.Buy, payload);
  const fee = feeAmount.mul(outputToBase);
  return fee;
};
const xstReferencePrice = (assetAddress, priceVariant, payload) => {
  const referenceAssetId = payload.consts.xst.referenceAsset;
  const syntheticBaseAssetId = _consts.Consts.XST;

  // XSTUSD is a special case because it is equal to the reference asset, DAI
  if ([referenceAssetId, _consts.Consts.XSTUSD].includes(assetAddress)) {
    return _math.FPNumber.ONE;
  } else if ((0, _utils.isAssetAddress)(assetAddress, syntheticBaseAssetId)) {
    const averagePrice = (0, _price.getAveragePrice)(assetAddress, referenceAssetId, priceVariant, payload);
    const floorPrice = _math.FPNumber.fromCodecValue(payload.consts.xst.floorPrice);
    return _math.FPNumber.max(averagePrice, floorPrice);
  } else {
    const symbol = payload.enabledAssets.xst[assetAddress].referenceSymbol;
    const rate = (0, _oracleProxy.oracleProxyQuoteUnchecked)(symbol, payload);
    const price = _math.FPNumber.fromCodecValue(rate.value);
    return price;
  }
};

/**
 * Buys the main asset (e.g., XST).
 * Calculates and returns the current buy price, assuming that input is the synthetic asset and output is the main asset.
 */
const xstBuyPrice = (syntheticAsset, amount, isDesiredInput, payload) => {
  const mainAssetPrice = xstReferencePrice(_consts.Consts.XST, _consts.PriceVariant.Buy, payload);
  const syntheticAssetPrice = xstReferencePrice(syntheticAsset, _consts.PriceVariant.Sell, payload);
  if (isDesiredInput) {
    // Input target amount of synthetic asset (e.g. XSTUSD) to get some synthetic base asset (e.g. XST)
    return (0, _utils.safeDivide)(amount.mul(syntheticAssetPrice), mainAssetPrice);
  } else {
    // Input some synthetic asset (e.g. XSTUSD) to get a target amount of synthetic base asset (e.g. XST)
    return (0, _utils.safeDivide)(amount.mul(mainAssetPrice), syntheticAssetPrice);
  }
};
const xstSellPrice = (syntheticAsset, amount, isDesiredInput, payload) => {
  const mainAssetPrice = xstReferencePrice(_consts.Consts.XST, _consts.PriceVariant.Sell, payload);
  const syntheticAssetPrice = xstReferencePrice(syntheticAsset, _consts.PriceVariant.Buy, payload);
  if (isDesiredInput) {
    // Sell desired amount of synthetic base asset (e.g. XST) for some synthetic asset (e.g. XSTUSD)
    return (0, _utils.safeDivide)(amount.mul(mainAssetPrice), syntheticAssetPrice);
  } else {
    // Sell some amount of synthetic base asset (e.g. XST) for desired amount of synthetic asset (e.g. XSTUSD)
    return (0, _utils.safeDivide)(amount.mul(syntheticAssetPrice), mainAssetPrice);
  }
};
// decide_buy_amounts
const xstBuyPriceWithFee = function (syntheticAsset, amount, isDesiredInput, payload, deduceFee) {
  let checkLimits = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  if (!_math.FPNumber.isGreaterThan(amount, _math.FPNumber.ZERO)) throw new Error('Price calculation failed');
  const feeRatio = deduceFee ? getAggregatedFee(syntheticAsset, payload) : _math.FPNumber.ZERO;
  if (isDesiredInput) {
    const outputAmount = xstBuyPrice(syntheticAsset, amount, isDesiredInput, payload);
    const feeAmount = feeRatio.mul(outputAmount);
    const output = outputAmount.sub(feeAmount);
    ensureBaseAssetAmountWithinLimit(output, payload, checkLimits);
    const fee = convertFee(feeAmount, payload); // in XOR

    return {
      amount: output,
      fee,
      rewards: [],
      distribution: [{
        input: syntheticAsset,
        output: _consts.Consts.XST,
        market: _consts.LiquiditySourceTypes.XSTPool,
        income: amount,
        outcome: output,
        fee
      }]
    };
  } else {
    ensureBaseAssetAmountWithinLimit(amount, payload, checkLimits);
    const amountWithFee = (0, _utils.safeDivide)(amount, _math.FPNumber.ONE.sub(feeRatio));
    const feeAmount = amountWithFee.sub(amount);
    const input = xstBuyPrice(syntheticAsset, amountWithFee, isDesiredInput, payload);
    const fee = convertFee(feeAmount, payload); // in XOR

    return {
      amount: input,
      fee,
      rewards: [],
      distribution: [{
        input: syntheticAsset,
        output: _consts.Consts.XST,
        market: _consts.LiquiditySourceTypes.XSTPool,
        income: input,
        outcome: amount,
        fee
      }]
    };
  }
};
// decide_sell_amounts
const xstSellPriceWithFee = function (syntheticAsset, amount, isDesiredInput, payload, deduceFee) {
  let checkLimits = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  if (!_math.FPNumber.isGreaterThan(amount, _math.FPNumber.ZERO)) throw new Error('Price calculation failed');
  const feeRatio = deduceFee ? getAggregatedFee(syntheticAsset, payload) : _math.FPNumber.ZERO;
  if (isDesiredInput) {
    ensureBaseAssetAmountWithinLimit(amount, payload, checkLimits);
    const feeAmount = amount.mul(feeRatio);
    const output = xstSellPrice(syntheticAsset, amount.sub(feeAmount), isDesiredInput, payload);
    const fee = convertFee(feeAmount, payload); // in XOR

    return {
      amount: output,
      fee,
      rewards: [],
      distribution: [{
        input: _consts.Consts.XST,
        output: syntheticAsset,
        market: _consts.LiquiditySourceTypes.XSTPool,
        income: amount,
        outcome: output,
        fee
      }]
    };
  } else {
    const inputAmount = xstSellPrice(syntheticAsset, amount, isDesiredInput, payload);
    const inputAmountWithFee = (0, _utils.safeDivide)(inputAmount, _math.FPNumber.ONE.sub(feeRatio));
    ensureBaseAssetAmountWithinLimit(inputAmountWithFee, payload, checkLimits);
    const feeAmount = inputAmountWithFee.sub(inputAmount);
    const fee = convertFee(feeAmount, payload); // in XOR

    return {
      amount: inputAmountWithFee,
      fee,
      rewards: [],
      distribution: [{
        input: _consts.Consts.XST,
        output: syntheticAsset,
        market: _consts.LiquiditySourceTypes.XSTPool,
        income: inputAmountWithFee,
        outcome: amount,
        fee
      }]
    };
  }
};
const xstBuyPriceNoVolume = (syntheticAsset, payload) => {
  const basePriceWrtRef = xstReferencePrice(_consts.Consts.XST, _consts.PriceVariant.Buy, payload);
  const syntheticPricePerReferenceUnit = xstReferencePrice(syntheticAsset, _consts.PriceVariant.Sell, payload);
  return (0, _utils.safeDivide)(basePriceWrtRef, syntheticPricePerReferenceUnit);
};
exports.xstBuyPriceNoVolume = xstBuyPriceNoVolume;
const xstSellPriceNoVolume = (syntheticAsset, payload) => {
  const basePriceWrtRef = xstReferencePrice(_consts.Consts.XST, _consts.PriceVariant.Sell, payload);
  const syntheticPricePerReferenceUnit = xstReferencePrice(syntheticAsset, _consts.PriceVariant.Buy, payload);
  return (0, _utils.safeDivide)(basePriceWrtRef, syntheticPricePerReferenceUnit);
};
exports.xstSellPriceNoVolume = xstSellPriceNoVolume;
const xstQuoteWithoutImpact = (inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee) => {
  try {
    // no impact already
    const quoteResult = xstQuote(inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee, false);
    return quoteResult.amount;
  } catch (error) {
    return _math.FPNumber.ZERO;
  }
};
exports.xstQuoteWithoutImpact = xstQuoteWithoutImpact;
const xstQuote = function (inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee) {
  let checkLimits = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;
  try {
    return (0, _utils.isAssetAddress)(inputAsset, _consts.Consts.XST) ? xstSellPriceWithFee(outputAsset, amount, isDesiredInput, payload, deduceFee, checkLimits) : xstBuyPriceWithFee(inputAsset, amount, isDesiredInput, payload, deduceFee, checkLimits);
  } catch (error) {
    return (0, _utils.safeQuoteResult)(inputAsset, outputAsset, amount, _consts.LiquiditySourceTypes.XSTPool);
  }
};
exports.xstQuote = xstQuote;