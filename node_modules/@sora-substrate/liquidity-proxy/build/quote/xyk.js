"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.xykQuoteWithoutImpact = exports.xykQuote = exports.getXykReserves = void 0;
var _math = require("@sora-substrate/math");
var _consts = require("../consts");
var _utils = require("../utils");
// returs reserves by order: inputAssetId, outputAssetId
const getXykReserves = function (inputAsset, outputAsset, payload) {
  let baseAssetId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _consts.Consts.XOR;
  const isBaseAssetInput = (0, _utils.isAssetAddress)(inputAsset, baseAssetId);
  const nonBaseAsset = isBaseAssetInput ? outputAsset : inputAsset;
  const reserves = [...payload.reserves.xyk[nonBaseAsset]];
  const [input, output] = isBaseAssetInput ? reserves : reserves.reverse();
  return [(0, _utils.toFp)(input), (0, _utils.toFp)(output)];
};

/**
 * Input token is dex base asset (xor), user indicates desired input amount
 * @param x - base asset reserve
 * @param y - other token reserve
 * @param xIn x_in - desired input amount (base asset)
 * @returns QuoteResult
 */
exports.getXykReserves = getXykReserves;
const xykQuoteA = (input, output, x, y, xIn, deduceFee) => {
  const feeRatio = deduceFee ? _consts.Consts.XYK_FEE : _math.FPNumber.ZERO;
  const fee = xIn.mul(feeRatio);
  const x1 = xIn.sub(fee);
  const yOut = (0, _utils.safeDivide)(x1.mul(y), x.add(x1));
  return {
    amount: yOut,
    fee,
    rewards: [],
    distribution: [{
      input,
      output,
      market: _consts.LiquiditySourceTypes.XYKPool,
      income: xIn,
      outcome: yOut,
      fee
    }]
  };
};

/**
 * Output token is dex base asset, user indicates desired input amount
 * @param x - other token reserve
 * @param y - base asset reserve
 * @param xIn - desired input amount (other token)
 * @returns QuoteResult
 */
const xykQuoteB = (input, output, x, y, xIn, deduceFee) => {
  const feeRatio = deduceFee ? _consts.Consts.XYK_FEE : _math.FPNumber.ZERO;
  const y1 = (0, _utils.safeDivide)(xIn.mul(y), x.add(xIn));
  const yOut = y1.mul(_math.FPNumber.ONE.sub(feeRatio));
  const fee = y1.sub(yOut);
  return {
    amount: yOut,
    fee,
    rewards: [],
    distribution: [{
      input,
      output,
      market: _consts.LiquiditySourceTypes.XYKPool,
      income: xIn,
      outcome: yOut,
      fee
    }]
  };
};

/**
 * Input token is dex base asset, user indicates desired output amount
 * @param x - base asset reserve
 * @param y - other token reserve
 * @param yOut - desired output amount (other token)
 * @returns QuoteResult
 */
const xykQuoteC = (input, output, x, y, yOut, deduceFee) => {
  if (_math.FPNumber.isGreaterThanOrEqualTo(yOut, y)) {
    throw new Error(`[liquidityProxy] xykQuote: output amount ${yOut.toString()} is larger than reserves ${y.toString()}. `);
  }
  const feeRatio = deduceFee ? _consts.Consts.XYK_FEE : _math.FPNumber.ZERO;
  const x1 = (0, _utils.safeDivide)(x.mul(yOut), y.sub(yOut));
  const xIn = (0, _utils.safeDivide)(x1, _math.FPNumber.ONE.sub(feeRatio));
  const fee = xIn.sub(x1);
  return {
    amount: xIn,
    fee,
    rewards: [],
    distribution: [{
      input,
      output,
      market: _consts.LiquiditySourceTypes.XYKPool,
      income: xIn,
      outcome: yOut,
      fee
    }]
  };
};

/**
 * Output token is dex base asset, user indicates desired output amount
 * @param x - other token reserve
 * @param y - base asset reserve
 * @param yOut - desired output amount (base asset)
 * @returns QuoteResult
 */
const xykQuoteD = (input, output, x, y, yOut, deduceFee) => {
  const feeRatio = deduceFee ? _consts.Consts.XYK_FEE : _math.FPNumber.ZERO;
  const y1 = (0, _utils.safeDivide)(yOut, _math.FPNumber.ONE.sub(feeRatio));
  if (_math.FPNumber.isGreaterThanOrEqualTo(y1, y)) {
    throw new Error(`[liquidityProxy] xykQuote: output amount ${y1.toString()} is larger than reserves ${y.toString()}.`);
  }
  const xIn = (0, _utils.safeDivide)(x.mul(y1), y.sub(y1));
  const fee = y1.sub(yOut);
  return {
    amount: xIn,
    fee,
    rewards: [],
    distribution: [{
      input,
      output,
      market: _consts.LiquiditySourceTypes.XYKPool,
      income: xIn,
      outcome: yOut,
      fee
    }]
  };
};
const xykQuote = (inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee, baseAssetId) => {
  try {
    const [inputReserves, outputReserves] = getXykReserves(inputAsset, outputAsset, payload, baseAssetId);
    const isBaseAssetInput = (0, _utils.isAssetAddress)(inputAsset, baseAssetId);
    if (isDesiredInput) {
      if (isBaseAssetInput) {
        return xykQuoteA(inputAsset, outputAsset, inputReserves, outputReserves, amount, deduceFee);
      } else {
        return xykQuoteB(inputAsset, outputAsset, inputReserves, outputReserves, amount, deduceFee);
      }
    } else {
      if (isBaseAssetInput) {
        return xykQuoteC(inputAsset, outputAsset, inputReserves, outputReserves, amount, deduceFee);
      } else {
        return xykQuoteD(inputAsset, outputAsset, inputReserves, outputReserves, amount, deduceFee);
      }
    }
  } catch (error) {
    return (0, _utils.safeQuoteResult)(inputAsset, outputAsset, amount, _consts.LiquiditySourceTypes.XYKPool);
  }
};
exports.xykQuote = xykQuote;
const xykQuoteWithoutImpact = (inputAsset, outputAsset, amount, isDesiredInput, payload, deduceFee, baseAssetId) => {
  try {
    const [inputReserves, outputReserves] = getXykReserves(inputAsset, outputAsset, payload, baseAssetId);
    const isBaseAssetInput = (0, _utils.isAssetAddress)(inputAsset, baseAssetId);
    const feeRatio = deduceFee ? _consts.Consts.XYK_FEE : _math.FPNumber.ZERO;
    if (isDesiredInput) {
      if (isBaseAssetInput) {
        const amountWithoutFee = amount.mul(_math.FPNumber.ONE.sub(feeRatio));
        return (0, _utils.safeDivide)(amountWithoutFee.mul(outputReserves), inputReserves);
      } else {
        const amountWithFee = (0, _utils.safeDivide)(amount.mul(outputReserves), inputReserves);
        return amountWithFee.mul(_math.FPNumber.ONE.sub(feeRatio));
      }
    } else {
      if (isBaseAssetInput) {
        const amountWithoutFee = (0, _utils.safeDivide)(amount.mul(inputReserves), outputReserves);
        return (0, _utils.safeDivide)(amountWithoutFee, _math.FPNumber.ONE.sub(feeRatio));
      } else {
        const amountWithFee = (0, _utils.safeDivide)(amount, _math.FPNumber.ONE.sub(feeRatio));
        return (0, _utils.safeDivide)(amountWithFee.mul(inputReserves), outputReserves);
      }
    }
  } catch (error) {
    return _math.FPNumber.ZERO;
  }
};
exports.xykQuoteWithoutImpact = xykQuoteWithoutImpact;