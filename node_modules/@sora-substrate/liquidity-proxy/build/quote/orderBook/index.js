"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.orderBookQuoteWithoutImpact = exports.orderBookQuote = exports.orderBookCanExchange = void 0;
var _math = require("@sora-substrate/math");
var _utils = require("../../utils");
var _consts = require("../../consts");
var _consts2 = require("./consts");
var OrderAmountType;
(function (OrderAmountType) {
  OrderAmountType["Base"] = "Base";
  OrderAmountType["Quote"] = "Quote";
})(OrderAmountType || (OrderAmountType = {}));
class OrderAmount {
  constructor(type, value) {
    this.type = void 0;
    this.value = void 0;
    this.type = type;
    this.value = value;
  }
  get isBase() {
    return this.type === OrderAmountType.Base;
  }
  get isQuote() {
    return this.type === OrderAmountType.Quote;
  }
  isSame(other) {
    return this.isBase && other.isBase || this.isQuote && other.isQuote;
  }
  copyType(amount) {
    return new OrderAmount(this.type, amount);
  }
  associatedAsset(id) {
    if (this.type === OrderAmountType.Base) {
      return id.base;
    } else {
      return id.quote;
    }
  }
  static averagePrice(input, output) {
    if (input.isQuote) {
      return (0, _utils.safeDivide)(input.value, output.value);
    } else {
      return (0, _utils.safeDivide)(output.value, input.value);
    }
  }
  add(other) {
    if (!this.isSame(other)) throw new Error('');
    const result = this.value.add(other.value);
    return this.copyType(result);
  }
  sub(other) {
    if (!this.isSame(other)) throw new Error('');
    const result = this.value.sub(other.value);
    return this.copyType(result);
  }
}
const orderBookCanExchange = (baseAssetId, inputAsset, outputAsset, payload) => {
  const id = assembleOrderBookId(baseAssetId, inputAsset, outputAsset);
  if (!id) return false;
  const book = getOrderBook(id, payload);
  if (!book) return false;
  return book.status === _consts2.OrderBookStatus.Trade;
};
exports.orderBookCanExchange = orderBookCanExchange;
const getOrderBook = (id, payload) => {
  return payload.reserves.orderBook[id.base];
};

// assemble_order_book_id
const assembleOrderBookId = (baseAssetId, inputAsset, outputAsset) => {
  // trick
  const dexId = (0, _utils.isAssetAddress)(baseAssetId, _consts.Consts.XOR) ? 0 : 1;
  if ((0, _utils.isAssetAddress)(inputAsset, outputAsset)) return null;
  if ((0, _utils.isAssetAddress)(inputAsset, baseAssetId)) {
    return {
      dexId,
      base: outputAsset,
      quote: inputAsset
    };
  } else if ((0, _utils.isAssetAddress)(outputAsset, baseAssetId)) {
    return {
      dexId,
      base: inputAsset,
      quote: outputAsset
    };
  } else {
    return null;
  }
};

// get_direction
const getDirection = (book, inputAsset, outputAsset) => {
  const {
    base,
    quote
  } = book.orderBookId;
  if ((0, _utils.isAssetAddress)(base, outputAsset) && (0, _utils.isAssetAddress)(quote, inputAsset)) {
    return _consts.PriceVariant.Buy;
  }
  if ((0, _utils.isAssetAddress)(base, inputAsset) && (0, _utils.isAssetAddress)(quote, outputAsset)) {
    return _consts.PriceVariant.Sell;
  }
  throw new Error('Invalid Assets');
};

// align_amount
const alignAmount = (amount, book) => {
  // get rounded by stepLotSize steps
  const steps = Math.floor((0, _utils.safeDivide)(amount, book.stepLotSize).toNumber());
  const aligned = _math.FPNumber.fromNatural(steps, amount.precision).mul(book.stepLotSize);
  return aligned;
};
const bestAsk = book => {
  const asks = book.aggregated.asks;
  if (!asks.length) return null;
  return _math.FPNumber.min(...asks.map(_ref => {
    let [price, _] = _ref;
    return price;
  }));
};
const bestBid = book => {
  const bids = book.aggregated.bids;
  if (!bids.length) return null;
  return _math.FPNumber.max(...bids.map(_ref2 => {
    let [price, _] = _ref2;
    return price;
  }));
};

// sum_market
const sumMarket = (book, marketData, depthLimit) => {
  let marketBaseVolume = _math.FPNumber.ZERO;
  let marketQuoteVolume = _math.FPNumber.ZERO;
  let enoughLiquidity = false;
  for (const [price, baseVolume] of marketData) {
    let quoteVolume = price.mul(baseVolume);
    let limit = depthLimit;
    if (depthLimit) {
      if (limit.isBase) {
        let baseLimit = limit.value;
        if (_math.FPNumber.isGreaterThanOrEqualTo(marketBaseVolume.add(baseVolume), baseLimit)) {
          const delta = alignAmount(baseLimit.sub(marketBaseVolume), book);
          marketBaseVolume = marketBaseVolume.add(delta);
          marketQuoteVolume = marketQuoteVolume.add(price.mul(delta));
          enoughLiquidity = true;
          break;
        }
      } else {
        let quoteLimit = limit.value;
        if (_math.FPNumber.isGreaterThanOrEqualTo(marketQuoteVolume.add(quoteLimit), quoteLimit)) {
          const delta = alignAmount((0, _utils.safeDivide)(quoteLimit.sub(marketQuoteVolume), price), book);
          marketBaseVolume = marketBaseVolume.add(delta);
          marketQuoteVolume = marketQuoteVolume.add(price.mul(delta));
          enoughLiquidity = true;
          break;
        }
      }
    }
    marketBaseVolume = marketBaseVolume.add(baseVolume);
    marketQuoteVolume = marketQuoteVolume.add(quoteVolume);
  }
  if (!(!depthLimit || enoughLiquidity)) {
    throw new Error(_consts.Errors.NotEnoughLiquidityInOrderBook);
  }
  return [new OrderAmount(OrderAmountType.Base, marketBaseVolume), new OrderAmount(OrderAmountType.Quote, marketQuoteVolume)];
};

// calculate_deal
const calculateDeal = (book, inputAsset, outputAsset, amount, isDesiredInput) => {
  const direction = getDirection(book, inputAsset, outputAsset);
  const isBuyDirection = direction === _consts.PriceVariant.Buy;
  let base;
  let quote;
  if (isDesiredInput) {
    if (isBuyDirection) {
      [base, quote] = sumMarket(book, book.aggregated.asks, new OrderAmount(OrderAmountType.Quote, amount.dp(book.tickSize.precision)));
    } else {
      [base, quote] = sumMarket(book, book.aggregated.bids, new OrderAmount(OrderAmountType.Base, amount.dp(book.stepLotSize.precision)));
    }
  } else {
    if (isBuyDirection) {
      [base, quote] = sumMarket(book, book.aggregated.asks, new OrderAmount(OrderAmountType.Base, amount.dp(book.stepLotSize.precision)));
    } else {
      [base, quote] = sumMarket(book, book.aggregated.bids, new OrderAmount(OrderAmountType.Quote, amount.dp(book.tickSize.precision)));
    }
  }
  if (!(base.value.isGtZero() && quote.value.isGtZero())) {
    throw new Error(_consts.Errors.InvalidOrderAmount);
  }
  const [inputAmount, outputAmount] = isBuyDirection ? [quote, base] : [base, quote];
  const averagePrice = OrderAmount.averagePrice(inputAmount, outputAmount);
  return {
    inputAsset,
    inputAmount,
    outputAsset,
    outputAmount,
    averagePrice,
    direction
  };
};

// quote
const orderBookQuote = function (baseAssetId, inputAsset, outputAsset, amount, isDesiredInput, payload) {
  let _deduceFee = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;
  try {
    const id = assembleOrderBookId(baseAssetId, inputAsset, outputAsset);
    if (!id) throw new Error(_consts.Errors.UnknownOrderBook);
    const book = getOrderBook(id, payload);
    if (!book) throw new Error(_consts.Errors.UnknownOrderBook);
    const dealInfo = calculateDeal(book, inputAsset, outputAsset, amount, isDesiredInput);

    // order-book doesn't take fee
    const fee = _math.FPNumber.ZERO;
    if (isDesiredInput) {
      return {
        amount: dealInfo.outputAmount.value,
        fee,
        rewards: [],
        distribution: [{
          market: _consts.LiquiditySourceTypes.OrderBook,
          input: inputAsset,
          output: outputAsset,
          income: amount,
          outcome: dealInfo.outputAmount.value,
          fee
        }]
      };
    } else {
      return {
        amount: dealInfo.inputAmount.value,
        fee,
        rewards: [],
        distribution: [{
          market: _consts.LiquiditySourceTypes.OrderBook,
          input: inputAsset,
          output: outputAsset,
          income: dealInfo.inputAmount.value,
          outcome: amount,
          fee
        }]
      };
    }
  } catch {
    return (0, _utils.safeQuoteResult)(inputAsset, outputAsset, amount, _consts.LiquiditySourceTypes.OrderBook);
  }
};

// quote_without_impact
exports.orderBookQuote = orderBookQuote;
const orderBookQuoteWithoutImpact = function (baseAssetId, inputAsset, outputAsset, amount, isDesiredInput, payload) {
  let _deduceFee = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;
  try {
    const id = assembleOrderBookId(baseAssetId, inputAsset, outputAsset);
    if (!id) throw new Error(_consts.Errors.UnknownOrderBook);
    const book = getOrderBook(id, payload);
    if (!book) throw new Error(_consts.Errors.UnknownOrderBook);
    const direction = getDirection(book, inputAsset, outputAsset);
    const isBuyDirection = direction === _consts.PriceVariant.Buy;
    const price = isBuyDirection ? bestAsk(book) : bestBid(book);
    if (!price) {
      throw new Error(_consts.Errors.NotEnoughLiquidityInOrderBook);
    }
    let targetAmount;
    if (isDesiredInput) {
      if (isBuyDirection) {
        targetAmount = alignAmount((0, _utils.safeDivide)(amount.dp(book.tickSize.precision), price), book);
      } else {
        targetAmount = alignAmount(amount.dp(book.stepLotSize.precision).mul(price), book);
      }
    } else {
      if (isBuyDirection) {
        targetAmount = alignAmount(amount.dp(book.stepLotSize.precision).mul(price), book);
      } else {
        targetAmount = alignAmount((0, _utils.safeDivide)(amount.dp(book.tickSize.precision), price), book);
      }
    }
    if (!targetAmount.isGtZero()) {
      throw new Error(_consts.Errors.InvalidOrderAmount);
    }
    return targetAmount;
  } catch {
    return _math.FPNumber.ZERO;
  }
};
exports.orderBookQuoteWithoutImpact = orderBookQuoteWithoutImpact;